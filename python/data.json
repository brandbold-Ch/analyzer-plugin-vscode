[
  {
    "package": "redis",
    "base": {
      "functions": [
        {
          "name": "default_backoff",
          "doc": null,
          "signature": "()"
        },
        {
          "name": "from_url",
          "doc": "Returns an active Redis client generated from the given database URL.\n\nWill attempt to extract the database id from the path url fragment, if\nnone is provided.",
          "signature": "(url, **kwargs)"
        },
        {
          "name": "int_or_str",
          "doc": null,
          "signature": "(value)"
        }
      ],
      "classes": [
        {
          "name": "AuthenticationError",
          "doc": "Common base class for all non-exit exceptions.",
          "functions": []
        },
        {
          "name": "AuthenticationWrongNumberOfArgsError",
          "doc": "An error to indicate that the wrong number of args\nwere sent to the AUTH command",
          "functions": []
        },
        {
          "name": "BlockingConnectionPool",
          "doc": "Thread-safe blocking connection pool::\n\n    >>> from redis.client import Redis\n    >>> client = Redis(connection_pool=BlockingConnectionPool())\n\nIt performs the same function as the default\n:py:class:`~redis.ConnectionPool` implementation, in that,\nit maintains a pool of reusable connections that can be shared by\nmultiple redis clients (safely across threads if required).\n\nThe difference is that, in the event that a client tries to get a\nconnection from the pool when all of connections are in use, rather than\nraising a :py:class:`~redis.ConnectionError` (as the default\n:py:class:`~redis.ConnectionPool` implementation does), it\nmakes the client wait (\"blocks\") for a specified number of seconds until\na connection becomes available.\n\nUse ``max_connections`` to increase / decrease the pool size::\n\n    >>> pool = BlockingConnectionPool(max_connections=10)\n\nUse ``timeout`` to tell it either how many seconds to wait for a connection\nto become available, or to block forever:\n\n    >>> # Block forever.\n    >>> pool = BlockingConnectionPool(timeout=None)\n\n    >>> # Raise a ``ConnectionError`` after five seconds if a connection is\n    >>> # not available.\n    >>> pool = BlockingConnectionPool(timeout=5)",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, max_connections=50, timeout=20, connection_class=<class 'redis.connection.Connection'>, queue_class=<class 'queue.LifoQueue'>, **connection_kwargs)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> (<class 'str'>, <class 'str'>)"
            },
            {
              "name": "_checkpid",
              "doc": null,
              "signature": "(self) -> None"
            },
            {
              "name": "_mock",
              "doc": "Dummy functions, needs to be passed as error callback to retry object.\n:param error:\n:return:",
              "signature": "(self, error: redis.exceptions.RedisError)"
            },
            {
              "name": "close",
              "doc": "Close the pool, disconnecting all connections",
              "signature": "(self) -> None"
            },
            {
              "name": "disconnect",
              "doc": "Disconnects all connections in the pool.",
              "signature": "(self)"
            },
            {
              "name": "get_connection",
              "doc": "Get a connection, blocking for ``self.timeout`` until a connection\nis available from the pool.\n\nIf the connection returned is ``None`` then creates a new connection.\nBecause we use a last-in first-out queue, the existing connections\n(having been returned to the pool after the initial ``None`` values\nwere added) will be returned before ``None`` values. This means we only\ncreate new connections when we need to, i.e.: the actual number of\nconnections will only increase in response to demand.",
              "signature": "(self, command_name=None, *keys, **options)"
            },
            {
              "name": "get_encoder",
              "doc": "Return an encoder based on encoding settings",
              "signature": "(self) -> redis._parsers.encoders.Encoder"
            },
            {
              "name": "get_protocol",
              "doc": "Returns:\n    The RESP protocol version, or ``None`` if the protocol is not specified,\n    in which case the server default will be used.",
              "signature": "(self)"
            },
            {
              "name": "make_connection",
              "doc": "Make a fresh connection.",
              "signature": "(self)"
            },
            {
              "name": "owns_connection",
              "doc": null,
              "signature": "(self, connection: 'Connection') -> int"
            },
            {
              "name": "re_auth_callback",
              "doc": null,
              "signature": "(self, token: redis.auth.token.TokenInterface)"
            },
            {
              "name": "release",
              "doc": "Releases the connection back to the pool.",
              "signature": "(self, connection)"
            },
            {
              "name": "reset",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "set_retry",
              "doc": null,
              "signature": "(self, retry: redis.retry.Retry) -> None"
            }
          ]
        },
        {
          "name": "BusyLoadingError",
          "doc": "Common base class for all non-exit exceptions.",
          "functions": []
        },
        {
          "name": "ChildDeadlockedError",
          "doc": "Error indicating that a child process is deadlocked after a fork()",
          "functions": []
        },
        {
          "name": "Connection",
          "doc": "Manages TCP communication to and from a Redis server",
          "functions": [
            {
              "name": "__del__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize a new Connection.\nTo specify a retry policy for specific errors, first set\n`retry_on_error` to a list of the error/s to retry on, then set\n`retry` to a valid `Retry` object.\nTo retry on TimeoutError, `retry_on_timeout` can also be set to `True`.",
              "signature": "(self, host='localhost', port=6379, socket_keepalive=False, socket_keepalive_options=None, socket_type=0, **kwargs)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "_connect",
              "doc": "Create a TCP socket connection",
              "signature": "(self)"
            },
            {
              "name": "_construct_command_packer",
              "doc": null,
              "signature": "(self, packer)"
            },
            {
              "name": "_error_message",
              "doc": null,
              "signature": "(self, exception)"
            },
            {
              "name": "_host_error",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_ping_failed",
              "doc": "Function to call when PING fails",
              "signature": "(self, error)"
            },
            {
              "name": "_send_ping",
              "doc": "Send PING, expect PONG in return",
              "signature": "(self)"
            },
            {
              "name": "can_read",
              "doc": "Poll the socket to see if there's data that can be read.",
              "signature": "(self, timeout=0)"
            },
            {
              "name": "check_health",
              "doc": "Check the health of the connection with a PING/PONG",
              "signature": "(self)"
            },
            {
              "name": "connect",
              "doc": "Connects to the Redis server if not already connected",
              "signature": "(self)"
            },
            {
              "name": "connect_check_health",
              "doc": null,
              "signature": "(self, check_health: bool = True)"
            },
            {
              "name": "deregister_connect_callback",
              "doc": "De-register a previously registered callback.  It will no-longer receive\nnotifications on connection events.  Calling this is not required when the\nlistener goes away, since the callbacks are kept as weak methods.",
              "signature": "(self, callback)"
            },
            {
              "name": "disconnect",
              "doc": "Disconnects from the Redis server",
              "signature": "(self, *args)"
            },
            {
              "name": "get_protocol",
              "doc": null,
              "signature": "(self) -> Union[int, str]"
            },
            {
              "name": "on_connect",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "on_connect_check_health",
              "doc": "Initialize the connection, authenticate and select a database",
              "signature": "(self, check_health: bool = True)"
            },
            {
              "name": "pack_command",
              "doc": "Pack a series of arguments into the Redis protocol",
              "signature": "(self, *args)"
            },
            {
              "name": "pack_commands",
              "doc": "Pack multiple commands into the Redis protocol",
              "signature": "(self, commands)"
            },
            {
              "name": "re_auth",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "read_response",
              "doc": "Read the response from a previously sent command",
              "signature": "(self, disable_decoding=False, *, disconnect_on_error=True, push_request=False)"
            },
            {
              "name": "register_connect_callback",
              "doc": "Register a callback to be called when the connection is established either\ninitially or reconnected.  This allows listeners to issue commands that\nare ephemeral to the connection, for example pub/sub subscription or\nkey tracking.  The callback must be a _method_ and will be kept as\na weak reference.",
              "signature": "(self, callback)"
            },
            {
              "name": "repr_pieces",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "send_command",
              "doc": "Pack and send a command to the Redis server",
              "signature": "(self, *args, **kwargs)"
            },
            {
              "name": "send_packed_command",
              "doc": "Send an already packed command to the Redis server",
              "signature": "(self, command, check_health=True)"
            },
            {
              "name": "set_parser",
              "doc": "Creates a new instance of parser_class with socket size:\n_socket_read_size and assigns it to the parser for the connection\n:param parser_class: The required parser class",
              "signature": "(self, parser_class)"
            },
            {
              "name": "set_re_auth_token",
              "doc": null,
              "signature": "(self, token: redis.auth.token.TokenInterface)"
            }
          ]
        },
        {
          "name": "ConnectionError",
          "doc": "Common base class for all non-exit exceptions.",
          "functions": []
        },
        {
          "name": "ConnectionPool",
          "doc": "Create a connection pool. ``If max_connections`` is set, then this\nobject raises :py:class:`~redis.exceptions.ConnectionError` when the pool's\nlimit is reached.\n\nBy default, TCP connections are created unless ``connection_class``\nis specified. Use class:`.UnixDomainSocketConnection` for\nunix sockets.\n\nAny additional keyword arguments are passed to the constructor of\n``connection_class``.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, connection_class=<class 'redis.connection.Connection'>, max_connections: Optional[int] = None, cache_factory: Optional[redis.cache.CacheFactoryInterface] = None, **connection_kwargs)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> (<class 'str'>, <class 'str'>)"
            },
            {
              "name": "_checkpid",
              "doc": null,
              "signature": "(self) -> None"
            },
            {
              "name": "_mock",
              "doc": "Dummy functions, needs to be passed as error callback to retry object.\n:param error:\n:return:",
              "signature": "(self, error: redis.exceptions.RedisError)"
            },
            {
              "name": "close",
              "doc": "Close the pool, disconnecting all connections",
              "signature": "(self) -> None"
            },
            {
              "name": "disconnect",
              "doc": "Disconnects connections in the pool\n\nIf ``inuse_connections`` is True, disconnect connections that are\ncurrent in use, potentially by other threads. Otherwise only disconnect\nconnections that are idle in the pool.",
              "signature": "(self, inuse_connections: bool = True) -> None"
            },
            {
              "name": "get_connection",
              "doc": "Get a connection from the pool",
              "signature": "(self, command_name=None, *keys, **options) -> 'Connection'"
            },
            {
              "name": "get_encoder",
              "doc": "Return an encoder based on encoding settings",
              "signature": "(self) -> redis._parsers.encoders.Encoder"
            },
            {
              "name": "get_protocol",
              "doc": "Returns:\n    The RESP protocol version, or ``None`` if the protocol is not specified,\n    in which case the server default will be used.",
              "signature": "(self)"
            },
            {
              "name": "make_connection",
              "doc": "Create a new connection",
              "signature": "(self) -> 'ConnectionInterface'"
            },
            {
              "name": "owns_connection",
              "doc": null,
              "signature": "(self, connection: 'Connection') -> int"
            },
            {
              "name": "re_auth_callback",
              "doc": null,
              "signature": "(self, token: redis.auth.token.TokenInterface)"
            },
            {
              "name": "release",
              "doc": "Releases the connection back to the pool",
              "signature": "(self, connection: 'Connection') -> None"
            },
            {
              "name": "reset",
              "doc": null,
              "signature": "(self) -> None"
            },
            {
              "name": "set_retry",
              "doc": null,
              "signature": "(self, retry: redis.retry.Retry) -> None"
            }
          ]
        },
        {
          "name": "CredentialProvider",
          "doc": "Credentials Provider.",
          "functions": [
            {
              "name": "get_credentials",
              "doc": null,
              "signature": "(self) -> Union[Tuple[str], Tuple[str, str]]"
            },
            {
              "name": "get_credentials_async",
              "doc": null,
              "signature": "(self) -> Union[Tuple[str], Tuple[str, str]]"
            }
          ]
        },
        {
          "name": "CrossSlotTransactionError",
          "doc": "Raised when a transaction or watch is triggered in a pipeline\nand not all keys or all commands belong to the same slot.",
          "functions": []
        },
        {
          "name": "DataError",
          "doc": "Common base class for all non-exit exceptions.",
          "functions": []
        },
        {
          "name": "InvalidPipelineStack",
          "doc": "Raised on unexpected response length on pipelines. This is\nmost likely a handling error on the stack.",
          "functions": []
        },
        {
          "name": "InvalidResponse",
          "doc": "Common base class for all non-exit exceptions.",
          "functions": []
        },
        {
          "name": "OutOfMemoryError",
          "doc": "Indicates the database is full. Can only occur when either:\n  * Redis maxmemory-policy=noeviction\n  * Redis maxmemory-policy=volatile* and there are no evictable keys\n\nFor more information see `Memory optimization in Redis <https://redis.io/docs/management/optimization/memory-optimization/#memory-allocation>`_. # noqa",
          "functions": []
        },
        {
          "name": "PubSubError",
          "doc": "Common base class for all non-exit exceptions.",
          "functions": []
        },
        {
          "name": "ReadOnlyError",
          "doc": "Common base class for all non-exit exceptions.",
          "functions": []
        },
        {
          "name": "Redis",
          "doc": "Implementation of the Redis protocol.\n\nThis abstract class provides a Python interface to all Redis commands\nand an implementation of the Redis protocol.\n\nPipelines derive from this, implementing how\nthe commands are sent and received to the Redis server. Based on\nconfiguration, an instance will either use a ConnectionPool, or\nConnection object to talk to redis.\n\nIt is not safe to pass PubSub or Pipeline objects between threads.",
          "functions": [
            {
              "name": "__contains__",
              "doc": "Returns the number of ``names`` that exist\n\nFor more information see https://redis.io/commands/exists",
              "signature": "(self, *names: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "__del__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__delitem__",
              "doc": null,
              "signature": "(self, name: Union[bytes, str, memoryview])"
            },
            {
              "name": "__enter__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__exit__",
              "doc": null,
              "signature": "(self, exc_type, exc_value, traceback)"
            },
            {
              "name": "__getitem__",
              "doc": "Return the value at key ``name``, raises a KeyError if the key\ndoesn't exist.",
              "signature": "(self, name: Union[bytes, str, memoryview])"
            },
            {
              "name": "__init__",
              "doc": "Initialize a new Redis client.\n\nTo specify a retry policy for specific errors, you have two options:\n\n1. Set the `retry_on_error` to a list of the error/s to retry on, and\nyou can also set `retry` to a valid `Retry` object(in case the default\none is not appropriate) - with this approach the retries will be triggered\non the default errors specified in the Retry object enriched with the\nerrors specified in `retry_on_error`.\n\n2. Define a `Retry` object with configured 'supported_errors' and set\nit to the `retry` parameter - with this approach you completely redefine\nthe errors on which retries will happen.\n\n`retry_on_timeout` is deprecated - please include the TimeoutError\neither in the Retry object or in the `retry_on_error` list.\n\nWhen 'connection_pool' is provided - the retry configuration of the\nprovided pool will be used.\n\nArgs:\n\nsingle_connection_client:\n    if `True`, connection pool is not used. In that case `Redis`\n    instance use is not thread safe.",
              "signature": "(self, host: str = 'localhost', port: int = 6379, db: int = 0, password: Optional[str] = None, socket_timeout: Optional[float] = None, socket_connect_timeout: Optional[float] = None, socket_keepalive: Optional[bool] = None, socket_keepalive_options: Optional[Mapping[int, Union[int, bytes]]] = None, connection_pool: Optional[redis.connection.ConnectionPool] = None, unix_socket_path: Optional[str] = None, encoding: str = 'utf-8', encoding_errors: str = 'strict', decode_responses: bool = False, retry_on_timeout: bool = False, retry: redis.retry.Retry = <redis.retry.Retry object at 0x0000023EF683A6D0>, retry_on_error: Optional[List[Type[Exception]]] = None, ssl: bool = False, ssl_keyfile: Optional[str] = None, ssl_certfile: Optional[str] = None, ssl_cert_reqs: Union[str, ForwardRef('ssl.VerifyMode')] = 'required', ssl_ca_certs: Optional[str] = None, ssl_ca_path: Optional[str] = None, ssl_ca_data: Optional[str] = None, ssl_check_hostname: bool = True, ssl_password: Optional[str] = None, ssl_validate_ocsp: bool = False, ssl_validate_ocsp_stapled: bool = False, ssl_ocsp_context: Optional[ForwardRef('OpenSSL.SSL.Context')] = None, ssl_ocsp_expected_cert: Optional[str] = None, ssl_min_version: Optional[ForwardRef('ssl.TLSVersion')] = None, ssl_ciphers: Optional[str] = None, max_connections: Optional[int] = None, single_connection_client: bool = False, health_check_interval: int = 0, client_name: Optional[str] = None, lib_name: Optional[str] = 'redis-py', lib_version: Optional[str] = '6.2.0', username: Optional[str] = None, redis_connect_func: Optional[Callable[[], NoneType]] = None, credential_provider: Optional[redis.credentials.CredentialProvider] = None, protocol: Optional[int] = 2, cache: Optional[redis.cache.CacheInterface] = None, cache_config: Optional[redis.cache.CacheConfig] = None, event_dispatcher: Optional[redis.event.EventDispatcher] = None) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "__setitem__",
              "doc": null,
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float])"
            },
            {
              "name": "_close_connection",
              "doc": "Close the connection before retrying.\n\nThe supported exceptions are already checked in the\nretry object so we don't need to do it here.\n\nAfter we disconnect the connection, it will try to reconnect and\ndo a health check as part of the send_command logic(on connection level).",
              "signature": "(self, conn) -> None"
            },
            {
              "name": "_eval",
              "doc": null,
              "signature": "(self, command: str, script: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "_evalsha",
              "doc": null,
              "signature": "(self, command: str, sha: str, numkeys: int, *keys_and_args: list) -> Union[Awaitable[str], str]"
            },
            {
              "name": "_execute_command",
              "doc": "Execute a command and return a parsed response",
              "signature": "(self, *args, **options)"
            },
            {
              "name": "_fcall",
              "doc": null,
              "signature": "(self, command: str, function, numkeys: int, *keys_and_args: Any) -> Union[Awaitable[str], str]"
            },
            {
              "name": "_georadiusgeneric",
              "doc": null,
              "signature": "(self, command: str, *args: Union[bytes, bytearray, memoryview, str, int, float], **kwargs: Union[bytes, bytearray, memoryview, str, int, float, NoneType]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "_geosearchgeneric",
              "doc": null,
              "signature": "(self, command: str, *args: Union[bytes, bytearray, memoryview, str, int, float], **kwargs: Union[bytes, bytearray, memoryview, str, int, float, NoneType]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "_send_command_parse_response",
              "doc": "Send a command and parse the response",
              "signature": "(self, conn, command_name, *args, **options)"
            },
            {
              "name": "_zaggregate",
              "doc": null,
              "signature": "(self, command: str, dest: Union[bytes, str, memoryview, NoneType], keys: Union[Sequence[Union[bytes, str, memoryview]], Mapping[~AnyKeyT, float]], aggregate: Optional[str] = None, **options) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "_zrange",
              "doc": null,
              "signature": "(self, command, dest: Union[bytes, str, memoryview, NoneType], name: Union[bytes, str, memoryview], start: int, end: int, desc: bool = False, byscore: bool = False, bylex: bool = False, withscores: bool = False, score_cast_func: Union[type, Callable, NoneType] = <class 'float'>, offset: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_cat",
              "doc": "Returns a list of categories or commands within a category.\n\nIf ``category`` is not supplied, returns a list of all categories.\nIf ``category`` is supplied, returns a list of all commands within\nthat category.\n\nFor more information see https://redis.io/commands/acl-cat",
              "signature": "(self, category: Optional[str] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_deluser",
              "doc": "Delete the ACL for the specified ``username``\\s\n\nFor more information see https://redis.io/commands/acl-deluser",
              "signature": "(self, *username: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_dryrun",
              "doc": "Simulate the execution of a given command by a given ``username``.\n\nFor more information see https://redis.io/commands/acl-dryrun",
              "signature": "(self, username, *args, **kwargs)"
            },
            {
              "name": "acl_genpass",
              "doc": "Generate a random password value.\nIf ``bits`` is supplied then use this number of bits, rounded to\nthe next multiple of 4.\nSee: https://redis.io/commands/acl-genpass",
              "signature": "(self, bits: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_getuser",
              "doc": "Get the ACL details for the specified ``username``.\n\nIf ``username`` does not exist, return None\n\nFor more information see https://redis.io/commands/acl-getuser",
              "signature": "(self, username: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_help",
              "doc": "The ACL HELP command returns helpful text describing\nthe different subcommands.\n\nFor more information see https://redis.io/commands/acl-help",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_list",
              "doc": "Return a list of all ACLs on the server\n\nFor more information see https://redis.io/commands/acl-list",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_load",
              "doc": "Load ACL rules from the configured ``aclfile``.\n\nNote that the server must be configured with the ``aclfile``\ndirective to be able to load ACL rules from an aclfile.\n\nFor more information see https://redis.io/commands/acl-load",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_log",
              "doc": "Get ACL logs as a list.\n:param int count: Get logs[0:count].\n:rtype: List.\n\nFor more information see https://redis.io/commands/acl-log",
              "signature": "(self, count: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_log_reset",
              "doc": "Reset ACL logs.\n:rtype: Boolean.\n\nFor more information see https://redis.io/commands/acl-log",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_save",
              "doc": "Save ACL rules to the configured ``aclfile``.\n\nNote that the server must be configured with the ``aclfile``\ndirective to be able to save ACL rules to an aclfile.\n\nFor more information see https://redis.io/commands/acl-save",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_setuser",
              "doc": "Create or update an ACL user.\n\nCreate or update the ACL for `username`. If the user already exists,\nthe existing ACL is completely overwritten and replaced with the\nspecified values.\n\nFor more information, see https://redis.io/commands/acl-setuser\n\nArgs:\n    username: The name of the user whose ACL is to be created or updated.\n    enabled: Indicates whether the user should be allowed to authenticate.\n             Defaults to `False`.\n    nopass: Indicates whether the user can authenticate without a password.\n            This cannot be `True` if `passwords` are also specified.\n    passwords: A list of plain text passwords to add to or remove from the user.\n               Each password must be prefixed with a '+' to add or a '-' to\n               remove. For convenience, a single prefixed string can be used\n               when adding or removing a single password.\n    hashed_passwords: A list of SHA-256 hashed passwords to add to or remove\n                      from the user. Each hashed password must be prefixed with\n                      a '+' to add or a '-' to remove. For convenience, a single\n                      prefixed string can be used when adding or removing a\n                      single password.\n    categories: A list of strings representing category permissions. Each string\n                must be prefixed with either a '+' to add the category\n                permission or a '-' to remove the category permission.\n    commands: A list of strings representing command permissions. Each string\n              must be prefixed with either a '+' to add the command permission\n              or a '-' to remove the command permission.\n    keys: A list of key patterns to grant the user access to. Key patterns allow\n          ``'*'`` to support wildcard matching. For example, ``'*'`` grants\n          access to all keys while ``'cache:*'`` grants access to all keys that\n          are prefixed with ``cache:``.\n          `keys` should not be prefixed with a ``'~'``.\n    reset: Indicates whether the user should be fully reset prior to applying\n           the new ACL. Setting this to `True` will remove all existing\n           passwords, flags, and privileges from the user and then apply the\n           specified rules. If `False`, the user's existing passwords, flags,\n           and privileges will be kept and any new specified rules will be\n           applied on top.\n    reset_keys: Indicates whether the user's key permissions should be reset\n                prior to applying any new key permissions specified in `keys`.\n                If `False`, the user's existing key permissions will be kept and\n                any new specified key permissions will be applied on top.\n    reset_channels: Indicates whether the user's channel permissions should be\n                    reset prior to applying any new channel permissions\n                    specified in `channels`. If `False`, the user's existing\n                    channel permissions will be kept and any new specified\n                    channel permissions will be applied on top.\n    reset_passwords: Indicates whether to remove all existing passwords and the\n                     `nopass` flag from the user prior to applying any new\n                     passwords specified in `passwords` or `hashed_passwords`.\n                     If `False`, the user's existing passwords and `nopass`\n                     status will be kept and any new specified passwords or\n                     hashed passwords will be applied on top.",
              "signature": "(self, username: str, enabled: bool = False, nopass: bool = False, passwords: Union[str, Iterable[str], NoneType] = None, hashed_passwords: Union[str, Iterable[str], NoneType] = None, categories: Optional[Iterable[str]] = None, commands: Optional[Iterable[str]] = None, keys: Optional[Iterable[Union[bytes, str, memoryview]]] = None, channels: Optional[Iterable[Union[bytes, str, memoryview]]] = None, selectors: Optional[Iterable[Tuple[str, Union[bytes, str, memoryview]]]] = None, reset: bool = False, reset_keys: bool = False, reset_channels: bool = False, reset_passwords: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_users",
              "doc": "Returns a list of all registered users on the server.\n\nFor more information see https://redis.io/commands/acl-users",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_whoami",
              "doc": "Get the username for the current connection\n\nFor more information see https://redis.io/commands/acl-whoami",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "append",
              "doc": "Appends the string ``value`` to the value at ``key``. If ``key``\ndoesn't already exist, create it with a value of ``value``.\nReturns the new length of the value at ``key``.\n\nFor more information see https://redis.io/commands/append",
              "signature": "(self, key: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "auth",
              "doc": "Authenticates the user. If you do not pass username, Redis will try to\nauthenticate for the \"default\" user. If you do pass username, it will\nauthenticate for the given user.\nFor more information see https://redis.io/commands/auth",
              "signature": "(self, password: str, username: Optional[str] = None, **kwargs)"
            },
            {
              "name": "bf",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'BFBloom'"
            },
            {
              "name": "bgrewriteaof",
              "doc": "Tell the Redis server to rewrite the AOF file from data in memory.\n\nFor more information see https://redis.io/commands/bgrewriteaof",
              "signature": "(self, **kwargs)"
            },
            {
              "name": "bgsave",
              "doc": "Tell the Redis server to save its data to disk.  Unlike save(),\nthis method is asynchronous and returns immediately.\n\nFor more information see https://redis.io/commands/bgsave",
              "signature": "(self, schedule: bool = True, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bitcount",
              "doc": "Returns the count of set bits in the value of ``key``.  Optional\n``start`` and ``end`` parameters indicate which bytes to consider\n\nFor more information see https://redis.io/commands/bitcount",
              "signature": "(self, key: Union[bytes, str, memoryview], start: Optional[int] = None, end: Optional[int] = None, mode: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bitfield",
              "doc": "Return a BitFieldOperation instance to conveniently construct one or\nmore bitfield operations on ``key``.\n\nFor more information see https://redis.io/commands/bitfield",
              "signature": "(self: Union[ForwardRef('redis.client.Redis'), ForwardRef('redis.asyncio.client.Redis')], key: Union[bytes, str, memoryview], default_overflow: Optional[str] = None) -> redis.commands.core.BitFieldOperation"
            },
            {
              "name": "bitfield_ro",
              "doc": "Return an array of the specified bitfield values\nwhere the first value is found using ``encoding`` and ``offset``\nparameters and remaining values are result of corresponding\nencoding/offset pairs in optional list ``items``\nRead-only variant of the BITFIELD command.\n\nFor more information see https://redis.io/commands/bitfield_ro",
              "signature": "(self: Union[ForwardRef('redis.client.Redis'), ForwardRef('redis.asyncio.client.Redis')], key: Union[bytes, str, memoryview], encoding: str, offset: Union[int, str], items: Optional[list] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bitop",
              "doc": "Perform a bitwise operation using ``operation`` between ``keys`` and\nstore the result in ``dest``.\n\nFor more information see https://redis.io/commands/bitop",
              "signature": "(self, operation: str, dest: Union[bytes, str, memoryview], *keys: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bitpos",
              "doc": "Return the position of the first bit set to 1 or 0 in a string.\n``start`` and ``end`` defines search range. The range is interpreted\nas a range of bytes and not a range of bits, so start=0 and end=2\nmeans to look at the first three bytes.\n\nFor more information see https://redis.io/commands/bitpos",
              "signature": "(self, key: Union[bytes, str, memoryview], bit: int, start: Optional[int] = None, end: Optional[int] = None, mode: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "blmove",
              "doc": "Blocking version of lmove.\n\nFor more information see https://redis.io/commands/blmove",
              "signature": "(self, first_list: str, second_list: str, timeout: int, src: str = 'LEFT', dest: str = 'RIGHT') -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "blmpop",
              "doc": "Pop ``count`` values (default 1) from first non-empty in the list\nof provided key names.\n\nWhen all lists are empty this command blocks the connection until another\nclient pushes to it or until the timeout, timeout of 0 blocks indefinitely\n\nFor more information see https://redis.io/commands/blmpop",
              "signature": "(self, timeout: float, numkeys: int, *args: List[str], direction: str, count: Optional[int] = 1) -> Optional[list]"
            },
            {
              "name": "blpop",
              "doc": "LPOP a value off of the first non-empty list\nnamed in the ``keys`` list.\n\nIf none of the lists in ``keys`` has a value to LPOP, then block\nfor ``timeout`` seconds, or until a value gets pushed on to one\nof the lists.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/blpop",
              "signature": "(self, keys: List, timeout: Union[int, float, NoneType] = 0) -> Union[Awaitable[list], list]"
            },
            {
              "name": "brpop",
              "doc": "RPOP a value off of the first non-empty list\nnamed in the ``keys`` list.\n\nIf none of the lists in ``keys`` has a value to RPOP, then block\nfor ``timeout`` seconds, or until a value gets pushed on to one\nof the lists.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/brpop",
              "signature": "(self, keys: List, timeout: Union[int, float, NoneType] = 0) -> Union[Awaitable[list], list]"
            },
            {
              "name": "brpoplpush",
              "doc": "Pop a value off the tail of ``src``, push it on the head of ``dst``\nand then return it.\n\nThis command blocks until a value is in ``src`` or until ``timeout``\nseconds elapse, whichever is first. A ``timeout`` value of 0 blocks\nforever.\n\nFor more information see https://redis.io/commands/brpoplpush",
              "signature": "(self, src: str, dst: str, timeout: Union[int, float, NoneType] = 0) -> Union[Awaitable[Optional[str]], str, NoneType]"
            },
            {
              "name": "bzmpop",
              "doc": "Pop ``count`` values (default 1) off of the first non-empty sorted set\nnamed in the ``keys`` list.\n\nIf none of the sorted sets in ``keys`` has a value to pop,\nthen block for ``timeout`` seconds, or until a member gets added\nto one of the sorted sets.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/bzmpop",
              "signature": "(self, timeout: float, numkeys: int, keys: List[str], min: Optional[bool] = False, max: Optional[bool] = False, count: Optional[int] = 1) -> Optional[list]"
            },
            {
              "name": "bzpopmax",
              "doc": "ZPOPMAX a value off of the first non-empty sorted set\nnamed in the ``keys`` list.\n\nIf none of the sorted sets in ``keys`` has a value to ZPOPMAX,\nthen block for ``timeout`` seconds, or until a member gets added\nto one of the sorted sets.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/bzpopmax",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], timeout: Union[int, float, bytes, str, memoryview] = 0) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bzpopmin",
              "doc": "ZPOPMIN a value off of the first non-empty sorted set\nnamed in the ``keys`` list.\n\nIf none of the sorted sets in ``keys`` has a value to ZPOPMIN,\nthen block for ``timeout`` seconds, or until a member gets added\nto one of the sorted sets.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/bzpopmin",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], timeout: Union[int, float, bytes, str, memoryview] = 0) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cf",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'CFBloom'"
            },
            {
              "name": "client",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "client_getname",
              "doc": "Returns the current connection name\n\nFor more information see https://redis.io/commands/client-getname",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_getredir",
              "doc": "Returns the ID (an integer) of the client to whom we are\nredirecting tracking notifications.\n\nsee: https://redis.io/commands/client-getredir",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_id",
              "doc": "Returns the current connection id\n\nFor more information see https://redis.io/commands/client-id",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_info",
              "doc": "Returns information and statistics about the current\nclient connection.\n\nFor more information see https://redis.io/commands/client-info",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_kill",
              "doc": "Disconnects the client at ``address`` (ip:port)\n\nFor more information see https://redis.io/commands/client-kill",
              "signature": "(self, address: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_kill_filter",
              "doc": "Disconnects client(s) using a variety of filter options\n:param _id: Kills a client by its unique ID field\n:param _type: Kills a client by type where type is one of 'normal',\n'master', 'slave' or 'pubsub'\n:param addr: Kills a client by its 'address:port'\n:param skipme: If True, then the client calling the command\nwill not get killed even if it is identified by one of the filter\noptions. If skipme is not provided, the server defaults to skipme=True\n:param laddr: Kills a client by its 'local (bind) address:port'\n:param user: Kills a client for a specific user name\n:param maxage: Kills clients that are older than the specified age in seconds",
              "signature": "(self, _id: Optional[str] = None, _type: Optional[str] = None, addr: Optional[str] = None, skipme: Optional[bool] = None, laddr: Optional[bool] = None, user: Optional[str] = None, maxage: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_list",
              "doc": "Returns a list of currently connected clients.\nIf type of client specified, only that type will be returned.\n\n:param _type: optional. one of the client types (normal, master,\n replica, pubsub)\n:param client_id: optional. a list of client ids\n\nFor more information see https://redis.io/commands/client-list",
              "signature": "(self, _type: Optional[str] = None, client_id: List[Union[bytes, bytearray, memoryview, str, int, float]] = [], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_no_evict",
              "doc": "Sets the client eviction mode for the current connection.\n\nFor more information see https://redis.io/commands/client-no-evict",
              "signature": "(self, mode: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "client_no_touch",
              "doc": "# The command controls whether commands sent by the client will alter\n# the LRU/LFU of the keys they access.\n# When turned on, the current client will not change LFU/LRU stats,\n# unless it sends the TOUCH command.\n\nFor more information see https://redis.io/commands/client-no-touch",
              "signature": "(self, mode: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "client_pause",
              "doc": "Suspend all the Redis clients for the specified amount of time.\n\n\nFor more information see https://redis.io/commands/client-pause\n\nArgs:\n    timeout: milliseconds to pause clients\n    all: If true (default) all client commands are blocked.\n         otherwise, clients are only blocked if they attempt to execute\n         a write command.\n\nFor the WRITE mode, some commands have special behavior:\n\n* EVAL/EVALSHA: Will block client for all scripts.\n* PUBLISH: Will block client.\n* PFCOUNT: Will block client.\n* WAIT: Acknowledgments will be delayed, so this command will\n    appear blocked.",
              "signature": "(self, timeout: int, all: bool = True, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_reply",
              "doc": "Enable and disable redis server replies.\n\n``reply`` Must be ON OFF or SKIP,\nON - The default most with server replies to commands\nOFF - Disable server responses to commands\nSKIP - Skip the response of the immediately following command.\n\nNote: When setting OFF or SKIP replies, you will need a client object\nwith a timeout specified in seconds, and will need to catch the\nTimeoutError.\nThe test_client_reply unit test illustrates this, and\nconftest.py has a client with a timeout.\n\nSee https://redis.io/commands/client-reply",
              "signature": "(self, reply: Union[Literal['ON'], Literal['OFF'], Literal['SKIP']], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_setinfo",
              "doc": "Sets the current connection library name or version\nFor mor information see https://redis.io/commands/client-setinfo",
              "signature": "(self, attr: str, value: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_setname",
              "doc": "Sets the current connection name\n\nFor more information see https://redis.io/commands/client-setname\n\n.. note::\n   This method sets client name only for **current** connection.\n\n   If you want to set a common name for all connections managed\n   by this client, use ``client_name`` constructor argument.",
              "signature": "(self, name: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_tracking",
              "doc": "Enables the tracking feature of the Redis server, that is used\nfor server assisted client side caching.\n\n``on`` indicate for tracking on or tracking off. The dafualt is on.\n\n``clientid`` send invalidation messages to the connection with\nthe specified ID.\n\n``bcast`` enable tracking in broadcasting mode. In this mode\ninvalidation messages are reported for all the prefixes\nspecified, regardless of the keys requested by the connection.\n\n``optin``  when broadcasting is NOT active, normally don't track\nkeys in read only commands, unless they are called immediately\nafter a CLIENT CACHING yes command.\n\n``optout`` when broadcasting is NOT active, normally track keys in\nread only commands, unless they are called immediately after a\nCLIENT CACHING no command.\n\n``noloop`` don't send notifications about keys modified by this\nconnection itself.\n\n``prefix``  for broadcasting, register a given key prefix, so that\nnotifications will be provided only for keys starting with this string.\n\nSee https://redis.io/commands/client-tracking",
              "signature": "(self, on: bool = True, clientid: Optional[int] = None, prefix: Sequence[Union[bytes, str, memoryview]] = [], bcast: bool = False, optin: bool = False, optout: bool = False, noloop: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_tracking_off",
              "doc": "Turn off the tracking mode.\nFor more information about the options look at client_tracking func.\n\nSee https://redis.io/commands/client-tracking",
              "signature": "(self, clientid: Optional[int] = None, prefix: Sequence[Union[bytes, str, memoryview]] = [], bcast: bool = False, optin: bool = False, optout: bool = False, noloop: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_tracking_on",
              "doc": "Turn on the tracking mode.\nFor more information about the options look at client_tracking func.\n\nSee https://redis.io/commands/client-tracking",
              "signature": "(self, clientid: Optional[int] = None, prefix: Sequence[Union[bytes, str, memoryview]] = [], bcast: bool = False, optin: bool = False, optout: bool = False, noloop: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_trackinginfo",
              "doc": "Returns the information about the current client connection's\nuse of the server assisted client side cache.\n\nSee https://redis.io/commands/client-trackinginfo",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_unblock",
              "doc": "Unblocks a connection by its client id.\nIf ``error`` is True, unblocks the client with a special error message.\nIf ``error`` is False (default), the client is unblocked using the\nregular timeout mechanism.\n\nFor more information see https://redis.io/commands/client-unblock",
              "signature": "(self, client_id: int, error: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_unpause",
              "doc": "Unpause all redis clients\n\nFor more information see https://redis.io/commands/client-unpause",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "close",
              "doc": null,
              "signature": "(self) -> None"
            },
            {
              "name": "cluster",
              "doc": null,
              "signature": "(self, cluster_arg, *args, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cms",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'CMSBloom'"
            },
            {
              "name": "command",
              "doc": "Returns dict reply of details about all Redis commands.\n\nFor more information see https://redis.io/commands/command",
              "signature": "(self, **kwargs)"
            },
            {
              "name": "command_count",
              "doc": null,
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "command_docs",
              "doc": "This function throws a NotImplementedError since it is intentionally\nnot supported.",
              "signature": "(self, *args)"
            },
            {
              "name": "command_getkeys",
              "doc": null,
              "signature": "(self, *args) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "command_getkeysandflags",
              "doc": "Returns array of keys from a full Redis command and their usage flags.\n\nFor more information see https://redis.io/commands/command-getkeysandflags",
              "signature": "(self, *args: List[str]) -> List[Union[str, List[str]]]"
            },
            {
              "name": "command_info",
              "doc": null,
              "signature": "(self, **kwargs) -> None"
            },
            {
              "name": "command_list",
              "doc": "Return an array of the server's command names.\nYou can use one of the following filters:\n``module``: get the commands that belong to the module\n``category``: get the commands in the ACL category\n``pattern``: get the commands that match the given pattern\n\nFor more information see https://redis.io/commands/command-list/",
              "signature": "(self, module: Optional[str] = None, category: Optional[str] = None, pattern: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "config_get",
              "doc": "Return a dictionary of configuration based on the ``pattern``\n\nFor more information see https://redis.io/commands/config-get",
              "signature": "(self, pattern: Union[bytes, str, memoryview] = '*', *args: List[Union[bytes, str, memoryview]], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "config_resetstat",
              "doc": "Reset runtime statistics\n\nFor more information see https://redis.io/commands/config-resetstat",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "config_rewrite",
              "doc": "Rewrite config file with the minimal change to reflect running config.\n\nFor more information see https://redis.io/commands/config-rewrite",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "config_set",
              "doc": "Set config item ``name`` with ``value``\n\nFor more information see https://redis.io/commands/config-set",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float], *args: List[Union[bytes, bytearray, memoryview, str, int, float]], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "copy",
              "doc": "Copy the value stored in the ``source`` key to the ``destination`` key.\n\n``destination_db`` an alternative destination database. By default,\nthe ``destination`` key is created in the source Redis database.\n\n``replace`` whether the ``destination`` key should be removed before\ncopying the value to it. By default, the value is not copied if\nthe ``destination`` key already exists.\n\nFor more information see https://redis.io/commands/copy",
              "signature": "(self, source: str, destination: str, destination_db: Optional[str] = None, replace: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "dbsize",
              "doc": "Returns the number of keys in the current database\n\nFor more information see https://redis.io/commands/dbsize",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "debug_object",
              "doc": "Returns version specific meta information about a given key\n\nFor more information see https://redis.io/commands/debug-object",
              "signature": "(self, key: Union[bytes, str, memoryview], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "debug_segfault",
              "doc": null,
              "signature": "(self, **kwargs) -> None"
            },
            {
              "name": "decr",
              "doc": "Decrements the value of ``key`` by ``amount``.  If no key exists,\nthe value will be initialized as 0 - ``amount``\n\nFor more information see https://redis.io/commands/decrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: int = 1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "decrby",
              "doc": "Decrements the value of ``key`` by ``amount``.  If no key exists,\nthe value will be initialized as 0 - ``amount``\n\nFor more information see https://redis.io/commands/decrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: int = 1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "delete",
              "doc": "Delete one or more keys specified by ``names``",
              "signature": "(self, *names: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "dump",
              "doc": "Return a serialized version of the value stored at the specified key.\nIf key does not exist a nil bulk reply is returned.\n\nFor more information see https://redis.io/commands/dump",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "echo",
              "doc": "Echo the string back from the server\n\nFor more information see https://redis.io/commands/echo",
              "signature": "(self, value: Union[bytes, bytearray, memoryview, str, int, float], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "eval",
              "doc": "Execute the Lua ``script``, specifying the ``numkeys`` the script\nwill touch and the key names and argument values in ``keys_and_args``.\nReturns the result of the script.\n\nIn practice, use the object returned by ``register_script``. This\nfunction exists purely for Redis API completion.\n\nFor more information see  https://redis.io/commands/eval",
              "signature": "(self, script: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "eval_ro",
              "doc": "The read-only variant of the EVAL command\n\nExecute the read-only Lua ``script`` specifying the ``numkeys`` the script\nwill touch and the key names and argument values in ``keys_and_args``.\nReturns the result of the script.\n\nFor more information see  https://redis.io/commands/eval_ro",
              "signature": "(self, script: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "evalsha",
              "doc": "Use the ``sha`` to execute a Lua script already registered via EVAL\nor SCRIPT LOAD. Specify the ``numkeys`` the script will touch and the\nkey names and argument values in ``keys_and_args``. Returns the result\nof the script.\n\nIn practice, use the object returned by ``register_script``. This\nfunction exists purely for Redis API completion.\n\nFor more information see  https://redis.io/commands/evalsha",
              "signature": "(self, sha: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "evalsha_ro",
              "doc": "The read-only variant of the EVALSHA command\n\nUse the ``sha`` to execute a read-only Lua script already registered via EVAL\nor SCRIPT LOAD. Specify the ``numkeys`` the script will touch and the\nkey names and argument values in ``keys_and_args``. Returns the result\nof the script.\n\nFor more information see  https://redis.io/commands/evalsha_ro",
              "signature": "(self, sha: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "execute_command",
              "doc": null,
              "signature": "(self, *args, **options)"
            },
            {
              "name": "exists",
              "doc": "Returns the number of ``names`` that exist\n\nFor more information see https://redis.io/commands/exists",
              "signature": "(self, *names: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "expire",
              "doc": "Set an expire flag on key ``name`` for ``time`` seconds with given\n``option``. ``time`` can be represented by an integer or a Python timedelta\nobject.\n\nValid options are:\n    NX -> Set expiry only when the key has no expiry\n    XX -> Set expiry only when the key has an existing expiry\n    GT -> Set expiry only when the new expiry is greater than current one\n    LT -> Set expiry only when the new expiry is less than current one\n\nFor more information see https://redis.io/commands/expire",
              "signature": "(self, name: Union[bytes, str, memoryview], time: Union[int, datetime.timedelta], nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "expireat",
              "doc": "Set an expire flag on key ``name`` with given ``option``. ``when``\ncan be represented as an integer indicating unix time or a Python\ndatetime object.\n\nValid options are:\n    -> NX -- Set expiry only when the key has no expiry\n    -> XX -- Set expiry only when the key has an existing expiry\n    -> GT -- Set expiry only when the new expiry is greater than current one\n    -> LT -- Set expiry only when the new expiry is less than current one\n\nFor more information see https://redis.io/commands/expireat",
              "signature": "(self, name: Union[bytes, str, memoryview], when: Union[int, datetime.datetime], nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "expiretime",
              "doc": "Returns the absolute Unix timestamp (since January 1, 1970) in seconds\nat which the given key will expire.\n\nFor more information see https://redis.io/commands/expiretime",
              "signature": "(self, key: str) -> int"
            },
            {
              "name": "failover",
              "doc": "This function throws a NotImplementedError since it is intentionally\nnot supported.",
              "signature": "(self)"
            },
            {
              "name": "fcall",
              "doc": "Invoke a function.\n\nFor more information see https://redis.io/commands/fcall",
              "signature": "(self, function, numkeys: int, *keys_and_args: Any) -> Union[Awaitable[str], str]"
            },
            {
              "name": "fcall_ro",
              "doc": "This is a read-only variant of the FCALL command that cannot\nexecute commands that modify data.\n\nFor more information see https://redis.io/commands/fcall_ro",
              "signature": "(self, function, numkeys: int, *keys_and_args: Any) -> Union[Awaitable[str], str]"
            },
            {
              "name": "flushall",
              "doc": "Delete all keys in all databases on the current host.\n\n``asynchronous`` indicates whether the operation is\nexecuted asynchronously by the server.\n\nFor more information see https://redis.io/commands/flushall",
              "signature": "(self, asynchronous: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "flushdb",
              "doc": "Delete all keys in the current database.\n\n``asynchronous`` indicates whether the operation is\nexecuted asynchronously by the server.\n\nFor more information see https://redis.io/commands/flushdb",
              "signature": "(self, asynchronous: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "ft",
              "doc": "Access the search namespace, providing support for redis search.",
              "signature": "(self, index_name='idx') -> 'Search'"
            },
            {
              "name": "function_delete",
              "doc": "Delete the library called ``library`` and all its functions.\n\nFor more information see https://redis.io/commands/function-delete",
              "signature": "(self, library: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_dump",
              "doc": "Return the serialized payload of loaded libraries.\n\nFor more information see https://redis.io/commands/function-dump",
              "signature": "(self) -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_flush",
              "doc": "Deletes all the libraries.\n\nFor more information see https://redis.io/commands/function-flush",
              "signature": "(self, mode: str = 'SYNC') -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_kill",
              "doc": "Kill a function that is currently executing.\n\nFor more information see https://redis.io/commands/function-kill",
              "signature": "(self) -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_list",
              "doc": "Return information about the functions and libraries.\n\nArgs:\n\n    library: specify a pattern for matching library names\n    withcode: cause the server to include the libraries source implementation\n        in the reply",
              "signature": "(self, library: Optional[str] = '*', withcode: Optional[bool] = False) -> Union[Awaitable[List], List]"
            },
            {
              "name": "function_load",
              "doc": "Load a library to Redis.\n:param code: the source code (must start with\nShebang statement that provides a metadata about the library)\n:param replace: changes the behavior to overwrite the existing library\nwith the new contents.\nReturn the library name that was loaded.\n\nFor more information see https://redis.io/commands/function-load",
              "signature": "(self, code: str, replace: Optional[bool] = False) -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_restore",
              "doc": "Restore libraries from the serialized ``payload``.\nYou can use the optional policy argument to provide a policy\nfor handling existing libraries.\n\nFor more information see https://redis.io/commands/function-restore",
              "signature": "(self, payload: str, policy: Optional[str] = 'APPEND') -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_stats",
              "doc": "Return information about the function that's currently running\nand information about the available execution engines.\n\nFor more information see https://redis.io/commands/function-stats",
              "signature": "(self) -> Union[Awaitable[List], List]"
            },
            {
              "name": "geoadd",
              "doc": "Add the specified geospatial items to the specified key identified\nby the ``name`` argument. The Geospatial items are given as ordered\nmembers of the ``values`` argument, each item or place is formed by\nthe triad longitude, latitude and name.\n\nNote: You can use ZREM to remove elements.\n\n``nx`` forces ZADD to only create new elements and not to update\nscores for elements that already exist.\n\n``xx`` forces ZADD to only update scores of elements that already\nexist. New elements will not be added.\n\n``ch`` modifies the return value to be the numbers of elements changed.\nChanged elements include new elements that were added and elements\nwhose scores changed.\n\nFor more information see https://redis.io/commands/geoadd",
              "signature": "(self, name: Union[bytes, str, memoryview], values: Sequence[Union[bytes, bytearray, memoryview, str, int, float]], nx: bool = False, xx: bool = False, ch: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geodist",
              "doc": "Return the distance between ``place1`` and ``place2`` members of the\n``name`` key.\nThe units must be one of the following : m, km mi, ft. By default\nmeters are used.\n\nFor more information see https://redis.io/commands/geodist",
              "signature": "(self, name: Union[bytes, str, memoryview], place1: Union[bytes, bytearray, memoryview, str, int, float], place2: Union[bytes, bytearray, memoryview, str, int, float], unit: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geohash",
              "doc": "Return the geo hash string for each item of ``values`` members of\nthe specified key identified by the ``name`` argument.\n\nFor more information see https://redis.io/commands/geohash",
              "signature": "(self, name: Union[bytes, str, memoryview], *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geopos",
              "doc": "Return the positions of each item of ``values`` as members of\nthe specified key identified by the ``name`` argument. Each position\nis represented by the pairs lon and lat.\n\nFor more information see https://redis.io/commands/geopos",
              "signature": "(self, name: Union[bytes, str, memoryview], *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "georadius",
              "doc": "Return the members of the specified key identified by the\n``name`` argument which are within the borders of the area specified\nwith the ``latitude`` and ``longitude`` location and the maximum\ndistance from the center specified by the ``radius`` value.\n\nThe units must be one of the following : m, km mi, ft. By default\n\n``withdist`` indicates to return the distances of each place.\n\n``withcoord`` indicates to return the latitude and longitude of\neach place.\n\n``withhash`` indicates to return the geohash string of each place.\n\n``count`` indicates to return the number of elements up to N.\n\n``sort`` indicates to return the places in a sorted way, ASC for\nnearest to fairest and DESC for fairest to nearest.\n\n``store`` indicates to save the places names in a sorted set named\nwith a specific key, each element of the destination sorted set is\npopulated with the score got from the original geo sorted set.\n\n``store_dist`` indicates to save the places names in a sorted set\nnamed with a specific key, instead of ``store`` the sorted set\ndestination score is set with the distance.\n\nFor more information see https://redis.io/commands/georadius",
              "signature": "(self, name: Union[bytes, str, memoryview], longitude: float, latitude: float, radius: float, unit: Optional[str] = None, withdist: bool = False, withcoord: bool = False, withhash: bool = False, count: Optional[int] = None, sort: Optional[str] = None, store: Union[bytes, str, memoryview, NoneType] = None, store_dist: Union[bytes, str, memoryview, NoneType] = None, any: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "georadiusbymember",
              "doc": "This command is exactly like ``georadius`` with the sole difference\nthat instead of taking, as the center of the area to query, a longitude\nand latitude value, it takes the name of a member already existing\ninside the geospatial index represented by the sorted set.\n\nFor more information see https://redis.io/commands/georadiusbymember",
              "signature": "(self, name: Union[bytes, str, memoryview], member: Union[bytes, bytearray, memoryview, str, int, float], radius: float, unit: Optional[str] = None, withdist: bool = False, withcoord: bool = False, withhash: bool = False, count: Optional[int] = None, sort: Optional[str] = None, store: Union[bytes, str, memoryview, NoneType] = None, store_dist: Union[bytes, str, memoryview, NoneType] = None, any: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geosearch",
              "doc": "Return the members of specified key identified by the\n``name`` argument, which are within the borders of the\narea specified by a given shape. This command extends the\nGEORADIUS command, so in addition to searching within circular\nareas, it supports searching within rectangular areas.\n\nThis command should be used in place of the deprecated\nGEORADIUS and GEORADIUSBYMEMBER commands.\n\n``member`` Use the position of the given existing\n member in the sorted set. Can't be given with ``longitude``\n and ``latitude``.\n\n``longitude`` and ``latitude`` Use the position given by\nthis coordinates. Can't be given with ``member``\n``radius`` Similar to GEORADIUS, search inside circular\narea according the given radius. Can't be given with\n``height`` and ``width``.\n``height`` and ``width`` Search inside an axis-aligned\nrectangle, determined by the given height and width.\nCan't be given with ``radius``\n\n``unit`` must be one of the following : m, km, mi, ft.\n`m` for meters (the default value), `km` for kilometers,\n`mi` for miles and `ft` for feet.\n\n``sort`` indicates to return the places in a sorted way,\nASC for nearest to furthest and DESC for furthest to nearest.\n\n``count`` limit the results to the first count matching items.\n\n``any`` is set to True, the command will return as soon as\nenough matches are found. Can't be provided without ``count``\n\n``withdist`` indicates to return the distances of each place.\n``withcoord`` indicates to return the latitude and longitude of\neach place.\n\n``withhash`` indicates to return the geohash string of each place.\n\nFor more information see https://redis.io/commands/geosearch",
              "signature": "(self, name: Union[bytes, str, memoryview], member: Union[bytes, bytearray, memoryview, str, int, float, NoneType] = None, longitude: Optional[float] = None, latitude: Optional[float] = None, unit: str = 'm', radius: Optional[float] = None, width: Optional[float] = None, height: Optional[float] = None, sort: Optional[str] = None, count: Optional[int] = None, any: bool = False, withcoord: bool = False, withdist: bool = False, withhash: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geosearchstore",
              "doc": "This command is like GEOSEARCH, but stores the result in\n``dest``. By default, it stores the results in the destination\nsorted set with their geospatial information.\nif ``store_dist`` set to True, the command will stores the\nitems in a sorted set populated with their distance from the\ncenter of the circle or box, as a floating-point number.\n\nFor more information see https://redis.io/commands/geosearchstore",
              "signature": "(self, dest: Union[bytes, str, memoryview], name: Union[bytes, str, memoryview], member: Union[bytes, bytearray, memoryview, str, int, float, NoneType] = None, longitude: Optional[float] = None, latitude: Optional[float] = None, unit: str = 'm', radius: Optional[float] = None, width: Optional[float] = None, height: Optional[float] = None, sort: Optional[str] = None, count: Optional[int] = None, any: bool = False, storedist: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "get",
              "doc": "Return the value at key ``name``, or None if the key doesn't exist\n\nFor more information see https://redis.io/commands/get",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "get_cache",
              "doc": null,
              "signature": "(self) -> Optional[redis.cache.CacheInterface]"
            },
            {
              "name": "get_connection_kwargs",
              "doc": "Get the connection's key-word arguments",
              "signature": "(self) -> Dict"
            },
            {
              "name": "get_encoder",
              "doc": "Get the connection pool's encoder",
              "signature": "(self) -> 'Encoder'"
            },
            {
              "name": "get_retry",
              "doc": null,
              "signature": "(self) -> Optional[redis.retry.Retry]"
            },
            {
              "name": "getbit",
              "doc": "Returns an integer indicating the value of ``offset`` in ``name``\n\nFor more information see https://redis.io/commands/getbit",
              "signature": "(self, name: Union[bytes, str, memoryview], offset: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "getdel",
              "doc": "Get the value at key ``name`` and delete the key. This command\nis similar to GET, except for the fact that it also deletes\nthe key on success (if and only if the key's value type\nis a string).\n\nFor more information see https://redis.io/commands/getdel",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "getex",
              "doc": "Get the value of key and optionally set its expiration.\nGETEX is similar to GET, but is a write command with\nadditional options. All time parameters can be given as\ndatetime.timedelta or integers.\n\n``ex`` sets an expire flag on key ``name`` for ``ex`` seconds.\n\n``px`` sets an expire flag on key ``name`` for ``px`` milliseconds.\n\n``exat`` sets an expire flag on key ``name`` for ``ex`` seconds,\nspecified in unix time.\n\n``pxat`` sets an expire flag on key ``name`` for ``ex`` milliseconds,\nspecified in unix time.\n\n``persist`` remove the time to live associated with ``name``.\n\nFor more information see https://redis.io/commands/getex",
              "signature": "(self, name: Union[bytes, str, memoryview], ex: Union[int, datetime.timedelta, NoneType] = None, px: Union[int, datetime.timedelta, NoneType] = None, exat: Union[int, datetime.datetime, NoneType] = None, pxat: Union[int, datetime.datetime, NoneType] = None, persist: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "getrange",
              "doc": "Returns the substring of the string value stored at ``key``,\ndetermined by the offsets ``start`` and ``end`` (both are inclusive)\n\nFor more information see https://redis.io/commands/getrange",
              "signature": "(self, key: Union[bytes, str, memoryview], start: int, end: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "getset",
              "doc": "Sets the value at key ``name`` to ``value``\nand returns the old value at key ``name`` atomically.\n\nAs per Redis 6.2, GETSET is considered deprecated.\nPlease use SET with GET parameter in new code.\n\nFor more information see https://redis.io/commands/getset",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hdel",
              "doc": "Delete ``keys`` from hash ``name``\n\nFor more information see https://redis.io/commands/hdel",
              "signature": "(self, name: str, *keys: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hello",
              "doc": "This function throws a NotImplementedError since it is intentionally\nnot supported.",
              "signature": "(self)"
            },
            {
              "name": "hexists",
              "doc": "Returns a boolean indicating if ``key`` exists within hash ``name``\n\nFor more information see https://redis.io/commands/hexists",
              "signature": "(self, name: str, key: str) -> Union[Awaitable[bool], bool]"
            },
            {
              "name": "hexpire",
              "doc": "Sets or updates the expiration time for fields within a hash key, using relative\ntime in seconds.\n\nIf a field already has an expiration time, the behavior of the update can be\ncontrolled using the `nx`, `xx`, `gt`, and `lt` parameters.\n\nThe return value provides detailed information about the outcome for each field.\n\nFor more information, see https://redis.io/commands/hexpire\n\nArgs:\n    name: The name of the hash key.\n    seconds: Expiration time in seconds, relative. Can be an integer, or a\n             Python `timedelta` object.\n    fields: List of fields within the hash to apply the expiration time to.\n    nx: Set expiry only when the field has no expiry.\n    xx: Set expiry only when the field has an existing expiry.\n    gt: Set expiry only when the new expiry is greater than the current one.\n    lt: Set expiry only when the new expiry is less than the current one.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `0` if the specified NX | XX | GT | LT condition was not met.\n        - `1` if the expiration time was set or updated.\n        - `2` if the field was deleted because the specified expiration time is\n          in the past.",
              "signature": "(self, name: Union[bytes, str, memoryview], seconds: Union[int, datetime.timedelta], *fields: str, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hexpireat",
              "doc": "Sets or updates the expiration time for fields within a hash key, using an\nabsolute Unix timestamp in seconds.\n\nIf a field already has an expiration time, the behavior of the update can be\ncontrolled using the `nx`, `xx`, `gt`, and `lt` parameters.\n\nThe return value provides detailed information about the outcome for each field.\n\nFor more information, see https://redis.io/commands/hexpireat\n\nArgs:\n    name: The name of the hash key.\n    unix_time_seconds: Expiration time as Unix timestamp in seconds. Can be an\n                       integer or a Python `datetime` object.\n    fields: List of fields within the hash to apply the expiration time to.\n    nx: Set expiry only when the field has no expiry.\n    xx: Set expiry only when the field has an existing expiration time.\n    gt: Set expiry only when the new expiry is greater than the current one.\n    lt: Set expiry only when the new expiry is less than the current one.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `0` if the specified NX | XX | GT | LT condition was not met.\n        - `1` if the expiration time was set or updated.\n        - `2` if the field was deleted because the specified expiration time is\n          in the past.",
              "signature": "(self, name: Union[bytes, str, memoryview], unix_time_seconds: Union[int, datetime.datetime], *fields: str, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hexpiretime",
              "doc": "Returns the expiration times of hash fields as Unix timestamps in seconds.\n\nFor more information, see https://redis.io/commands/hexpiretime\n\nArgs:\n    key: The hash key.\n    fields: A list of fields within the hash for which to get the expiration\n            time.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expire time.\n        - A positive integer representing the expiration Unix timestamp in\n          seconds, if the field has an associated expiration time.",
              "signature": "(self, key: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hget",
              "doc": "Return the value of ``key`` within the hash ``name``\n\nFor more information see https://redis.io/commands/hget",
              "signature": "(self, name: str, key: str) -> Union[Awaitable[Optional[str]], str, NoneType]"
            },
            {
              "name": "hgetall",
              "doc": "Return a Python dict of the hash's name/value pairs\n\nFor more information see https://redis.io/commands/hgetall",
              "signature": "(self, name: str) -> Union[Awaitable[dict], dict]"
            },
            {
              "name": "hgetdel",
              "doc": "Return the value of ``key`` within the hash ``name`` and\ndelete the field in the hash.\nThis command is similar to HGET, except for the fact that it also deletes\nthe key on success from the hash with the provided ```name```.\n\nAvailable since Redis 8.0\nFor more information see https://redis.io/commands/hgetdel",
              "signature": "(self, name: str, *keys: str) -> Union[Awaitable[Optional[List[Union[str, bytes]]]], List[Union[str, bytes]], NoneType]"
            },
            {
              "name": "hgetex",
              "doc": "Return the values of ``key`` and ``keys`` within the hash ``name``\nand optionally set their expiration.\n\n``ex`` sets an expire flag on ``kyes`` for ``ex`` seconds.\n\n``px`` sets an expire flag on ``keys`` for ``px`` milliseconds.\n\n``exat`` sets an expire flag on ``keys`` for ``ex`` seconds,\nspecified in unix time.\n\n``pxat`` sets an expire flag on ``keys`` for ``ex`` milliseconds,\nspecified in unix time.\n\n``persist`` remove the time to live associated with the ``keys``.\n\nAvailable since Redis 8.0\nFor more information see https://redis.io/commands/hgetex",
              "signature": "(self, name: Union[bytes, str, memoryview], *keys: str, ex: Union[int, datetime.timedelta, NoneType] = None, px: Union[int, datetime.timedelta, NoneType] = None, exat: Union[int, datetime.datetime, NoneType] = None, pxat: Union[int, datetime.datetime, NoneType] = None, persist: bool = False) -> Union[Awaitable[Optional[List[Union[str, bytes]]]], List[Union[str, bytes]], NoneType]"
            },
            {
              "name": "hincrby",
              "doc": "Increment the value of ``key`` in hash ``name`` by ``amount``\n\nFor more information see https://redis.io/commands/hincrby",
              "signature": "(self, name: str, key: str, amount: int = 1) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hincrbyfloat",
              "doc": "Increment the value of ``key`` in hash ``name`` by floating ``amount``\n\nFor more information see https://redis.io/commands/hincrbyfloat",
              "signature": "(self, name: str, key: str, amount: float = 1.0) -> Union[Awaitable[float], float]"
            },
            {
              "name": "hkeys",
              "doc": "Return the list of keys within hash ``name``\n\nFor more information see https://redis.io/commands/hkeys",
              "signature": "(self, name: str) -> Union[Awaitable[List], List]"
            },
            {
              "name": "hlen",
              "doc": "Return the number of elements in hash ``name``\n\nFor more information see https://redis.io/commands/hlen",
              "signature": "(self, name: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hmget",
              "doc": "Returns a list of values ordered identically to ``keys``\n\nFor more information see https://redis.io/commands/hmget",
              "signature": "(self, name: str, keys: List, *args: List) -> Union[Awaitable[List], List]"
            },
            {
              "name": "hmset",
              "doc": "Set key to value within hash ``name`` for each corresponding\nkey and value from the ``mapping`` dict.\n\nFor more information see https://redis.io/commands/hmset",
              "signature": "(self, name: str, mapping: dict) -> Union[Awaitable[str], str]"
            },
            {
              "name": "hpersist",
              "doc": "Removes the expiration time for each specified field in a hash.\n\nFor more information, see https://redis.io/commands/hpersist\n\nArgs:\n    name: The name of the hash key.\n    fields: A list of fields within the hash from which to remove the\n            expiration time.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expiration time.\n        - `1` if the expiration time was successfully removed from the field.",
              "signature": "(self, name: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hpexpire",
              "doc": "Sets or updates the expiration time for fields within a hash key, using relative\ntime in milliseconds.\n\nIf a field already has an expiration time, the behavior of the update can be\ncontrolled using the `nx`, `xx`, `gt`, and `lt` parameters.\n\nThe return value provides detailed information about the outcome for each field.\n\nFor more information, see https://redis.io/commands/hpexpire\n\nArgs:\n    name: The name of the hash key.\n    milliseconds: Expiration time in milliseconds, relative. Can be an integer,\n                  or a Python `timedelta` object.\n    fields: List of fields within the hash to apply the expiration time to.\n    nx: Set expiry only when the field has no expiry.\n    xx: Set expiry only when the field has an existing expiry.\n    gt: Set expiry only when the new expiry is greater than the current one.\n    lt: Set expiry only when the new expiry is less than the current one.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `0` if the specified NX | XX | GT | LT condition was not met.\n        - `1` if the expiration time was set or updated.\n        - `2` if the field was deleted because the specified expiration time is\n          in the past.",
              "signature": "(self, name: Union[bytes, str, memoryview], milliseconds: Union[int, datetime.timedelta], *fields: str, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hpexpireat",
              "doc": "Sets or updates the expiration time for fields within a hash key, using an\nabsolute Unix timestamp in milliseconds.\n\nIf a field already has an expiration time, the behavior of the update can be\ncontrolled using the `nx`, `xx`, `gt`, and `lt` parameters.\n\nThe return value provides detailed information about the outcome for each field.\n\nFor more information, see https://redis.io/commands/hpexpireat\n\nArgs:\n    name: The name of the hash key.\n    unix_time_milliseconds: Expiration time as Unix timestamp in milliseconds.\n                            Can be an integer or a Python `datetime` object.\n    fields: List of fields within the hash to apply the expiry.\n    nx: Set expiry only when the field has no expiry.\n    xx: Set expiry only when the field has an existing expiry.\n    gt: Set expiry only when the new expiry is greater than the current one.\n    lt: Set expiry only when the new expiry is less than the current one.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `0` if the specified NX | XX | GT | LT condition was not met.\n        - `1` if the expiration time was set or updated.\n        - `2` if the field was deleted because the specified expiration time is\n          in the past.",
              "signature": "(self, name: Union[bytes, str, memoryview], unix_time_milliseconds: Union[int, datetime.datetime], *fields: str, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hpexpiretime",
              "doc": "Returns the expiration times of hash fields as Unix timestamps in milliseconds.\n\nFor more information, see https://redis.io/commands/hpexpiretime\n\nArgs:\n    key: The hash key.\n    fields: A list of fields within the hash for which to get the expiration\n            time.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expire time.\n        - A positive integer representing the expiration Unix timestamp in\n          milliseconds, if the field has an associated expiration time.",
              "signature": "(self, key: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hpttl",
              "doc": "Returns the TTL (Time To Live) in milliseconds for each specified field within a\nhash key.\n\nFor more information, see https://redis.io/commands/hpttl\n\nArgs:\n    key: The hash key.\n    fields: A list of fields within the hash for which to get the TTL.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expire time.\n        - A positive integer representing the TTL in milliseconds if the field\n          has an associated expiration time.",
              "signature": "(self, key: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hrandfield",
              "doc": "Return a random field from the hash value stored at key.\n\ncount: if the argument is positive, return an array of distinct fields.\nIf called with a negative count, the behavior changes and the command\nis allowed to return the same field multiple times. In this case,\nthe number of returned fields is the absolute value of the\nspecified count.\nwithvalues: The optional WITHVALUES modifier changes the reply so it\nincludes the respective values of the randomly selected hash fields.\n\nFor more information see https://redis.io/commands/hrandfield",
              "signature": "(self, key: str, count: Optional[int] = None, withvalues: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hscan",
              "doc": "Incrementally return key/value slices in a hash. Also return a cursor\nindicating the scan position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\n``no_values`` indicates to return only the keys, without values.\n\nFor more information see https://redis.io/commands/hscan",
              "signature": "(self, name: Union[bytes, str, memoryview], cursor: int = 0, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, no_values: Optional[bool] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hscan_iter",
              "doc": "Make an iterator using the HSCAN command so that the client doesn't\nneed to remember the cursor position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\n``no_values`` indicates to return only the keys, without values",
              "signature": "(self, name: str, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, no_values: Optional[bool] = None) -> Iterator"
            },
            {
              "name": "hset",
              "doc": "Set ``key`` to ``value`` within hash ``name``,\n``mapping`` accepts a dict of key/value pairs that will be\nadded to hash ``name``.\n``items`` accepts a list of key/value pairs that will be\nadded to hash ``name``.\nReturns the number of fields that were added.\n\nFor more information see https://redis.io/commands/hset",
              "signature": "(self, name: str, key: Optional[str] = None, value: Optional[str] = None, mapping: Optional[dict] = None, items: Optional[list] = None) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hsetex",
              "doc": "Set ``key`` to ``value`` within hash ``name``\n\n``mapping`` accepts a dict of key/value pairs that will be\nadded to hash ``name``.\n\n``items`` accepts a list of key/value pairs that will be\nadded to hash ``name``.\n\n``ex`` sets an expire flag on ``keys`` for ``ex`` seconds.\n\n``px`` sets an expire flag on ``keys`` for ``px`` milliseconds.\n\n``exat`` sets an expire flag on ``keys`` for ``ex`` seconds,\n    specified in unix time.\n\n``pxat`` sets an expire flag on ``keys`` for ``ex`` milliseconds,\n    specified in unix time.\n\n``data_persist_option`` can be set to ``FNX`` or ``FXX`` to control the\n    behavior of the command.\n    ``FNX`` will set the value for each provided key to each\n        provided value only if all do not already exist.\n    ``FXX`` will set the value for each provided key to each\n        provided value only if all already exist.\n\n``keepttl`` if True, retain the time to live associated with the keys.\n\nReturns the number of fields that were added.\n\nAvailable since Redis 8.0\nFor more information see https://redis.io/commands/hsetex",
              "signature": "(self, name: str, key: Optional[str] = None, value: Optional[str] = None, mapping: Optional[dict] = None, items: Optional[list] = None, ex: Union[int, datetime.timedelta, NoneType] = None, px: Union[int, datetime.timedelta, NoneType] = None, exat: Union[int, datetime.datetime, NoneType] = None, pxat: Union[int, datetime.datetime, NoneType] = None, data_persist_option: Optional[redis.commands.core.HashDataPersistOptions] = None, keepttl: bool = False) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hsetnx",
              "doc": "Set ``key`` to ``value`` within hash ``name`` if ``key`` does not\nexist.  Returns 1 if HSETNX created a field, otherwise 0.\n\nFor more information see https://redis.io/commands/hsetnx",
              "signature": "(self, name: str, key: str, value: str) -> Union[Awaitable[bool], bool]"
            },
            {
              "name": "hstrlen",
              "doc": "Return the number of bytes stored in the value of ``key``\nwithin hash ``name``\n\nFor more information see https://redis.io/commands/hstrlen",
              "signature": "(self, name: str, key: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "httl",
              "doc": "Returns the TTL (Time To Live) in seconds for each specified field within a hash\nkey.\n\nFor more information, see https://redis.io/commands/httl\n\nArgs:\n    key: The hash key.\n    fields: A list of fields within the hash for which to get the TTL.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expire time.\n        - A positive integer representing the TTL in seconds if the field has\n          an associated expiration time.",
              "signature": "(self, key: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hvals",
              "doc": "Return the list of values within hash ``name``\n\nFor more information see https://redis.io/commands/hvals",
              "signature": "(self, name: str) -> Union[Awaitable[List], List]"
            },
            {
              "name": "incr",
              "doc": "Increments the value of ``key`` by ``amount``.  If no key exists,\nthe value will be initialized as ``amount``\n\nFor more information see https://redis.io/commands/incrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: int = 1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "incrby",
              "doc": "Increments the value of ``key`` by ``amount``.  If no key exists,\nthe value will be initialized as ``amount``\n\nFor more information see https://redis.io/commands/incrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: int = 1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "incrbyfloat",
              "doc": "Increments the value at key ``name`` by floating ``amount``.\nIf no key exists, the value will be initialized as ``amount``\n\nFor more information see https://redis.io/commands/incrbyfloat",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: float = 1.0) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "info",
              "doc": "Returns a dictionary containing information about the Redis server\n\nThe ``section`` option can be used to select a specific section\nof information\n\nThe section option is not supported by older versions of Redis Server,\nand will generate ResponseError\n\nFor more information see https://redis.io/commands/info",
              "signature": "(self, section: Optional[str] = None, *args: List[str], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "json",
              "doc": "Access the json namespace, providing support for redis json.",
              "signature": "(self, encoder=<json.encoder.JSONEncoder object at 0x0000023EF6E34C90>, decoder=<json.decoder.JSONDecoder object at 0x0000023EF6E34B90>) -> 'JSON'"
            },
            {
              "name": "keys",
              "doc": "Returns a list of keys matching ``pattern``\n\nFor more information see https://redis.io/commands/keys",
              "signature": "(self, pattern: Union[bytes, str, memoryview] = '*', **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "lastsave",
              "doc": "Return a Python datetime object representing the last time the\nRedis database was saved to disk\n\nFor more information see https://redis.io/commands/lastsave",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "latency_doctor",
              "doc": "Raise a NotImplementedError, as the client will not support LATENCY DOCTOR.\nThis funcion is best used within the redis-cli.\n\nFor more information see https://redis.io/commands/latency-doctor",
              "signature": "(self)"
            },
            {
              "name": "latency_graph",
              "doc": "Raise a NotImplementedError, as the client will not support LATENCY GRAPH.\nThis funcion is best used within the redis-cli.\n\nFor more information see https://redis.io/commands/latency-graph.",
              "signature": "(self)"
            },
            {
              "name": "latency_histogram",
              "doc": "This function throws a NotImplementedError since it is intentionally\nnot supported.",
              "signature": "(self, *args)"
            },
            {
              "name": "latency_history",
              "doc": "Returns the raw data of the ``event``'s latency spikes time series.\n\nFor more information see https://redis.io/commands/latency-history",
              "signature": "(self, event: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "latency_latest",
              "doc": "Reports the latest latency events logged.\n\nFor more information see https://redis.io/commands/latency-latest",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "latency_reset",
              "doc": "Resets the latency spikes time series of all, or only some, events.\n\nFor more information see https://redis.io/commands/latency-reset",
              "signature": "(self, *events: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "lcs",
              "doc": "Find the longest common subsequence between ``key1`` and ``key2``.\nIf ``len`` is true the length of the match will will be returned.\nIf ``idx`` is true the match position in each strings will be returned.\n``minmatchlen`` restrict the list of matches to the ones of\nthe given ``minmatchlen``.\nIf ``withmatchlen`` the length of the match also will be returned.\nFor more information see https://redis.io/commands/lcs",
              "signature": "(self, key1: str, key2: str, len: Optional[bool] = False, idx: Optional[bool] = False, minmatchlen: Optional[int] = 0, withmatchlen: Optional[bool] = False) -> Union[str, int, list]"
            },
            {
              "name": "lindex",
              "doc": "Return the item from list ``name`` at position ``index``\n\nNegative indexes are supported and will return an item at the\nend of the list\n\nFor more information see https://redis.io/commands/lindex",
              "signature": "(self, name: str, index: int) -> Union[Awaitable[Optional[str]], str, NoneType]"
            },
            {
              "name": "linsert",
              "doc": "Insert ``value`` in list ``name`` either immediately before or after\n[``where``] ``refvalue``\n\nReturns the new length of the list on success or -1 if ``refvalue``\nis not in the list.\n\nFor more information see https://redis.io/commands/linsert",
              "signature": "(self, name: str, where: str, refvalue: str, value: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "llen",
              "doc": "Return the length of the list ``name``\n\nFor more information see https://redis.io/commands/llen",
              "signature": "(self, name: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "lmove",
              "doc": "Atomically returns and removes the first/last element of a list,\npushing it as the first/last element on the destination list.\nReturns the element being popped and pushed.\n\nFor more information see https://redis.io/commands/lmove",
              "signature": "(self, first_list: str, second_list: str, src: str = 'LEFT', dest: str = 'RIGHT') -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "lmpop",
              "doc": "Pop ``count`` values (default 1) first non-empty list key from the list\nof args provided key names.\n\nFor more information see https://redis.io/commands/lmpop",
              "signature": "(self, num_keys: int, *args: List[str], direction: str, count: Optional[int] = 1) -> Union[Awaitable[list], list]"
            },
            {
              "name": "load_external_module",
              "doc": "This function can be used to add externally defined redis modules,\nand their namespaces to the redis client.\n\nfuncname - A string containing the name of the function to create\nfunc - The function, being added to this class.\n\nex: Assume that one has a custom redis module named foomod that\ncreates command named 'foo.dothing' and 'foo.anotherthing' in redis.\nTo load function functions into this namespace:\n\nfrom redis import Redis\nfrom foomodule import F\nr = Redis()\nr.load_external_module(\"foo\", F)\nr.foo().dothing('your', 'arguments')\n\nFor a concrete example see the reimport of the redisjson module in\ntests/test_connection.py::test_loading_external_modules",
              "signature": "(self, funcname, func) -> None"
            },
            {
              "name": "lock",
              "doc": "Return a new Lock object using key ``name`` that mimics\nthe behavior of threading.Lock.\n\nIf specified, ``timeout`` indicates a maximum life for the lock.\nBy default, it will remain locked until release() is called.\n\n``sleep`` indicates the amount of time to sleep per loop iteration\nwhen the lock is in blocking mode and another client is currently\nholding the lock.\n\n``blocking`` indicates whether calling ``acquire`` should block until\nthe lock has been acquired or to fail immediately, causing ``acquire``\nto return False and the lock not being acquired. Defaults to True.\nNote this value can be overridden by passing a ``blocking``\nargument to ``acquire``.\n\n``blocking_timeout`` indicates the maximum amount of time in seconds to\nspend trying to acquire the lock. A value of ``None`` indicates\ncontinue trying forever. ``blocking_timeout`` can be specified as a\nfloat or integer, both representing the number of seconds to wait.\n\n``lock_class`` forces the specified lock implementation. Note that as\nof redis-py 3.0, the only lock class we implement is ``Lock`` (which is\na Lua-based lock). So, it's unlikely you'll need this parameter, unless\nyou have created your own custom lock class.\n\n``thread_local`` indicates whether the lock token is placed in\nthread-local storage. By default, the token is placed in thread local\nstorage so that a thread only sees its token, not a token set by\nanother thread. Consider the following timeline:\n\n    time: 0, thread-1 acquires `my-lock`, with a timeout of 5 seconds.\n             thread-1 sets the token to \"abc\"\n    time: 1, thread-2 blocks trying to acquire `my-lock` using the\n             Lock instance.\n    time: 5, thread-1 has not yet completed. redis expires the lock\n             key.\n    time: 5, thread-2 acquired `my-lock` now that it's available.\n             thread-2 sets the token to \"xyz\"\n    time: 6, thread-1 finishes its work and calls release(). if the\n             token is *not* stored in thread local storage, then\n             thread-1 would see the token value as \"xyz\" and would be\n             able to successfully release the thread-2's lock.\n\n``raise_on_release_error`` indicates whether to raise an exception when\nthe lock is no longer owned when exiting the context manager. By default,\nthis is True, meaning an exception will be raised. If False, the warning\nwill be logged and the exception will be suppressed.\n\nIn some use cases it's necessary to disable thread local storage. For\nexample, if you have code where one thread acquires a lock and passes\nthat lock instance to a worker thread to release later. If thread\nlocal storage isn't disabled in this case, the worker thread won't see\nthe token set by the thread that acquired the lock. Our assumption\nis that these cases aren't common and as such default to using\nthread local storage.",
              "signature": "(self, name: str, timeout: Optional[float] = None, sleep: float = 0.1, blocking: bool = True, blocking_timeout: Optional[float] = None, lock_class: Optional[Any] = None, thread_local: bool = True, raise_on_release_error: bool = True)"
            },
            {
              "name": "lolwut",
              "doc": "Get the Redis version and a piece of generative computer art\n\nSee: https://redis.io/commands/lolwut",
              "signature": "(self, *version_numbers: Union[str, float], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "lpop",
              "doc": "Removes and returns the first elements of the list ``name``.\n\nBy default, the command pops a single element from the beginning of\nthe list. When provided with the optional ``count`` argument, the reply\nwill consist of up to count elements, depending on the list's length.\n\nFor more information see https://redis.io/commands/lpop",
              "signature": "(self, name: str, count: Optional[int] = None) -> Union[Awaitable[Union[str, List, NoneType]], str, List, NoneType]"
            },
            {
              "name": "lpos",
              "doc": "Get position of ``value`` within the list ``name``\n\n If specified, ``rank`` indicates the \"rank\" of the first element to\n return in case there are multiple copies of ``value`` in the list.\n By default, LPOS returns the position of the first occurrence of\n ``value`` in the list. When ``rank`` 2, LPOS returns the position of\n the second ``value`` in the list. If ``rank`` is negative, LPOS\n searches the list in reverse. For example, -1 would return the\n position of the last occurrence of ``value`` and -2 would return the\n position of the next to last occurrence of ``value``.\n\n If specified, ``count`` indicates that LPOS should return a list of\n up to ``count`` positions. A ``count`` of 2 would return a list of\n up to 2 positions. A ``count`` of 0 returns a list of all positions\n matching ``value``. When ``count`` is specified and but ``value``\n does not exist in the list, an empty list is returned.\n\n If specified, ``maxlen`` indicates the maximum number of list\n elements to scan. A ``maxlen`` of 1000 will only return the\n position(s) of items within the first 1000 entries in the list.\n A ``maxlen`` of 0 (the default) will scan the entire list.\n\n For more information see https://redis.io/commands/lpos",
              "signature": "(self, name: str, value: str, rank: Optional[int] = None, count: Optional[int] = None, maxlen: Optional[int] = None) -> Union[str, List, NoneType]"
            },
            {
              "name": "lpush",
              "doc": "Push ``values`` onto the head of the list ``name``\n\nFor more information see https://redis.io/commands/lpush",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "lpushx",
              "doc": "Push ``value`` onto the head of the list ``name`` if ``name`` exists\n\nFor more information see https://redis.io/commands/lpushx",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "lrange",
              "doc": "Return a slice of the list ``name`` between\nposition ``start`` and ``end``\n\n``start`` and ``end`` can be negative numbers just like\nPython slicing notation\n\nFor more information see https://redis.io/commands/lrange",
              "signature": "(self, name: str, start: int, end: int) -> Union[Awaitable[list], list]"
            },
            {
              "name": "lrem",
              "doc": "Remove the first ``count`` occurrences of elements equal to ``value``\nfrom the list stored at ``name``.\n\nThe count argument influences the operation in the following ways:\n    count > 0: Remove elements equal to value moving from head to tail.\n    count < 0: Remove elements equal to value moving from tail to head.\n    count = 0: Remove all elements equal to value.\n\n    For more information see https://redis.io/commands/lrem",
              "signature": "(self, name: str, count: int, value: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "lset",
              "doc": "Set element at ``index`` of list ``name`` to ``value``\n\nFor more information see https://redis.io/commands/lset",
              "signature": "(self, name: str, index: int, value: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "ltrim",
              "doc": "Trim the list ``name``, removing all values not within the slice\nbetween ``start`` and ``end``\n\n``start`` and ``end`` can be negative numbers just like\nPython slicing notation\n\nFor more information see https://redis.io/commands/ltrim",
              "signature": "(self, name: str, start: int, end: int) -> Union[Awaitable[str], str]"
            },
            {
              "name": "memory_doctor",
              "doc": null,
              "signature": "(self, **kwargs) -> None"
            },
            {
              "name": "memory_help",
              "doc": null,
              "signature": "(self, **kwargs) -> None"
            },
            {
              "name": "memory_malloc_stats",
              "doc": "Return an internal statistics report from the memory allocator.\n\nSee: https://redis.io/commands/memory-malloc-stats",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "memory_purge",
              "doc": "Attempts to purge dirty pages for reclamation by allocator\n\nFor more information see https://redis.io/commands/memory-purge",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "memory_stats",
              "doc": "Return a dictionary of memory stats\n\nFor more information see https://redis.io/commands/memory-stats",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "memory_usage",
              "doc": "Return the total memory usage for key, its value and associated\nadministrative overheads.\n\nFor nested data structures, ``samples`` is the number of elements to\nsample. If left unspecified, the server's default is 5. Use 0 to sample\nall elements.\n\nFor more information see https://redis.io/commands/memory-usage",
              "signature": "(self, key: Union[bytes, str, memoryview], samples: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "mget",
              "doc": "Returns a list of values ordered identically to ``keys``\n\nFor more information see https://redis.io/commands/mget",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], *args: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "migrate",
              "doc": "Migrate 1 or more keys from the current Redis server to a different\nserver specified by the ``host``, ``port`` and ``destination_db``.\n\nThe ``timeout``, specified in milliseconds, indicates the maximum\ntime the connection between the two servers can be idle before the\ncommand is interrupted.\n\nIf ``copy`` is True, the specified ``keys`` are NOT deleted from\nthe source server.\n\nIf ``replace`` is True, this operation will overwrite the keys\non the destination server if they exist.\n\nIf ``auth`` is specified, authenticate to the destination server with\nthe password provided.\n\nFor more information see https://redis.io/commands/migrate",
              "signature": "(self, host: str, port: int, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], destination_db: int, timeout: int, copy: bool = False, replace: bool = False, auth: Optional[str] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "module_list",
              "doc": "Returns a list of dictionaries containing the name and version of\nall loaded modules.\n\nFor more information see https://redis.io/commands/module-list",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "module_load",
              "doc": "Loads the module from ``path``.\nPasses all ``*args`` to the module, during loading.\nRaises ``ModuleError`` if a module is not found at ``path``.\n\nFor more information see https://redis.io/commands/module-load",
              "signature": "(self, path, *args) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "module_loadex",
              "doc": "Loads a module from a dynamic library at runtime with configuration directives.\n\nFor more information see https://redis.io/commands/module-loadex",
              "signature": "(self, path: str, options: Optional[List[str]] = None, args: Optional[List[str]] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "module_unload",
              "doc": "Unloads the module ``name``.\nRaises ``ModuleError`` if ``name`` is not in loaded modules.\n\nFor more information see https://redis.io/commands/module-unload",
              "signature": "(self, name) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "monitor",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "move",
              "doc": "Moves the key ``name`` to a different Redis database ``db``\n\nFor more information see https://redis.io/commands/move",
              "signature": "(self, name: Union[bytes, str, memoryview], db: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "mset",
              "doc": "Sets key/values based on a mapping. Mapping is a dictionary of\nkey/value pairs. Both keys and values should be strings or types that\ncan be cast to a string via str().\n\nFor more information see https://redis.io/commands/mset",
              "signature": "(self, mapping: Mapping[~AnyKeyT, Union[bytes, bytearray, memoryview, str, int, float]]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "msetnx",
              "doc": "Sets key/values based on a mapping if none of the keys are already set.\nMapping is a dictionary of key/value pairs. Both keys and values\nshould be strings or types that can be cast to a string via str().\nReturns a boolean indicating if the operation was successful.\n\nFor more information see https://redis.io/commands/msetnx",
              "signature": "(self, mapping: Mapping[~AnyKeyT, Union[bytes, bytearray, memoryview, str, int, float]]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "object",
              "doc": "Return the encoding, idletime, or refcount about the key",
              "signature": "(self, infotype: str, key: Union[bytes, str, memoryview], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "parse_response",
              "doc": "Parses a response from the Redis server",
              "signature": "(self, connection, command_name, **options)"
            },
            {
              "name": "persist",
              "doc": "Removes an expiration on ``name``\n\nFor more information see https://redis.io/commands/persist",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pexpire",
              "doc": "Set an expire flag on key ``name`` for ``time`` milliseconds\nwith given ``option``. ``time`` can be represented by an\ninteger or a Python timedelta object.\n\nValid options are:\n    NX -> Set expiry only when the key has no expiry\n    XX -> Set expiry only when the key has an existing expiry\n    GT -> Set expiry only when the new expiry is greater than current one\n    LT -> Set expiry only when the new expiry is less than current one\n\nFor more information see https://redis.io/commands/pexpire",
              "signature": "(self, name: Union[bytes, str, memoryview], time: Union[int, datetime.timedelta], nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pexpireat",
              "doc": "Set an expire flag on key ``name`` with given ``option``. ``when``\ncan be represented as an integer representing unix time in\nmilliseconds (unix time * 1000) or a Python datetime object.\n\nValid options are:\n    NX -> Set expiry only when the key has no expiry\n    XX -> Set expiry only when the key has an existing expiry\n    GT -> Set expiry only when the new expiry is greater than current one\n    LT -> Set expiry only when the new expiry is less than current one\n\nFor more information see https://redis.io/commands/pexpireat",
              "signature": "(self, name: Union[bytes, str, memoryview], when: Union[int, datetime.datetime], nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pexpiretime",
              "doc": "Returns the absolute Unix timestamp (since January 1, 1970) in milliseconds\nat which the given key will expire.\n\nFor more information see https://redis.io/commands/pexpiretime",
              "signature": "(self, key: str) -> int"
            },
            {
              "name": "pfadd",
              "doc": "Adds the specified elements to the specified HyperLogLog.\n\nFor more information see https://redis.io/commands/pfadd",
              "signature": "(self, name: Union[bytes, str, memoryview], *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pfcount",
              "doc": "Return the approximated cardinality of\nthe set observed by the HyperLogLog at key(s).\n\nFor more information see https://redis.io/commands/pfcount",
              "signature": "(self, *sources: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pfmerge",
              "doc": "Merge N different HyperLogLogs into a single one.\n\nFor more information see https://redis.io/commands/pfmerge",
              "signature": "(self, dest: Union[bytes, str, memoryview], *sources: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "ping",
              "doc": "Ping the Redis server\n\nFor more information see https://redis.io/commands/ping",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pipeline",
              "doc": "Return a new pipeline object that can queue multiple commands for\nlater execution. ``transaction`` indicates whether all commands\nshould be executed atomically. Apart from making a group of operations\natomic, pipelines are useful for reducing the back-and-forth overhead\nbetween the client and server.",
              "signature": "(self, transaction=True, shard_hint=None) -> 'Pipeline'"
            },
            {
              "name": "psetex",
              "doc": "Set the value of key ``name`` to ``value`` that expires in ``time_ms``\nmilliseconds. ``time_ms`` can be represented by an integer or a Python\ntimedelta object\n\nFor more information see https://redis.io/commands/psetex",
              "signature": "(self, name: Union[bytes, str, memoryview], time_ms: Union[int, datetime.timedelta], value: Union[bytes, bytearray, memoryview, str, int, float])"
            },
            {
              "name": "psync",
              "doc": "Initiates a replication stream from the master.\nNewer version for `sync`.\n\nFor more information see https://redis.io/commands/sync",
              "signature": "(self, replicationid: str, offset: int)"
            },
            {
              "name": "pttl",
              "doc": "Returns the number of milliseconds until the key ``name`` will expire\n\nFor more information see https://redis.io/commands/pttl",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "publish",
              "doc": "Publish ``message`` on ``channel``.\nReturns the number of subscribers the message was delivered to.\n\nFor more information see https://redis.io/commands/publish",
              "signature": "(self, channel: Union[bytes, str, memoryview], message: Union[bytes, bytearray, memoryview, str, int, float], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub",
              "doc": "Return a Publish/Subscribe object. With this object, you can\nsubscribe to channels and listen for messages that get published to\nthem.",
              "signature": "(self, **kwargs)"
            },
            {
              "name": "pubsub_channels",
              "doc": "Return a list of channels that have at least one subscriber\n\nFor more information see https://redis.io/commands/pubsub-channels",
              "signature": "(self, pattern: Union[bytes, str, memoryview] = '*', **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub_numpat",
              "doc": "Returns the number of subscriptions to patterns\n\nFor more information see https://redis.io/commands/pubsub-numpat",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub_numsub",
              "doc": "Return a list of (channel, number of subscribers) tuples\nfor each channel given in ``*args``\n\nFor more information see https://redis.io/commands/pubsub-numsub",
              "signature": "(self, *args: Union[bytes, str, memoryview], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub_shardchannels",
              "doc": "Return a list of shard_channels that have at least one subscriber\n\nFor more information see https://redis.io/commands/pubsub-shardchannels",
              "signature": "(self, pattern: Union[bytes, str, memoryview] = '*', **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub_shardnumsub",
              "doc": "Return a list of (shard_channel, number of subscribers) tuples\nfor each channel given in ``*args``\n\nFor more information see https://redis.io/commands/pubsub-shardnumsub",
              "signature": "(self, *args: Union[bytes, str, memoryview], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "quit",
              "doc": "Ask the server to close the connection.\n\nFor more information see https://redis.io/commands/quit",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "randomkey",
              "doc": "Returns the name of a random key\n\nFor more information see https://redis.io/commands/randomkey",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "readonly",
              "doc": "Enables read queries for a connection to a Redis Cluster replica node.\n\nFor more information see https://redis.io/commands/readonly",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "readwrite",
              "doc": "Disables read queries for a connection to a Redis Cluster slave node.\n\nFor more information see https://redis.io/commands/readwrite",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "register_script",
              "doc": "Register a Lua ``script`` specifying the ``keys`` it will touch.\nReturns a Script object that is callable and hides the complexity of\ndeal with scripts, keys, and shas. This is the preferred way to work\nwith Lua scripts.",
              "signature": "(self: 'redis.client.Redis', script: Union[bytes, str, memoryview]) -> redis.commands.core.Script"
            },
            {
              "name": "rename",
              "doc": "Rename key ``src`` to ``dst``\n\nFor more information see https://redis.io/commands/rename",
              "signature": "(self, src: Union[bytes, str, memoryview], dst: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "renamenx",
              "doc": "Rename key ``src`` to ``dst`` if ``dst`` doesn't already exist\n\nFor more information see https://redis.io/commands/renamenx",
              "signature": "(self, src: Union[bytes, str, memoryview], dst: Union[bytes, str, memoryview])"
            },
            {
              "name": "replicaof",
              "doc": "Update the replication settings of a redis replica, on the fly.\n\nExamples of valid arguments include:\n\nNO ONE (set no replication)\nhost port (set to the host and port of a redis server)\n\nFor more information see  https://redis.io/commands/replicaof",
              "signature": "(self, *args, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "reset",
              "doc": "Perform a full reset on the connection's server side contenxt.\n\nSee: https://redis.io/commands/reset",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "restore",
              "doc": "Create a key using the provided serialized value, previously obtained\nusing DUMP.\n\n``replace`` allows an existing key on ``name`` to be overridden. If\nit's not specified an error is raised on collision.\n\n``absttl`` if True, specified ``ttl`` should represent an absolute Unix\ntimestamp in milliseconds in which the key will expire. (Redis 5.0 or\ngreater).\n\n``idletime`` Used for eviction, this is the number of seconds the\nkey must be idle, prior to execution.\n\n``frequency`` Used for eviction, this is the frequency counter of\nthe object stored at the key, prior to execution.\n\nFor more information see https://redis.io/commands/restore",
              "signature": "(self, name: Union[bytes, str, memoryview], ttl: float, value: Union[bytes, bytearray, memoryview, str, int, float], replace: bool = False, absttl: bool = False, idletime: Optional[int] = None, frequency: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "role",
              "doc": "Provide information on the role of a Redis instance in\nthe context of replication, by returning if the instance\nis currently a master, slave, or sentinel.\n\nFor more information see https://redis.io/commands/role",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "rpop",
              "doc": "Removes and returns the last elements of the list ``name``.\n\nBy default, the command pops a single element from the end of the list.\nWhen provided with the optional ``count`` argument, the reply will\nconsist of up to count elements, depending on the list's length.\n\nFor more information see https://redis.io/commands/rpop",
              "signature": "(self, name: str, count: Optional[int] = None) -> Union[Awaitable[Union[str, List, NoneType]], str, List, NoneType]"
            },
            {
              "name": "rpoplpush",
              "doc": "RPOP a value off of the ``src`` list and atomically LPUSH it\non to the ``dst`` list.  Returns the value.\n\nFor more information see https://redis.io/commands/rpoplpush",
              "signature": "(self, src: str, dst: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "rpush",
              "doc": "Push ``values`` onto the tail of the list ``name``\n\nFor more information see https://redis.io/commands/rpush",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "rpushx",
              "doc": "Push ``value`` onto the tail of the list ``name`` if ``name`` exists\n\nFor more information see https://redis.io/commands/rpushx",
              "signature": "(self, name: str, *values: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "sadd",
              "doc": "Add ``value(s)`` to set ``name``\n\nFor more information see https://redis.io/commands/sadd",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "save",
              "doc": "Tell the Redis server to save its data to disk,\nblocking until the save is complete\n\nFor more information see https://redis.io/commands/save",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "scan",
              "doc": "Incrementally return lists of key names. Also return a cursor\nindicating the scan position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` provides a hint to Redis about the number of keys to\n    return per batch.\n\n``_type`` filters the returned values by a particular Redis type.\n    Stock Redis instances allow for the following types:\n    HASH, LIST, SET, STREAM, STRING, ZSET\n    Additionally, Redis modules can expose other types as well.\n\nFor more information see https://redis.io/commands/scan",
              "signature": "(self, cursor: int = 0, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, _type: Optional[str] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "scan_iter",
              "doc": "Make an iterator using the SCAN command so that the client doesn't\nneed to remember the cursor position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` provides a hint to Redis about the number of keys to\n    return per batch.\n\n``_type`` filters the returned values by a particular Redis type.\n    Stock Redis instances allow for the following types:\n    HASH, LIST, SET, STREAM, STRING, ZSET\n    Additionally, Redis modules can expose other types as well.",
              "signature": "(self, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, _type: Optional[str] = None, **kwargs) -> Iterator"
            },
            {
              "name": "scard",
              "doc": "Return the number of elements in set ``name``\n\nFor more information see https://redis.io/commands/scard",
              "signature": "(self, name: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "script_debug",
              "doc": null,
              "signature": "(self, *args) -> None"
            },
            {
              "name": "script_exists",
              "doc": "Check if a script exists in the script cache by specifying the SHAs of\neach script as ``args``. Returns a list of boolean values indicating if\nif each already script exists in the cache_data.\n\nFor more information see  https://redis.io/commands/script-exists",
              "signature": "(self, *args: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "script_flush",
              "doc": "Flush all scripts from the script cache_data.\n\n``sync_type`` is by default SYNC (synchronous) but it can also be\n              ASYNC.\n\nFor more information see  https://redis.io/commands/script-flush",
              "signature": "(self, sync_type: Union[Literal['SYNC'], Literal['ASYNC']] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "script_kill",
              "doc": "Kill the currently executing Lua script\n\nFor more information see https://redis.io/commands/script-kill",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "script_load",
              "doc": "Load a Lua ``script`` into the script cache_data. Returns the SHA.\n\nFor more information see https://redis.io/commands/script-load",
              "signature": "(self, script: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sdiff",
              "doc": "Return the difference of sets specified by ``keys``\n\nFor more information see https://redis.io/commands/sdiff",
              "signature": "(self, keys: List, *args: List) -> Union[Awaitable[list], list]"
            },
            {
              "name": "sdiffstore",
              "doc": "Store the difference of sets specified by ``keys`` into a new\nset named ``dest``.  Returns the number of keys in the new set.\n\nFor more information see https://redis.io/commands/sdiffstore",
              "signature": "(self, dest: str, keys: List, *args: List) -> Union[Awaitable[int], int]"
            },
            {
              "name": "select",
              "doc": "Select the Redis logical database at index.\n\nSee: https://redis.io/commands/select",
              "signature": "(self, index: int, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sentinel",
              "doc": "Redis Sentinel's SENTINEL command.",
              "signature": "(self, *args)"
            },
            {
              "name": "sentinel_ckquorum",
              "doc": "Check if the current Sentinel configuration is able to reach the\nquorum needed to failover a master, and the majority needed to\nauthorize the failover.\n\nThis command should be used in monitoring systems to check if a\nSentinel deployment is ok.",
              "signature": "(self, new_master_name)"
            },
            {
              "name": "sentinel_failover",
              "doc": "Force a failover as if the master was not reachable, and without\nasking for agreement to other Sentinels (however a new version of the\nconfiguration will be published so that the other Sentinels will\nupdate their configurations).",
              "signature": "(self, new_master_name)"
            },
            {
              "name": "sentinel_flushconfig",
              "doc": "Force Sentinel to rewrite its configuration on disk, including the\ncurrent Sentinel state.\n\nNormally Sentinel rewrites the configuration every time something\nchanges in its state (in the context of the subset of the state which\nis persisted on disk across restart).\nHowever sometimes it is possible that the configuration file is lost\nbecause of operation errors, disk failures, package upgrade scripts or\nconfiguration managers. In those cases a way to to force Sentinel to\nrewrite the configuration file is handy.\n\nThis command works even if the previous configuration file is\ncompletely missing.",
              "signature": "(self)"
            },
            {
              "name": "sentinel_get_master_addr_by_name",
              "doc": "Returns a (host, port) pair for the given ``service_name``",
              "signature": "(self, service_name)"
            },
            {
              "name": "sentinel_master",
              "doc": "Returns a dictionary containing the specified masters state.",
              "signature": "(self, service_name)"
            },
            {
              "name": "sentinel_masters",
              "doc": "Returns a list of dictionaries containing each master's state.",
              "signature": "(self)"
            },
            {
              "name": "sentinel_monitor",
              "doc": "Add a new master to Sentinel to be monitored",
              "signature": "(self, name, ip, port, quorum)"
            },
            {
              "name": "sentinel_remove",
              "doc": "Remove a master from Sentinel's monitoring",
              "signature": "(self, name)"
            },
            {
              "name": "sentinel_reset",
              "doc": "This command will reset all the masters with matching name.\nThe pattern argument is a glob-style pattern.\n\nThe reset process clears any previous state in a master (including a\nfailover in progress), and removes every slave and sentinel already\ndiscovered and associated with the master.",
              "signature": "(self, pattern)"
            },
            {
              "name": "sentinel_sentinels",
              "doc": "Returns a list of sentinels for ``service_name``",
              "signature": "(self, service_name)"
            },
            {
              "name": "sentinel_set",
              "doc": "Set Sentinel monitoring parameters for a given master",
              "signature": "(self, name, option, value)"
            },
            {
              "name": "sentinel_slaves",
              "doc": "Returns a list of slaves for ``service_name``",
              "signature": "(self, service_name)"
            },
            {
              "name": "set",
              "doc": "Set the value at key ``name`` to ``value``\n\n``ex`` sets an expire flag on key ``name`` for ``ex`` seconds.\n\n``px`` sets an expire flag on key ``name`` for ``px`` milliseconds.\n\n``nx`` if set to True, set the value at key ``name`` to ``value`` only\n    if it does not exist.\n\n``xx`` if set to True, set the value at key ``name`` to ``value`` only\n    if it already exists.\n\n``keepttl`` if True, retain the time to live associated with the key.\n    (Available since Redis 6.0)\n\n``get`` if True, set the value at key ``name`` to ``value`` and return\n    the old value stored at key, or None if the key did not exist.\n    (Available since Redis 6.2)\n\n``exat`` sets an expire flag on key ``name`` for ``ex`` seconds,\n    specified in unix time.\n\n``pxat`` sets an expire flag on key ``name`` for ``ex`` milliseconds,\n    specified in unix time.\n\nFor more information see https://redis.io/commands/set",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float], ex: Union[int, datetime.timedelta, NoneType] = None, px: Union[int, datetime.timedelta, NoneType] = None, nx: bool = False, xx: bool = False, keepttl: bool = False, get: bool = False, exat: Union[int, datetime.datetime, NoneType] = None, pxat: Union[int, datetime.datetime, NoneType] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "set_response_callback",
              "doc": "Set a custom Response Callback",
              "signature": "(self, command: str, callback: Callable) -> None"
            },
            {
              "name": "set_retry",
              "doc": null,
              "signature": "(self, retry: redis.retry.Retry) -> None"
            },
            {
              "name": "setbit",
              "doc": "Flag the ``offset`` in ``name`` as ``value``. Returns an integer\nindicating the previous value of ``offset``.\n\nFor more information see https://redis.io/commands/setbit",
              "signature": "(self, name: Union[bytes, str, memoryview], offset: int, value: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "setex",
              "doc": "Set the value of key ``name`` to ``value`` that expires in ``time``\nseconds. ``time`` can be represented by an integer or a Python\ntimedelta object.\n\nFor more information see https://redis.io/commands/setex",
              "signature": "(self, name: Union[bytes, str, memoryview], time: Union[int, datetime.timedelta], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "setnx",
              "doc": "Set the value of key ``name`` to ``value`` if key doesn't exist\n\nFor more information see https://redis.io/commands/setnx",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "setrange",
              "doc": "Overwrite bytes in the value of ``name`` starting at ``offset`` with\n``value``. If ``offset`` plus the length of ``value`` exceeds the\nlength of the original value, the new value will be larger than before.\nIf ``offset`` exceeds the length of the original value, null bytes\nwill be used to pad between the end of the previous value and the start\nof what's being injected.\n\nReturns the length of the new string.\n\nFor more information see https://redis.io/commands/setrange",
              "signature": "(self, name: Union[bytes, str, memoryview], offset: int, value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "shutdown",
              "doc": "Shutdown the Redis server.  If Redis has persistence configured,\ndata will be flushed before shutdown.\nIt is possible to specify modifiers to alter the behavior of the command:\n``save`` will force a DB saving operation even if no save points are configured.\n``nosave`` will prevent a DB saving operation even if one or more save points\nare configured.\n``now`` skips waiting for lagging replicas, i.e. it bypasses the first step in\nthe shutdown sequence.\n``force`` ignores any errors that would normally prevent the server from exiting\n``abort`` cancels an ongoing shutdown and cannot be combined with other flags.\n\nFor more information see https://redis.io/commands/shutdown",
              "signature": "(self, save: bool = False, nosave: bool = False, now: bool = False, force: bool = False, abort: bool = False, **kwargs) -> None"
            },
            {
              "name": "sinter",
              "doc": "Return the intersection of sets specified by ``keys``\n\nFor more information see https://redis.io/commands/sinter",
              "signature": "(self, keys: List, *args: List) -> Union[Awaitable[list], list]"
            },
            {
              "name": "sintercard",
              "doc": "Return the cardinality of the intersect of multiple sets specified by ``keys``.\n\nWhen LIMIT provided (defaults to 0 and means unlimited), if the intersection\ncardinality reaches limit partway through the computation, the algorithm will\nexit and yield limit as the cardinality\n\nFor more information see https://redis.io/commands/sintercard",
              "signature": "(self, numkeys: int, keys: List[str], limit: int = 0) -> Union[Awaitable[int], int]"
            },
            {
              "name": "sinterstore",
              "doc": "Store the intersection of sets specified by ``keys`` into a new\nset named ``dest``.  Returns the number of keys in the new set.\n\nFor more information see https://redis.io/commands/sinterstore",
              "signature": "(self, dest: str, keys: List, *args: List) -> Union[Awaitable[int], int]"
            },
            {
              "name": "sismember",
              "doc": "Return whether ``value`` is a member of set ``name``:\n- 1 if the value is a member of the set.\n- 0 if the value is not a member of the set or if key does not exist.\n\nFor more information see https://redis.io/commands/sismember",
              "signature": "(self, name: str, value: str) -> Union[Awaitable[Union[Literal[0], Literal[1]]], Literal[0], Literal[1]]"
            },
            {
              "name": "slaveof",
              "doc": "Set the server to be a replicated slave of the instance identified\nby the ``host`` and ``port``. If called without arguments, the\ninstance is promoted to a master instead.\n\nFor more information see https://redis.io/commands/slaveof",
              "signature": "(self, host: Optional[str] = None, port: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "slowlog_get",
              "doc": "Get the entries from the slowlog. If ``num`` is specified, get the\nmost recent ``num`` items.\n\nFor more information see https://redis.io/commands/slowlog-get",
              "signature": "(self, num: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "slowlog_len",
              "doc": "Get the number of items in the slowlog\n\nFor more information see https://redis.io/commands/slowlog-len",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "slowlog_reset",
              "doc": "Remove all items in the slowlog\n\nFor more information see https://redis.io/commands/slowlog-reset",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "smembers",
              "doc": "Return all members of the set ``name``\n\nFor more information see https://redis.io/commands/smembers",
              "signature": "(self, name: str) -> Union[Awaitable[Set], Set]"
            },
            {
              "name": "smismember",
              "doc": "Return whether each value in ``values`` is a member of the set ``name``\nas a list of ``int`` in the order of ``values``:\n- 1 if the value is a member of the set.\n- 0 if the value is not a member of the set or if key does not exist.\n\nFor more information see https://redis.io/commands/smismember",
              "signature": "(self, name: str, values: List, *args: List) -> Union[Awaitable[List[Union[Literal[0], Literal[1]]]], List[Union[Literal[0], Literal[1]]]]"
            },
            {
              "name": "smove",
              "doc": "Move ``value`` from set ``src`` to set ``dst`` atomically\n\nFor more information see https://redis.io/commands/smove",
              "signature": "(self, src: str, dst: str, value: str) -> Union[Awaitable[bool], bool]"
            },
            {
              "name": "sort",
              "doc": "Sort and return the list, set or sorted set at ``name``.\n\n``start`` and ``num`` allow for paging through the sorted data\n\n``by`` allows using an external key to weight and sort the items.\n    Use an \"*\" to indicate where in the key the item value is located\n\n``get`` allows for returning items from external keys rather than the\n    sorted data itself.  Use an \"*\" to indicate where in the key\n    the item value is located\n\n``desc`` allows for reversing the sort\n\n``alpha`` allows for sorting lexicographically rather than numerically\n\n``store`` allows for storing the result of the sort into\n    the key ``store``\n\n``groups`` if set to True and if ``get`` contains at least two\n    elements, sort will return a list of tuples, each containing the\n    values fetched from the arguments to ``get``.\n\nFor more information see https://redis.io/commands/sort",
              "signature": "(self, name: str, start: Optional[int] = None, num: Optional[int] = None, by: Optional[str] = None, get: Optional[List[str]] = None, desc: bool = False, alpha: bool = False, store: Optional[str] = None, groups: Optional[bool] = False) -> Union[List, int]"
            },
            {
              "name": "sort_ro",
              "doc": "Returns the elements contained in the list, set or sorted set at key.\n(read-only variant of the SORT command)\n\n``start`` and ``num`` allow for paging through the sorted data\n\n``by`` allows using an external key to weight and sort the items.\n    Use an \"*\" to indicate where in the key the item value is located\n\n``get`` allows for returning items from external keys rather than the\n    sorted data itself.  Use an \"*\" to indicate where in the key\n    the item value is located\n\n``desc`` allows for reversing the sort\n\n``alpha`` allows for sorting lexicographically rather than numerically\n\nFor more information see https://redis.io/commands/sort_ro",
              "signature": "(self, key: str, start: Optional[int] = None, num: Optional[int] = None, by: Optional[str] = None, get: Optional[List[str]] = None, desc: bool = False, alpha: bool = False) -> list"
            },
            {
              "name": "spop",
              "doc": "Remove and return a random member of set ``name``\n\nFor more information see https://redis.io/commands/spop",
              "signature": "(self, name: str, count: Optional[int] = None) -> Union[str, List, NoneType]"
            },
            {
              "name": "spublish",
              "doc": "Posts a message to the given shard channel.\nReturns the number of clients that received the message\n\nFor more information see https://redis.io/commands/spublish",
              "signature": "(self, shard_channel: Union[bytes, str, memoryview], message: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "srandmember",
              "doc": "If ``number`` is None, returns a random member of set ``name``.\n\nIf ``number`` is supplied, returns a list of ``number`` random\nmembers of set ``name``. Note this is only available when running\nRedis 2.6+.\n\nFor more information see https://redis.io/commands/srandmember",
              "signature": "(self, name: str, number: Optional[int] = None) -> Union[str, List, NoneType]"
            },
            {
              "name": "srem",
              "doc": "Remove ``values`` from set ``name``\n\nFor more information see https://redis.io/commands/srem",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "sscan",
              "doc": "Incrementally return lists of elements in a set. Also return a cursor\nindicating the scan position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\nFor more information see https://redis.io/commands/sscan",
              "signature": "(self, name: Union[bytes, str, memoryview], cursor: int = 0, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sscan_iter",
              "doc": "Make an iterator using the SSCAN command so that the client doesn't\nneed to remember the cursor position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns",
              "signature": "(self, name: Union[bytes, str, memoryview], match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None) -> Iterator"
            },
            {
              "name": "stralgo",
              "doc": "Implements complex algorithms that operate on strings.\nRight now the only algorithm implemented is the LCS algorithm\n(longest common substring). However new algorithms could be\nimplemented in the future.\n\n``algo`` Right now must be LCS\n``value1`` and ``value2`` Can be two strings or two keys\n``specific_argument`` Specifying if the arguments to the algorithm\nwill be keys or strings. strings is the default.\n``len`` Returns just the len of the match.\n``idx`` Returns the match positions in each string.\n``minmatchlen`` Restrict the list of matches to the ones of a given\nminimal length. Can be provided only when ``idx`` set to True.\n``withmatchlen`` Returns the matches with the len of the match.\nCan be provided only when ``idx`` set to True.\n\nFor more information see https://redis.io/commands/stralgo",
              "signature": "(self, algo: Literal['LCS'], value1: Union[bytes, str, memoryview], value2: Union[bytes, str, memoryview], specific_argument: Union[Literal['strings'], Literal['keys']] = 'strings', len: bool = False, idx: bool = False, minmatchlen: Optional[int] = None, withmatchlen: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "strlen",
              "doc": "Return the number of bytes stored in the value of ``name``\n\nFor more information see https://redis.io/commands/strlen",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "substr",
              "doc": "Return a substring of the string at key ``name``. ``start`` and ``end``\nare 0-based integers specifying the portion of the string to return.",
              "signature": "(self, name: Union[bytes, str, memoryview], start: int, end: int = -1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sunion",
              "doc": "Return the union of sets specified by ``keys``\n\nFor more information see https://redis.io/commands/sunion",
              "signature": "(self, keys: List, *args: List) -> Union[Awaitable[List], List]"
            },
            {
              "name": "sunionstore",
              "doc": "Store the union of sets specified by ``keys`` into a new\nset named ``dest``.  Returns the number of keys in the new set.\n\nFor more information see https://redis.io/commands/sunionstore",
              "signature": "(self, dest: str, keys: List, *args: List) -> Union[Awaitable[int], int]"
            },
            {
              "name": "swapdb",
              "doc": "Swap two databases\n\nFor more information see https://redis.io/commands/swapdb",
              "signature": "(self, first: int, second: int, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sync",
              "doc": "Initiates a replication stream from the master.\n\nFor more information see https://redis.io/commands/sync",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "tdigest",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'TDigestBloom'"
            },
            {
              "name": "time",
              "doc": "Returns the server time as a 2-item tuple of ints:\n(seconds since epoch, microseconds into this second).\n\nFor more information see https://redis.io/commands/time",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "topk",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'TOPKBloom'"
            },
            {
              "name": "touch",
              "doc": "Alters the last access time of a key(s) ``*args``. A key is ignored\nif it does not exist.\n\nFor more information see https://redis.io/commands/touch",
              "signature": "(self, *args: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "transaction",
              "doc": "Convenience method for executing the callable `func` as a transaction\nwhile watching all keys specified in `watches`. The 'func' callable\nshould expect a single argument which is a Pipeline object.",
              "signature": "(self, func: Callable[[ForwardRef('Pipeline')], NoneType], *watches, **kwargs) -> None"
            },
            {
              "name": "ts",
              "doc": "Access the timeseries namespace, providing support for\nredis timeseries data.",
              "signature": "(self) -> 'TimeSeries'"
            },
            {
              "name": "ttl",
              "doc": "Returns the number of seconds until the key ``name`` will expire\n\nFor more information see https://redis.io/commands/ttl",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "type",
              "doc": "Returns the type of key ``name``\n\nFor more information see https://redis.io/commands/type",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "unlink",
              "doc": "Unlink one or more keys specified by ``names``\n\nFor more information see https://redis.io/commands/unlink",
              "signature": "(self, *names: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "unwatch",
              "doc": "Unwatches all previously watched keys for a transaction\n\nFor more information see https://redis.io/commands/unwatch",
              "signature": "(self) -> None"
            },
            {
              "name": "vset",
              "doc": "Access the VectorSet commands namespace.",
              "signature": "(self) -> 'VectorSet'"
            },
            {
              "name": "wait",
              "doc": "Redis synchronous replication\nThat returns the number of replicas that processed the query when\nwe finally have at least ``num_replicas``, or when the ``timeout`` was\nreached.\n\nFor more information see https://redis.io/commands/wait",
              "signature": "(self, num_replicas: int, timeout: int, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "waitaof",
              "doc": "This command blocks the current client until all previous write\ncommands by that client are acknowledged as having been fsynced\nto the AOF of the local Redis and/or at least the specified number\nof replicas.\n\nFor more information see https://redis.io/commands/waitaof",
              "signature": "(self, num_local: int, num_replicas: int, timeout: int, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "watch",
              "doc": "Watches the values at keys ``names``, or None if the key doesn't exist\n\nFor more information see https://redis.io/commands/watch",
              "signature": "(self, *names: Union[bytes, str, memoryview]) -> None"
            },
            {
              "name": "xack",
              "doc": "Acknowledges the successful processing of one or more messages.\n\nArgs:\n    name: name of the stream.\n    groupname: name of the consumer group.\n    *ids: message ids to acknowledge.\n\nFor more information see https://redis.io/commands/xack",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], *ids: Union[int, bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xadd",
              "doc": "Add to a stream.\nname: name of the stream\nfields: dict of field/value pairs to insert into the stream\nid: Location to insert this record. By default it is appended.\nmaxlen: truncate old stream members beyond this size.\nCan't be specified with minid.\napproximate: actual stream length may be slightly more than maxlen\nnomkstream: When set to true, do not make a stream\nminid: the minimum id in the stream to query.\nCan't be specified with maxlen.\nlimit: specifies the maximum number of entries to retrieve\n\nFor more information see https://redis.io/commands/xadd",
              "signature": "(self, name: Union[bytes, str, memoryview], fields: Dict[Union[bytes, bytearray, memoryview, str, int, float], Union[bytes, bytearray, memoryview, str, int, float]], id: Union[int, bytes, str, memoryview] = '*', maxlen: Optional[int] = None, approximate: bool = True, nomkstream: bool = False, minid: Union[int, bytes, str, memoryview, NoneType] = None, limit: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xautoclaim",
              "doc": "Transfers ownership of pending stream entries that match the specified\ncriteria. Conceptually, equivalent to calling XPENDING and then XCLAIM,\nbut provides a more straightforward way to deal with message delivery\nfailures via SCAN-like semantics.\nname: name of the stream.\ngroupname: name of the consumer group.\nconsumername: name of a consumer that claims the message.\nmin_idle_time: filter messages that were idle less than this amount of\nmilliseconds.\nstart_id: filter messages with equal or greater ID.\ncount: optional integer, upper limit of the number of entries that the\ncommand attempts to claim. Set to 100 by default.\njustid: optional boolean, false by default. Return just an array of IDs\nof messages successfully claimed, without returning the actual message\n\nFor more information see https://redis.io/commands/xautoclaim",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], consumername: Union[bytes, str, memoryview], min_idle_time: int, start_id: Union[int, bytes, str, memoryview] = '0-0', count: Optional[int] = None, justid: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xclaim",
              "doc": "Changes the ownership of a pending message.\n\nname: name of the stream.\n\ngroupname: name of the consumer group.\n\nconsumername: name of a consumer that claims the message.\n\nmin_idle_time: filter messages that were idle less than this amount of\nmilliseconds\n\nmessage_ids: non-empty list or tuple of message IDs to claim\n\nidle: optional. Set the idle time (last time it was delivered) of the\nmessage in ms\n\ntime: optional integer. This is the same as idle but instead of a\nrelative amount of milliseconds, it sets the idle time to a specific\nUnix time (in milliseconds).\n\nretrycount: optional integer. set the retry counter to the specified\nvalue. This counter is incremented every time a message is delivered\nagain.\n\nforce: optional boolean, false by default. Creates the pending message\nentry in the PEL even if certain specified IDs are not already in the\nPEL assigned to a different client.\n\njustid: optional boolean, false by default. Return just an array of IDs\nof messages successfully claimed, without returning the actual message\n\nFor more information see https://redis.io/commands/xclaim",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], consumername: Union[bytes, str, memoryview], min_idle_time: int, message_ids: Union[List[Union[int, bytes, str, memoryview]], Tuple[Union[int, bytes, str, memoryview]]], idle: Optional[int] = None, time: Optional[int] = None, retrycount: Optional[int] = None, force: bool = False, justid: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xdel",
              "doc": "Deletes one or more messages from a stream.\n\nArgs:\n    name: name of the stream.\n    *ids: message ids to delete.\n\nFor more information see https://redis.io/commands/xdel",
              "signature": "(self, name: Union[bytes, str, memoryview], *ids: Union[int, bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_create",
              "doc": "Create a new consumer group associated with a stream.\nname: name of the stream.\ngroupname: name of the consumer group.\nid: ID of the last item in the stream to consider already delivered.\n\nFor more information see https://redis.io/commands/xgroup-create",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], id: Union[int, bytes, str, memoryview] = '$', mkstream: bool = False, entries_read: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_createconsumer",
              "doc": "Consumers in a consumer group are auto-created every time a new\nconsumer name is mentioned by some command.\nThey can be explicitly created by using this command.\nname: name of the stream.\ngroupname: name of the consumer group.\nconsumername: name of consumer to create.\n\nSee: https://redis.io/commands/xgroup-createconsumer",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], consumername: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_delconsumer",
              "doc": "Remove a specific consumer from a consumer group.\nReturns the number of pending messages that the consumer had before it\nwas deleted.\nname: name of the stream.\ngroupname: name of the consumer group.\nconsumername: name of consumer to delete\n\nFor more information see https://redis.io/commands/xgroup-delconsumer",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], consumername: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_destroy",
              "doc": "Destroy a consumer group.\nname: name of the stream.\ngroupname: name of the consumer group.\n\nFor more information see https://redis.io/commands/xgroup-destroy",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_setid",
              "doc": "Set the consumer group last delivered ID to something else.\nname: name of the stream.\ngroupname: name of the consumer group.\nid: ID of the last item in the stream to consider already delivered.\n\nFor more information see https://redis.io/commands/xgroup-setid",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], id: Union[int, bytes, str, memoryview], entries_read: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xinfo_consumers",
              "doc": "Returns general information about the consumers in the group.\nname: name of the stream.\ngroupname: name of the consumer group.\n\nFor more information see https://redis.io/commands/xinfo-consumers",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xinfo_groups",
              "doc": "Returns general information about the consumer groups of the stream.\nname: name of the stream.\n\nFor more information see https://redis.io/commands/xinfo-groups",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xinfo_stream",
              "doc": "Returns general information about the stream.\nname: name of the stream.\nfull: optional boolean, false by default. Return full summary\n\nFor more information see https://redis.io/commands/xinfo-stream",
              "signature": "(self, name: Union[bytes, str, memoryview], full: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xlen",
              "doc": "Returns the number of elements in a given stream.\n\nFor more information see https://redis.io/commands/xlen",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xpending",
              "doc": "Returns information about pending messages of a group.\nname: name of the stream.\ngroupname: name of the consumer group.\n\nFor more information see https://redis.io/commands/xpending",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xpending_range",
              "doc": "Returns information about pending messages, in a range.\n\nname: name of the stream.\ngroupname: name of the consumer group.\nidle: available from  version 6.2. filter entries by their\nidle-time, given in milliseconds (optional).\nmin: minimum stream ID.\nmax: maximum stream ID.\ncount: number of messages to return\nconsumername: name of a consumer to filter by (optional).",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], min: Union[int, bytes, str, memoryview], max: Union[int, bytes, str, memoryview], count: int, consumername: Union[bytes, str, memoryview, NoneType] = None, idle: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xrange",
              "doc": "Read stream values within an interval.\n\nname: name of the stream.\n\nstart: first stream ID. defaults to '-',\n       meaning the earliest available.\n\nfinish: last stream ID. defaults to '+',\n        meaning the latest available.\n\ncount: if set, only return this many items, beginning with the\n       earliest available.\n\nFor more information see https://redis.io/commands/xrange",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[int, bytes, str, memoryview] = '-', max: Union[int, bytes, str, memoryview] = '+', count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xread",
              "doc": "Block and monitor multiple streams for new data.\n\nstreams: a dict of stream names to stream IDs, where\n           IDs indicate the last ID already seen.\n\ncount: if set, only return this many items, beginning with the\n       earliest available.\n\nblock: number of milliseconds to wait, if nothing already present.\n\nFor more information see https://redis.io/commands/xread",
              "signature": "(self, streams: Dict[Union[bytes, str, memoryview], Union[int, bytes, str, memoryview]], count: Optional[int] = None, block: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xreadgroup",
              "doc": "Read from a stream via a consumer group.\n\ngroupname: name of the consumer group.\n\nconsumername: name of the requesting consumer.\n\nstreams: a dict of stream names to stream IDs, where\n       IDs indicate the last ID already seen.\n\ncount: if set, only return this many items, beginning with the\n       earliest available.\n\nblock: number of milliseconds to wait, if nothing already present.\nnoack: do not add messages to the PEL\n\nFor more information see https://redis.io/commands/xreadgroup",
              "signature": "(self, groupname: str, consumername: str, streams: Dict[Union[bytes, str, memoryview], Union[int, bytes, str, memoryview]], count: Optional[int] = None, block: Optional[int] = None, noack: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xrevrange",
              "doc": "Read stream values within an interval, in reverse order.\n\nname: name of the stream\n\nstart: first stream ID. defaults to '+',\n       meaning the latest available.\n\nfinish: last stream ID. defaults to '-',\n        meaning the earliest available.\n\ncount: if set, only return this many items, beginning with the\n       latest available.\n\nFor more information see https://redis.io/commands/xrevrange",
              "signature": "(self, name: Union[bytes, str, memoryview], max: Union[int, bytes, str, memoryview] = '+', min: Union[int, bytes, str, memoryview] = '-', count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xtrim",
              "doc": "Trims old messages from a stream.\nname: name of the stream.\nmaxlen: truncate old stream messages beyond this size\nCan't be specified with minid.\napproximate: actual stream length may be slightly more than maxlen\nminid: the minimum id in the stream to query\nCan't be specified with maxlen.\nlimit: specifies the maximum number of entries to retrieve\n\nFor more information see https://redis.io/commands/xtrim",
              "signature": "(self, name: Union[bytes, str, memoryview], maxlen: Optional[int] = None, approximate: bool = True, minid: Union[int, bytes, str, memoryview, NoneType] = None, limit: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zadd",
              "doc": "Set any number of element-name, score pairs to the key ``name``. Pairs\nare specified as a dict of element-names keys to score values.\n\n``nx`` forces ZADD to only create new elements and not to update\nscores for elements that already exist.\n\n``xx`` forces ZADD to only update scores of elements that already\nexist. New elements will not be added.\n\n``ch`` modifies the return value to be the numbers of elements changed.\nChanged elements include new elements that were added and elements\nwhose scores changed.\n\n``incr`` modifies ZADD to behave like ZINCRBY. In this mode only a\nsingle element/score pair can be specified and the score is the amount\nthe existing score will be incremented by. When using this mode the\nreturn value of ZADD will be the new score of the element.\n\n``LT`` Only update existing elements if the new score is less than\nthe current score. This flag doesn't prevent adding new elements.\n\n``GT`` Only update existing elements if the new score is greater than\nthe current score. This flag doesn't prevent adding new elements.\n\nThe return value of ZADD varies based on the mode specified. With no\noptions, ZADD returns the number of new elements added to the sorted\nset.\n\n``NX``, ``LT``, and ``GT`` are mutually exclusive options.\n\nSee: https://redis.io/commands/ZADD",
              "signature": "(self, name: Union[bytes, str, memoryview], mapping: Mapping[~AnyKeyT, Union[bytes, bytearray, memoryview, str, int, float]], nx: bool = False, xx: bool = False, ch: bool = False, incr: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zcard",
              "doc": "Return the number of elements in the sorted set ``name``\n\nFor more information see https://redis.io/commands/zcard",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zcount",
              "doc": "Returns the number of elements in the sorted set at key ``name`` with\na score between ``min`` and ``max``.\n\nFor more information see https://redis.io/commands/zcount",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[float, str], max: Union[float, str]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zdiff",
              "doc": "Returns the difference between the first and all successive input\nsorted sets provided in ``keys``.\n\nFor more information see https://redis.io/commands/zdiff",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], withscores: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zdiffstore",
              "doc": "Computes the difference between the first and all successive input\nsorted sets provided in ``keys`` and stores the result in ``dest``.\n\nFor more information see https://redis.io/commands/zdiffstore",
              "signature": "(self, dest: Union[bytes, str, memoryview], keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zincrby",
              "doc": "Increment the score of ``value`` in sorted set ``name`` by ``amount``\n\nFor more information see https://redis.io/commands/zincrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: float, value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zinter",
              "doc": "Return the intersect of multiple sorted sets specified by ``keys``.\nWith the ``aggregate`` option, it is possible to specify how the\nresults of the union are aggregated. This option defaults to SUM,\nwhere the score of an element is summed across the inputs where it\nexists. When this option is set to either MIN or MAX, the resulting\nset will contain the minimum or maximum score of an element across\nthe inputs where it exists.\n\nFor more information see https://redis.io/commands/zinter",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], aggregate: Optional[str] = None, withscores: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zintercard",
              "doc": "Return the cardinality of the intersect of multiple sorted sets\nspecified by ``keys``.\nWhen LIMIT provided (defaults to 0 and means unlimited), if the intersection\ncardinality reaches limit partway through the computation, the algorithm will\nexit and yield limit as the cardinality\n\nFor more information see https://redis.io/commands/zintercard",
              "signature": "(self, numkeys: int, keys: List[str], limit: int = 0) -> Union[Awaitable[int], int]"
            },
            {
              "name": "zinterstore",
              "doc": "Intersect multiple sorted sets specified by ``keys`` into a new\nsorted set, ``dest``. Scores in the destination will be aggregated\nbased on the ``aggregate``. This option defaults to SUM, where the\nscore of an element is summed across the inputs where it exists.\nWhen this option is set to either MIN or MAX, the resulting set will\ncontain the minimum or maximum score of an element across the inputs\nwhere it exists.\n\nFor more information see https://redis.io/commands/zinterstore",
              "signature": "(self, dest: Union[bytes, str, memoryview], keys: Union[Sequence[Union[bytes, str, memoryview]], Mapping[~AnyKeyT, float]], aggregate: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zlexcount",
              "doc": "Return the number of items in the sorted set ``name`` between the\nlexicographical range ``min`` and ``max``.\n\nFor more information see https://redis.io/commands/zlexcount",
              "signature": "(self, name, min, max)"
            },
            {
              "name": "zmpop",
              "doc": "Pop ``count`` values (default 1) off of the first non-empty sorted set\nnamed in the ``keys`` list.\nFor more information see https://redis.io/commands/zmpop",
              "signature": "(self, num_keys: int, keys: List[str], min: Optional[bool] = False, max: Optional[bool] = False, count: Optional[int] = 1) -> Union[Awaitable[list], list]"
            },
            {
              "name": "zmscore",
              "doc": "Returns the scores associated with the specified members\nin the sorted set stored at key.\n``members`` should be a list of the member name.\nReturn type is a list of score.\nIf the member does not exist, a None will be returned\nin corresponding position.\n\nFor more information see https://redis.io/commands/zmscore",
              "signature": "(self, key: Union[bytes, str, memoryview], members: List[str]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zpopmax",
              "doc": "Remove and return up to ``count`` members with the highest scores\nfrom the sorted set ``name``.\n\nFor more information see https://redis.io/commands/zpopmax",
              "signature": "(self, name: Union[bytes, str, memoryview], count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zpopmin",
              "doc": "Remove and return up to ``count`` members with the lowest scores\nfrom the sorted set ``name``.\n\nFor more information see https://redis.io/commands/zpopmin",
              "signature": "(self, name: Union[bytes, str, memoryview], count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrandmember",
              "doc": "Return a random element from the sorted set value stored at key.\n\n``count`` if the argument is positive, return an array of distinct\nfields. If called with a negative count, the behavior changes and\nthe command is allowed to return the same field multiple times.\nIn this case, the number of returned fields is the absolute value\nof the specified count.\n\n``withscores`` The optional WITHSCORES modifier changes the reply so it\nincludes the respective scores of the randomly selected elements from\nthe sorted set.\n\nFor more information see https://redis.io/commands/zrandmember",
              "signature": "(self, key: Union[bytes, str, memoryview], count: Optional[int] = None, withscores: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrange",
              "doc": "Return a range of values from sorted set ``name`` between\n``start`` and ``end`` sorted in ascending order.\n\n``start`` and ``end`` can be negative, indicating the end of the range.\n\n``desc`` a boolean indicating whether to sort the results in reversed\norder.\n\n``withscores`` indicates to return the scores along with the values.\nThe return type is a list of (value, score) pairs.\n\n``score_cast_func`` a callable used to cast the score return value.\n\n``byscore`` when set to True, returns the range of elements from the\nsorted set having scores equal or between ``start`` and ``end``.\n\n``bylex`` when set to True, returns the range of elements from the\nsorted set between the ``start`` and ``end`` lexicographical closed\nrange intervals.\nValid ``start`` and ``end`` must start with ( or [, in order to specify\nwhether the range interval is exclusive or inclusive, respectively.\n\n``offset`` and ``num`` are specified, then return a slice of the range.\nCan't be provided when using ``bylex``.\n\nFor more information see https://redis.io/commands/zrange",
              "signature": "(self, name: Union[bytes, str, memoryview], start: int, end: int, desc: bool = False, withscores: bool = False, score_cast_func: Union[type, Callable] = <class 'float'>, byscore: bool = False, bylex: bool = False, offset: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrangebylex",
              "doc": "Return the lexicographical range of values from sorted set ``name``\nbetween ``min`` and ``max``.\n\nIf ``start`` and ``num`` are specified, then return a slice of the\nrange.\n\nFor more information see https://redis.io/commands/zrangebylex",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[bytes, bytearray, memoryview, str, int, float], max: Union[bytes, bytearray, memoryview, str, int, float], start: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrangebyscore",
              "doc": "Return a range of values from the sorted set ``name`` with scores\nbetween ``min`` and ``max``.\n\nIf ``start`` and ``num`` are specified, then return a slice\nof the range.\n\n``withscores`` indicates to return the scores along with the values.\nThe return type is a list of (value, score) pairs\n\n`score_cast_func`` a callable used to cast the score return value\n\nFor more information see https://redis.io/commands/zrangebyscore",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[float, str], max: Union[float, str], start: Optional[int] = None, num: Optional[int] = None, withscores: bool = False, score_cast_func: Union[type, Callable] = <class 'float'>) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrangestore",
              "doc": "Stores in ``dest`` the result of a range of values from sorted set\n``name`` between ``start`` and ``end`` sorted in ascending order.\n\n``start`` and ``end`` can be negative, indicating the end of the range.\n\n``byscore`` when set to True, returns the range of elements from the\nsorted set having scores equal or between ``start`` and ``end``.\n\n``bylex`` when set to True, returns the range of elements from the\nsorted set between the ``start`` and ``end`` lexicographical closed\nrange intervals.\nValid ``start`` and ``end`` must start with ( or [, in order to specify\nwhether the range interval is exclusive or inclusive, respectively.\n\n``desc`` a boolean indicating whether to sort the results in reversed\norder.\n\n``offset`` and ``num`` are specified, then return a slice of the range.\nCan't be provided when using ``bylex``.\n\nFor more information see https://redis.io/commands/zrangestore",
              "signature": "(self, dest: Union[bytes, str, memoryview], name: Union[bytes, str, memoryview], start: int, end: int, byscore: bool = False, bylex: bool = False, desc: bool = False, offset: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrank",
              "doc": "Returns a 0-based value indicating the rank of ``value`` in sorted set\n``name``.\nThe optional WITHSCORE argument supplements the command's\nreply with the score of the element returned.\n\nFor more information see https://redis.io/commands/zrank",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float], withscore: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrem",
              "doc": "Remove member ``values`` from sorted set ``name``\n\nFor more information see https://redis.io/commands/zrem",
              "signature": "(self, name: Union[bytes, str, memoryview], *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zremrangebylex",
              "doc": "Remove all elements in the sorted set ``name`` between the\nlexicographical range specified by ``min`` and ``max``.\n\nReturns the number of elements removed.\n\nFor more information see https://redis.io/commands/zremrangebylex",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[bytes, bytearray, memoryview, str, int, float], max: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zremrangebyrank",
              "doc": "Remove all elements in the sorted set ``name`` with ranks between\n``min`` and ``max``. Values are 0-based, ordered from smallest score\nto largest. Values can be negative indicating the highest scores.\nReturns the number of elements removed\n\nFor more information see https://redis.io/commands/zremrangebyrank",
              "signature": "(self, name: Union[bytes, str, memoryview], min: int, max: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zremrangebyscore",
              "doc": "Remove all elements in the sorted set ``name`` with scores\nbetween ``min`` and ``max``. Returns the number of elements removed.\n\nFor more information see https://redis.io/commands/zremrangebyscore",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[float, str], max: Union[float, str]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrevrange",
              "doc": "Return a range of values from sorted set ``name`` between\n``start`` and ``end`` sorted in descending order.\n\n``start`` and ``end`` can be negative, indicating the end of the range.\n\n``withscores`` indicates to return the scores along with the values\nThe return type is a list of (value, score) pairs\n\n``score_cast_func`` a callable used to cast the score return value\n\nFor more information see https://redis.io/commands/zrevrange",
              "signature": "(self, name: Union[bytes, str, memoryview], start: int, end: int, withscores: bool = False, score_cast_func: Union[type, Callable] = <class 'float'>) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrevrangebylex",
              "doc": "Return the reversed lexicographical range of values from sorted set\n``name`` between ``max`` and ``min``.\n\nIf ``start`` and ``num`` are specified, then return a slice of the\nrange.\n\nFor more information see https://redis.io/commands/zrevrangebylex",
              "signature": "(self, name: Union[bytes, str, memoryview], max: Union[bytes, bytearray, memoryview, str, int, float], min: Union[bytes, bytearray, memoryview, str, int, float], start: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrevrangebyscore",
              "doc": "Return a range of values from the sorted set ``name`` with scores\nbetween ``min`` and ``max`` in descending order.\n\nIf ``start`` and ``num`` are specified, then return a slice\nof the range.\n\n``withscores`` indicates to return the scores along with the values.\nThe return type is a list of (value, score) pairs\n\n``score_cast_func`` a callable used to cast the score return value\n\nFor more information see https://redis.io/commands/zrevrangebyscore",
              "signature": "(self, name: Union[bytes, str, memoryview], max: Union[float, str], min: Union[float, str], start: Optional[int] = None, num: Optional[int] = None, withscores: bool = False, score_cast_func: Union[type, Callable] = <class 'float'>)"
            },
            {
              "name": "zrevrank",
              "doc": "Returns a 0-based value indicating the descending rank of\n``value`` in sorted set ``name``.\nThe optional ``withscore`` argument supplements the command's\nreply with the score of the element returned.\n\nFor more information see https://redis.io/commands/zrevrank",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float], withscore: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zscan",
              "doc": "Incrementally return lists of elements in a sorted set. Also return a\ncursor indicating the scan position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\n``score_cast_func`` a callable used to cast the score return value\n\nFor more information see https://redis.io/commands/zscan",
              "signature": "(self, name: Union[bytes, str, memoryview], cursor: int = 0, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, score_cast_func: Union[type, Callable] = <class 'float'>) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zscan_iter",
              "doc": "Make an iterator using the ZSCAN command so that the client doesn't\nneed to remember the cursor position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\n``score_cast_func`` a callable used to cast the score return value",
              "signature": "(self, name: Union[bytes, str, memoryview], match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, score_cast_func: Union[type, Callable] = <class 'float'>) -> Iterator"
            },
            {
              "name": "zscore",
              "doc": "Return the score of element ``value`` in sorted set ``name``\n\nFor more information see https://redis.io/commands/zscore",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zunion",
              "doc": "Return the union of multiple sorted sets specified by ``keys``.\n``keys`` can be provided as dictionary of keys and their weights.\nScores will be aggregated based on the ``aggregate``, or SUM if\nnone is provided.\n\nFor more information see https://redis.io/commands/zunion",
              "signature": "(self, keys: Union[Sequence[Union[bytes, str, memoryview]], Mapping[~AnyKeyT, float]], aggregate: Optional[str] = None, withscores: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zunionstore",
              "doc": "Union multiple sorted sets specified by ``keys`` into\na new sorted set, ``dest``. Scores in the destination will be\naggregated based on the ``aggregate``, or SUM if none is provided.\n\nFor more information see https://redis.io/commands/zunionstore",
              "signature": "(self, dest: Union[bytes, str, memoryview], keys: Union[Sequence[Union[bytes, str, memoryview]], Mapping[~AnyKeyT, float]], aggregate: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            }
          ]
        },
        {
          "name": "RedisCluster",
          "doc": "A class for all Redis Cluster commands\n\nFor key-based commands, the target node(s) will be internally determined\nby the keys' hash slot.\nNon-key-based commands can be executed with the 'target_nodes' argument to\ntarget specific nodes. By default, if target_nodes is not specified, the\ncommand will be executed on the default cluster node.\n\n:param :target_nodes: type can be one of the followings:\n    - nodes flag: ALL_NODES, PRIMARIES, REPLICAS, RANDOM\n    - 'ClusterNode'\n    - 'list(ClusterNodes)'\n    - 'dict(any:clusterNodes)'\n\nfor example:\n    r.cluster_info(target_nodes=RedisCluster.ALL_NODES)",
          "functions": [
            {
              "name": "__contains__",
              "doc": "Returns the number of ``names`` that exist\n\nFor more information see https://redis.io/commands/exists",
              "signature": "(self, *names: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "__del__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__delitem__",
              "doc": null,
              "signature": "(self, name: Union[bytes, str, memoryview])"
            },
            {
              "name": "__enter__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__exit__",
              "doc": null,
              "signature": "(self, exc_type, exc_value, traceback)"
            },
            {
              "name": "__getitem__",
              "doc": "Return the value at key ``name``, raises a KeyError if the key\ndoesn't exist.",
              "signature": "(self, name: Union[bytes, str, memoryview])"
            },
            {
              "name": "__init__",
              "doc": " Initialize a new RedisCluster client.\n\n :param startup_nodes:\n     List of nodes from which initial bootstrapping can be done\n :param host:\n     Can be used to point to a startup node\n :param port:\n     Can be used to point to a startup node\n :param require_full_coverage:\n    When set to False (default value): the client will not require a\n    full coverage of the slots. However, if not all slots are covered,\n    and at least one node has 'cluster-require-full-coverage' set to\n    'yes,' the server will throw a ClusterDownError for some key-based\n    commands. See -\n    https://redis.io/topics/cluster-tutorial#redis-cluster-configuration-parameters\n    When set to True: all slots must be covered to construct the\n    cluster client. If not all slots are covered, RedisClusterException\n    will be thrown.\n:param read_from_replicas:\n     @deprecated - please use load_balancing_strategy instead\n     Enable read from replicas in READONLY mode. You can read possibly\n     stale data.\n     When set to true, read commands will be assigned between the\n     primary and its replications in a Round-Robin manner.\n:param load_balancing_strategy:\n     Enable read from replicas in READONLY mode and defines the load balancing\n     strategy that will be used for cluster node selection.\n     The data read from replicas is eventually consistent with the data in primary nodes.\n:param dynamic_startup_nodes:\n     Set the RedisCluster's startup nodes to all of the discovered nodes.\n     If true (default value), the cluster's discovered nodes will be used to\n     determine the cluster nodes-slots mapping in the next topology refresh.\n     It will remove the initial passed startup nodes if their endpoints aren't\n     listed in the CLUSTER SLOTS output.\n     If you use dynamic DNS endpoints for startup nodes but CLUSTER SLOTS lists\n     specific IP addresses, it is best to set it to false.\n:param cluster_error_retry_attempts:\n     @deprecated - Please configure the 'retry' object instead\n     In case 'retry' object is set - this argument is ignored!\n\n     Number of times to retry before raising an error when\n     :class:`~.TimeoutError` or :class:`~.ConnectionError`, :class:`~.SlotNotCoveredError` or\n     :class:`~.ClusterDownError` are encountered\n:param retry:\n    A retry object that defines the retry strategy and the number of\n    retries for the cluster client.\n    In current implementation for the cluster client (starting form redis-py version 6.0.0)\n    the retry object is not yet fully utilized, instead it is used just to determine\n    the number of retries for the cluster client.\n    In the future releases the retry object will be used to handle the cluster client retries!\n:param reinitialize_steps:\n    Specifies the number of MOVED errors that need to occur before\n    reinitializing the whole cluster topology. If a MOVED error occurs\n    and the cluster does not need to be reinitialized on this current\n    error handling, only the MOVED slot will be patched with the\n    redirected node.\n    To reinitialize the cluster on every MOVED error, set\n    reinitialize_steps to 1.\n    To avoid reinitializing the cluster on moved errors, set\n    reinitialize_steps to 0.\n:param address_remap:\n    An optional callable which, when provided with an internal network\n    address of a node, e.g. a `(host, port)` tuple, will return the address\n    where the node is reachable.  This can be used to map the addresses at\n    which the nodes _think_ they are, to addresses at which a client may\n    reach them, such as when they sit behind a proxy.\n\n :**kwargs:\n     Extra arguments that will be sent into Redis instance when created\n     (See Official redis-py doc for supported kwargs - the only limitation\n      is that you can't provide 'retry' object as part of kwargs.\n [https://github.com/andymccurdy/redis-py/blob/master/redis/client.py])\n     Some kwargs are not supported and will raise a\n     RedisClusterException:\n         - db (Redis do not support database SELECT in cluster mode)",
              "signature": "(self, host: Optional[str] = None, port: int = 6379, startup_nodes: Optional[List[ForwardRef('ClusterNode')]] = None, cluster_error_retry_attempts: int = 3, retry: Optional[ForwardRef('Retry')] = None, require_full_coverage: bool = True, reinitialize_steps: int = 5, read_from_replicas: bool = False, load_balancing_strategy: Optional[ForwardRef('LoadBalancingStrategy')] = None, dynamic_startup_nodes: bool = True, url: Optional[str] = None, address_remap: Optional[Callable[[Tuple[str, int]], Tuple[str, int]]] = None, cache: Optional[redis.cache.CacheInterface] = None, cache_config: Optional[redis.cache.CacheConfig] = None, event_dispatcher: Optional[redis.event.EventDispatcher] = None, **kwargs)"
            },
            {
              "name": "__setitem__",
              "doc": null,
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float])"
            },
            {
              "name": "_determine_nodes",
              "doc": null,
              "signature": "(self, *args, **kwargs) -> List[ForwardRef('ClusterNode')]"
            },
            {
              "name": "_eval",
              "doc": null,
              "signature": "(self, command: str, script: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "_evalsha",
              "doc": null,
              "signature": "(self, command: str, sha: str, numkeys: int, *keys_and_args: list) -> Union[Awaitable[str], str]"
            },
            {
              "name": "_execute_command",
              "doc": "Send a command to a node in the cluster",
              "signature": "(self, target_node, *args, **kwargs)"
            },
            {
              "name": "_execute_pipeline_by_slot",
              "doc": null,
              "signature": "(self, command: str, slots_to_args: Mapping[int, Iterable[Union[bytes, bytearray, memoryview, str, int, float]]]) -> List[Any]"
            },
            {
              "name": "_fcall",
              "doc": null,
              "signature": "(self, command: str, function, numkeys: int, *keys_and_args: Any) -> Union[Awaitable[str], str]"
            },
            {
              "name": "_georadiusgeneric",
              "doc": null,
              "signature": "(self, command: str, *args: Union[bytes, bytearray, memoryview, str, int, float], **kwargs: Union[bytes, bytearray, memoryview, str, int, float, NoneType]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "_geosearchgeneric",
              "doc": null,
              "signature": "(self, command: str, *args: Union[bytes, bytearray, memoryview, str, int, float], **kwargs: Union[bytes, bytearray, memoryview, str, int, float, NoneType]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "_get_command_keys",
              "doc": "Get the keys in the command. If the command has no keys in in, None is\nreturned.\n\nNOTE: Due to a bug in redis<7.0, this function does not work properly\nfor EVAL or EVALSHA when the `numkeys` arg is 0.\n - issue: https://github.com/redis/redis/issues/9493\n - fix: https://github.com/redis/redis/pull/9733\n\nSo, don't use this function with EVAL or EVALSHA.",
              "signature": "(self, *args)"
            },
            {
              "name": "_internal_execute_command",
              "doc": "Wrapper for ERRORS_ALLOW_RETRY error handling.\n\nIt will try the number of times specified by the retries property from\nconfig option \"self.retry\" which defaults to 3 unless manually\nconfigured.\n\nIf it reaches the number of times, the command will raise the exception\n\nKey argument :target_nodes: can be passed with the following types:\n    nodes_flag: PRIMARIES, REPLICAS, ALL_NODES, RANDOM\n    ClusterNode\n    list<ClusterNode>\n    dict<Any, ClusterNode>",
              "signature": "(self, *args, **kwargs)"
            },
            {
              "name": "_is_nodes_flag",
              "doc": null,
              "signature": "(self, target_nodes)"
            },
            {
              "name": "_parse_target_nodes",
              "doc": null,
              "signature": "(self, target_nodes)"
            },
            {
              "name": "_partition_keys_by_slot",
              "doc": "Split keys into a dictionary that maps a slot to a list of keys.",
              "signature": "(self, keys: Iterable[Union[bytes, str, memoryview]]) -> Dict[int, List[Union[bytes, str, memoryview]]]"
            },
            {
              "name": "_partition_pairs_by_slot",
              "doc": "Split pairs into a dictionary that maps a slot to a list of pairs.",
              "signature": "(self, mapping: Mapping[~AnyKeyT, Union[bytes, bytearray, memoryview, str, int, float]]) -> Dict[int, List[Union[bytes, bytearray, memoryview, str, int, float]]]"
            },
            {
              "name": "_process_result",
              "doc": "Process the result of the executed command.\nThe function would return a dict or a single value.\n\n:type command: str\n:type res: dict\n\n`res` should be in the following format:\n    Dict<node_name, command_result>",
              "signature": "(self, command, res, **kwargs)"
            },
            {
              "name": "_reorder_keys_by_command",
              "doc": null,
              "signature": "(self, keys: Iterable[Union[bytes, str, memoryview]], slots_to_args: Mapping[int, Iterable[Union[bytes, bytearray, memoryview, str, int, float]]], responses: Iterable[Any]) -> List[Any]"
            },
            {
              "name": "_should_reinitialized",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_split_command_across_slots",
              "doc": "Runs the given command once for the keys\nof each slot. Returns the sum of the return values.",
              "signature": "(self, command: str, *keys: Union[bytes, str, memoryview]) -> int"
            },
            {
              "name": "_zaggregate",
              "doc": null,
              "signature": "(self, command: str, dest: Union[bytes, str, memoryview, NoneType], keys: Union[Sequence[Union[bytes, str, memoryview]], Mapping[~AnyKeyT, float]], aggregate: Optional[str] = None, **options) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "_zrange",
              "doc": null,
              "signature": "(self, command, dest: Union[bytes, str, memoryview, NoneType], name: Union[bytes, str, memoryview], start: int, end: int, desc: bool = False, byscore: bool = False, bylex: bool = False, withscores: bool = False, score_cast_func: Union[type, Callable, NoneType] = <class 'float'>, offset: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_cat",
              "doc": "Returns a list of categories or commands within a category.\n\nIf ``category`` is not supplied, returns a list of all categories.\nIf ``category`` is supplied, returns a list of all commands within\nthat category.\n\nFor more information see https://redis.io/commands/acl-cat",
              "signature": "(self, category: Optional[str] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_deluser",
              "doc": "Delete the ACL for the specified ``username``\\s\n\nFor more information see https://redis.io/commands/acl-deluser",
              "signature": "(self, *username: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_dryrun",
              "doc": "Simulate the execution of a given command by a given ``username``.\n\nFor more information see https://redis.io/commands/acl-dryrun",
              "signature": "(self, username, *args, **kwargs)"
            },
            {
              "name": "acl_genpass",
              "doc": "Generate a random password value.\nIf ``bits`` is supplied then use this number of bits, rounded to\nthe next multiple of 4.\nSee: https://redis.io/commands/acl-genpass",
              "signature": "(self, bits: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_getuser",
              "doc": "Get the ACL details for the specified ``username``.\n\nIf ``username`` does not exist, return None\n\nFor more information see https://redis.io/commands/acl-getuser",
              "signature": "(self, username: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_help",
              "doc": "The ACL HELP command returns helpful text describing\nthe different subcommands.\n\nFor more information see https://redis.io/commands/acl-help",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_list",
              "doc": "Return a list of all ACLs on the server\n\nFor more information see https://redis.io/commands/acl-list",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_load",
              "doc": "Load ACL rules from the configured ``aclfile``.\n\nNote that the server must be configured with the ``aclfile``\ndirective to be able to load ACL rules from an aclfile.\n\nFor more information see https://redis.io/commands/acl-load",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_log",
              "doc": "Get ACL logs as a list.\n:param int count: Get logs[0:count].\n:rtype: List.\n\nFor more information see https://redis.io/commands/acl-log",
              "signature": "(self, count: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_log_reset",
              "doc": "Reset ACL logs.\n:rtype: Boolean.\n\nFor more information see https://redis.io/commands/acl-log",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_save",
              "doc": "Save ACL rules to the configured ``aclfile``.\n\nNote that the server must be configured with the ``aclfile``\ndirective to be able to save ACL rules to an aclfile.\n\nFor more information see https://redis.io/commands/acl-save",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_setuser",
              "doc": "Create or update an ACL user.\n\nCreate or update the ACL for `username`. If the user already exists,\nthe existing ACL is completely overwritten and replaced with the\nspecified values.\n\nFor more information, see https://redis.io/commands/acl-setuser\n\nArgs:\n    username: The name of the user whose ACL is to be created or updated.\n    enabled: Indicates whether the user should be allowed to authenticate.\n             Defaults to `False`.\n    nopass: Indicates whether the user can authenticate without a password.\n            This cannot be `True` if `passwords` are also specified.\n    passwords: A list of plain text passwords to add to or remove from the user.\n               Each password must be prefixed with a '+' to add or a '-' to\n               remove. For convenience, a single prefixed string can be used\n               when adding or removing a single password.\n    hashed_passwords: A list of SHA-256 hashed passwords to add to or remove\n                      from the user. Each hashed password must be prefixed with\n                      a '+' to add or a '-' to remove. For convenience, a single\n                      prefixed string can be used when adding or removing a\n                      single password.\n    categories: A list of strings representing category permissions. Each string\n                must be prefixed with either a '+' to add the category\n                permission or a '-' to remove the category permission.\n    commands: A list of strings representing command permissions. Each string\n              must be prefixed with either a '+' to add the command permission\n              or a '-' to remove the command permission.\n    keys: A list of key patterns to grant the user access to. Key patterns allow\n          ``'*'`` to support wildcard matching. For example, ``'*'`` grants\n          access to all keys while ``'cache:*'`` grants access to all keys that\n          are prefixed with ``cache:``.\n          `keys` should not be prefixed with a ``'~'``.\n    reset: Indicates whether the user should be fully reset prior to applying\n           the new ACL. Setting this to `True` will remove all existing\n           passwords, flags, and privileges from the user and then apply the\n           specified rules. If `False`, the user's existing passwords, flags,\n           and privileges will be kept and any new specified rules will be\n           applied on top.\n    reset_keys: Indicates whether the user's key permissions should be reset\n                prior to applying any new key permissions specified in `keys`.\n                If `False`, the user's existing key permissions will be kept and\n                any new specified key permissions will be applied on top.\n    reset_channels: Indicates whether the user's channel permissions should be\n                    reset prior to applying any new channel permissions\n                    specified in `channels`. If `False`, the user's existing\n                    channel permissions will be kept and any new specified\n                    channel permissions will be applied on top.\n    reset_passwords: Indicates whether to remove all existing passwords and the\n                     `nopass` flag from the user prior to applying any new\n                     passwords specified in `passwords` or `hashed_passwords`.\n                     If `False`, the user's existing passwords and `nopass`\n                     status will be kept and any new specified passwords or\n                     hashed passwords will be applied on top.",
              "signature": "(self, username: str, enabled: bool = False, nopass: bool = False, passwords: Union[str, Iterable[str], NoneType] = None, hashed_passwords: Union[str, Iterable[str], NoneType] = None, categories: Optional[Iterable[str]] = None, commands: Optional[Iterable[str]] = None, keys: Optional[Iterable[Union[bytes, str, memoryview]]] = None, channels: Optional[Iterable[Union[bytes, str, memoryview]]] = None, selectors: Optional[Iterable[Tuple[str, Union[bytes, str, memoryview]]]] = None, reset: bool = False, reset_keys: bool = False, reset_channels: bool = False, reset_passwords: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_users",
              "doc": "Returns a list of all registered users on the server.\n\nFor more information see https://redis.io/commands/acl-users",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_whoami",
              "doc": "Get the username for the current connection\n\nFor more information see https://redis.io/commands/acl-whoami",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "append",
              "doc": "Appends the string ``value`` to the value at ``key``. If ``key``\ndoesn't already exist, create it with a value of ``value``.\nReturns the new length of the value at ``key``.\n\nFor more information see https://redis.io/commands/append",
              "signature": "(self, key: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "auth",
              "doc": "Authenticates the user. If you do not pass username, Redis will try to\nauthenticate for the \"default\" user. If you do pass username, it will\nauthenticate for the given user.\nFor more information see https://redis.io/commands/auth",
              "signature": "(self, password: str, username: Optional[str] = None, **kwargs)"
            },
            {
              "name": "bf",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'BFBloom'"
            },
            {
              "name": "bgrewriteaof",
              "doc": "Tell the Redis server to rewrite the AOF file from data in memory.\n\nFor more information see https://redis.io/commands/bgrewriteaof",
              "signature": "(self, **kwargs)"
            },
            {
              "name": "bgsave",
              "doc": "Tell the Redis server to save its data to disk.  Unlike save(),\nthis method is asynchronous and returns immediately.\n\nFor more information see https://redis.io/commands/bgsave",
              "signature": "(self, schedule: bool = True, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bitcount",
              "doc": "Returns the count of set bits in the value of ``key``.  Optional\n``start`` and ``end`` parameters indicate which bytes to consider\n\nFor more information see https://redis.io/commands/bitcount",
              "signature": "(self, key: Union[bytes, str, memoryview], start: Optional[int] = None, end: Optional[int] = None, mode: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bitfield",
              "doc": "Return a BitFieldOperation instance to conveniently construct one or\nmore bitfield operations on ``key``.\n\nFor more information see https://redis.io/commands/bitfield",
              "signature": "(self: Union[ForwardRef('redis.client.Redis'), ForwardRef('redis.asyncio.client.Redis')], key: Union[bytes, str, memoryview], default_overflow: Optional[str] = None) -> redis.commands.core.BitFieldOperation"
            },
            {
              "name": "bitfield_ro",
              "doc": "Return an array of the specified bitfield values\nwhere the first value is found using ``encoding`` and ``offset``\nparameters and remaining values are result of corresponding\nencoding/offset pairs in optional list ``items``\nRead-only variant of the BITFIELD command.\n\nFor more information see https://redis.io/commands/bitfield_ro",
              "signature": "(self: Union[ForwardRef('redis.client.Redis'), ForwardRef('redis.asyncio.client.Redis')], key: Union[bytes, str, memoryview], encoding: str, offset: Union[int, str], items: Optional[list] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bitop",
              "doc": "Perform a bitwise operation using ``operation`` between ``keys`` and\nstore the result in ``dest``.\n\nFor more information see https://redis.io/commands/bitop",
              "signature": "(self, operation: str, dest: Union[bytes, str, memoryview], *keys: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bitpos",
              "doc": "Return the position of the first bit set to 1 or 0 in a string.\n``start`` and ``end`` defines search range. The range is interpreted\nas a range of bytes and not a range of bits, so start=0 and end=2\nmeans to look at the first three bytes.\n\nFor more information see https://redis.io/commands/bitpos",
              "signature": "(self, key: Union[bytes, str, memoryview], bit: int, start: Optional[int] = None, end: Optional[int] = None, mode: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "blmove",
              "doc": "Blocking version of lmove.\n\nFor more information see https://redis.io/commands/blmove",
              "signature": "(self, first_list: str, second_list: str, timeout: int, src: str = 'LEFT', dest: str = 'RIGHT') -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "blmpop",
              "doc": "Pop ``count`` values (default 1) from first non-empty in the list\nof provided key names.\n\nWhen all lists are empty this command blocks the connection until another\nclient pushes to it or until the timeout, timeout of 0 blocks indefinitely\n\nFor more information see https://redis.io/commands/blmpop",
              "signature": "(self, timeout: float, numkeys: int, *args: List[str], direction: str, count: Optional[int] = 1) -> Optional[list]"
            },
            {
              "name": "blpop",
              "doc": "LPOP a value off of the first non-empty list\nnamed in the ``keys`` list.\n\nIf none of the lists in ``keys`` has a value to LPOP, then block\nfor ``timeout`` seconds, or until a value gets pushed on to one\nof the lists.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/blpop",
              "signature": "(self, keys: List, timeout: Union[int, float, NoneType] = 0) -> Union[Awaitable[list], list]"
            },
            {
              "name": "brpop",
              "doc": "RPOP a value off of the first non-empty list\nnamed in the ``keys`` list.\n\nIf none of the lists in ``keys`` has a value to RPOP, then block\nfor ``timeout`` seconds, or until a value gets pushed on to one\nof the lists.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/brpop",
              "signature": "(self, keys: List, timeout: Union[int, float, NoneType] = 0) -> Union[Awaitable[list], list]"
            },
            {
              "name": "brpoplpush",
              "doc": "Pop a value off the tail of ``src``, push it on the head of ``dst``\nand then return it.\n\nThis command blocks until a value is in ``src`` or until ``timeout``\nseconds elapse, whichever is first. A ``timeout`` value of 0 blocks\nforever.\n\nFor more information see https://redis.io/commands/brpoplpush",
              "signature": "(self, src: str, dst: str, timeout: Union[int, float, NoneType] = 0) -> Union[Awaitable[Optional[str]], str, NoneType]"
            },
            {
              "name": "bzmpop",
              "doc": "Pop ``count`` values (default 1) off of the first non-empty sorted set\nnamed in the ``keys`` list.\n\nIf none of the sorted sets in ``keys`` has a value to pop,\nthen block for ``timeout`` seconds, or until a member gets added\nto one of the sorted sets.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/bzmpop",
              "signature": "(self, timeout: float, numkeys: int, keys: List[str], min: Optional[bool] = False, max: Optional[bool] = False, count: Optional[int] = 1) -> Optional[list]"
            },
            {
              "name": "bzpopmax",
              "doc": "ZPOPMAX a value off of the first non-empty sorted set\nnamed in the ``keys`` list.\n\nIf none of the sorted sets in ``keys`` has a value to ZPOPMAX,\nthen block for ``timeout`` seconds, or until a member gets added\nto one of the sorted sets.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/bzpopmax",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], timeout: Union[int, float, bytes, str, memoryview] = 0) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bzpopmin",
              "doc": "ZPOPMIN a value off of the first non-empty sorted set\nnamed in the ``keys`` list.\n\nIf none of the sorted sets in ``keys`` has a value to ZPOPMIN,\nthen block for ``timeout`` seconds, or until a member gets added\nto one of the sorted sets.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/bzpopmin",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], timeout: Union[int, float, bytes, str, memoryview] = 0) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cf",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'CFBloom'"
            },
            {
              "name": "client_getname",
              "doc": "Returns the current connection name\n\nFor more information see https://redis.io/commands/client-getname",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_getredir",
              "doc": "Returns the ID (an integer) of the client to whom we are\nredirecting tracking notifications.\n\nsee: https://redis.io/commands/client-getredir",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_id",
              "doc": "Returns the current connection id\n\nFor more information see https://redis.io/commands/client-id",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_info",
              "doc": "Returns information and statistics about the current\nclient connection.\n\nFor more information see https://redis.io/commands/client-info",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_kill",
              "doc": "Disconnects the client at ``address`` (ip:port)\n\nFor more information see https://redis.io/commands/client-kill",
              "signature": "(self, address: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_kill_filter",
              "doc": "Disconnects client(s) using a variety of filter options\n:param _id: Kills a client by its unique ID field\n:param _type: Kills a client by type where type is one of 'normal',\n'master', 'slave' or 'pubsub'\n:param addr: Kills a client by its 'address:port'\n:param skipme: If True, then the client calling the command\nwill not get killed even if it is identified by one of the filter\noptions. If skipme is not provided, the server defaults to skipme=True\n:param laddr: Kills a client by its 'local (bind) address:port'\n:param user: Kills a client for a specific user name\n:param maxage: Kills clients that are older than the specified age in seconds",
              "signature": "(self, _id: Optional[str] = None, _type: Optional[str] = None, addr: Optional[str] = None, skipme: Optional[bool] = None, laddr: Optional[bool] = None, user: Optional[str] = None, maxage: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_list",
              "doc": "Returns a list of currently connected clients.\nIf type of client specified, only that type will be returned.\n\n:param _type: optional. one of the client types (normal, master,\n replica, pubsub)\n:param client_id: optional. a list of client ids\n\nFor more information see https://redis.io/commands/client-list",
              "signature": "(self, _type: Optional[str] = None, client_id: List[Union[bytes, bytearray, memoryview, str, int, float]] = [], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_no_evict",
              "doc": "Sets the client eviction mode for the current connection.\n\nFor more information see https://redis.io/commands/client-no-evict",
              "signature": "(self, mode: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "client_no_touch",
              "doc": "# The command controls whether commands sent by the client will alter\n# the LRU/LFU of the keys they access.\n# When turned on, the current client will not change LFU/LRU stats,\n# unless it sends the TOUCH command.\n\nFor more information see https://redis.io/commands/client-no-touch",
              "signature": "(self, mode: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "client_pause",
              "doc": "Suspend all the Redis clients for the specified amount of time.\n\n\nFor more information see https://redis.io/commands/client-pause\n\nArgs:\n    timeout: milliseconds to pause clients\n    all: If true (default) all client commands are blocked.\n         otherwise, clients are only blocked if they attempt to execute\n         a write command.\n\nFor the WRITE mode, some commands have special behavior:\n\n* EVAL/EVALSHA: Will block client for all scripts.\n* PUBLISH: Will block client.\n* PFCOUNT: Will block client.\n* WAIT: Acknowledgments will be delayed, so this command will\n    appear blocked.",
              "signature": "(self, timeout: int, all: bool = True, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_reply",
              "doc": "Enable and disable redis server replies.\n\n``reply`` Must be ON OFF or SKIP,\nON - The default most with server replies to commands\nOFF - Disable server responses to commands\nSKIP - Skip the response of the immediately following command.\n\nNote: When setting OFF or SKIP replies, you will need a client object\nwith a timeout specified in seconds, and will need to catch the\nTimeoutError.\nThe test_client_reply unit test illustrates this, and\nconftest.py has a client with a timeout.\n\nSee https://redis.io/commands/client-reply",
              "signature": "(self, reply: Union[Literal['ON'], Literal['OFF'], Literal['SKIP']], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_setinfo",
              "doc": "Sets the current connection library name or version\nFor mor information see https://redis.io/commands/client-setinfo",
              "signature": "(self, attr: str, value: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_setname",
              "doc": "Sets the current connection name\n\nFor more information see https://redis.io/commands/client-setname\n\n.. note::\n   This method sets client name only for **current** connection.\n\n   If you want to set a common name for all connections managed\n   by this client, use ``client_name`` constructor argument.",
              "signature": "(self, name: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_tracking",
              "doc": "Enables the tracking feature of the Redis server, that is used\nfor server assisted client side caching.\n\n``on`` indicate for tracking on or tracking off. The dafualt is on.\n\n``clientid`` send invalidation messages to the connection with\nthe specified ID.\n\n``bcast`` enable tracking in broadcasting mode. In this mode\ninvalidation messages are reported for all the prefixes\nspecified, regardless of the keys requested by the connection.\n\n``optin``  when broadcasting is NOT active, normally don't track\nkeys in read only commands, unless they are called immediately\nafter a CLIENT CACHING yes command.\n\n``optout`` when broadcasting is NOT active, normally track keys in\nread only commands, unless they are called immediately after a\nCLIENT CACHING no command.\n\n``noloop`` don't send notifications about keys modified by this\nconnection itself.\n\n``prefix``  for broadcasting, register a given key prefix, so that\nnotifications will be provided only for keys starting with this string.\n\nSee https://redis.io/commands/client-tracking",
              "signature": "(self, on: bool = True, clientid: Optional[int] = None, prefix: Sequence[Union[bytes, str, memoryview]] = [], bcast: bool = False, optin: bool = False, optout: bool = False, noloop: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_tracking_off",
              "doc": "Turn off the tracking mode.\nFor more information about the options look at client_tracking func.\n\nSee https://redis.io/commands/client-tracking",
              "signature": "(self, clientid: Optional[int] = None, prefix: Sequence[Union[bytes, str, memoryview]] = [], bcast: bool = False, optin: bool = False, optout: bool = False, noloop: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_tracking_on",
              "doc": "Turn on the tracking mode.\nFor more information about the options look at client_tracking func.\n\nSee https://redis.io/commands/client-tracking",
              "signature": "(self, clientid: Optional[int] = None, prefix: Sequence[Union[bytes, str, memoryview]] = [], bcast: bool = False, optin: bool = False, optout: bool = False, noloop: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_trackinginfo",
              "doc": "Returns the information about the current client connection's\nuse of the server assisted client side cache.\n\nSee https://redis.io/commands/client-trackinginfo",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_unblock",
              "doc": "Unblocks a connection by its client id.\nIf ``error`` is True, unblocks the client with a special error message.\nIf ``error`` is False (default), the client is unblocked using the\nregular timeout mechanism.\n\nFor more information see https://redis.io/commands/client-unblock",
              "signature": "(self, client_id: int, error: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_unpause",
              "doc": "Unpause all redis clients\n\nFor more information see https://redis.io/commands/client-unpause",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "close",
              "doc": null,
              "signature": "(self) -> None"
            },
            {
              "name": "cluster_addslots",
              "doc": "Assign new hash slots to receiving node. Sends to specified node.\n\n:target_node: 'ClusterNode'\n    The node to execute the command on\n\nFor more information see https://redis.io/commands/cluster-addslots",
              "signature": "(self, target_node: 'TargetNodesT', *slots: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_addslotsrange",
              "doc": "Similar to the CLUSTER ADDSLOTS command.\nThe difference between the two commands is that ADDSLOTS takes a list of slots\nto assign to the node, while ADDSLOTSRANGE takes a list of slot ranges\n(specified by start and end slots) to assign to the node.\n\n:target_node: 'ClusterNode'\n    The node to execute the command on\n\nFor more information see https://redis.io/commands/cluster-addslotsrange",
              "signature": "(self, target_node: 'TargetNodesT', *slots: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_bumpepoch",
              "doc": null,
              "signature": "(self, target_nodes: Optional[ForwardRef('TargetNodesT')] = None) -> None"
            },
            {
              "name": "cluster_count_failure_report",
              "doc": "Return the number of failure reports active for a given node\nSends to a random node\n\nFor more information see https://redis.io/commands/cluster-count-failure-reports",
              "signature": "(self, node_id: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_countkeysinslot",
              "doc": "Return the number of local keys in the specified hash slot\nSend to node based on specified slot_id\n\nFor more information see https://redis.io/commands/cluster-countkeysinslot",
              "signature": "(self, slot_id: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_delslots",
              "doc": "Set hash slots as unbound in the cluster.\nIt determines by it self what node the slot is in and sends it there\n\nReturns a list of the results for each processed slot.\n\nFor more information see https://redis.io/commands/cluster-delslots",
              "signature": "(self, *slots: Union[bytes, bytearray, memoryview, str, int, float]) -> List[bool]"
            },
            {
              "name": "cluster_delslotsrange",
              "doc": "Similar to the CLUSTER DELSLOTS command.\nThe difference is that CLUSTER DELSLOTS takes a list of hash slots to remove\nfrom the node, while CLUSTER DELSLOTSRANGE takes a list of slot ranges to remove\nfrom the node.\n\nFor more information see https://redis.io/commands/cluster-delslotsrange",
              "signature": "(self, *slots: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_failover",
              "doc": "Forces a slave to perform a manual failover of its master\nSends to specified node\n\n:target_node: 'ClusterNode'\n    The node to execute the command on\n\nFor more information see https://redis.io/commands/cluster-failover",
              "signature": "(self, target_node: 'TargetNodesT', option: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_flushslots",
              "doc": null,
              "signature": "(self, target_nodes: Optional[ForwardRef('TargetNodesT')] = None) -> None"
            },
            {
              "name": "cluster_get_keys_in_slot",
              "doc": "Returns the number of keys in the specified cluster slot\n\nFor more information see https://redis.io/commands/cluster-getkeysinslot",
              "signature": "(self, slot: int, num_keys: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_info",
              "doc": "Provides info about Redis Cluster node state.\nThe command will be sent to a random node in the cluster if no target\nnode is specified.\n\nFor more information see https://redis.io/commands/cluster-info",
              "signature": "(self, target_nodes: Optional[ForwardRef('TargetNodesT')] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_keyslot",
              "doc": "Returns the hash slot of the specified key\nSends to random node in the cluster\n\nFor more information see https://redis.io/commands/cluster-keyslot",
              "signature": "(self, key: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_links",
              "doc": "Each node in a Redis Cluster maintains a pair of long-lived TCP link with each\npeer in the cluster: One for sending outbound messages towards the peer and one\nfor receiving inbound messages from the peer.\n\nThis command outputs information of all such peer links as an array.\n\nFor more information see https://redis.io/commands/cluster-links",
              "signature": "(self, target_node: 'TargetNodesT') -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_meet",
              "doc": "Force a node cluster to handshake with another node.\nSends to specified node.\n\nFor more information see https://redis.io/commands/cluster-meet",
              "signature": "(self, host: str, port: int, target_nodes: Optional[ForwardRef('TargetNodesT')] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_myid",
              "doc": "Returns the node's id.\n\n:target_node: 'ClusterNode'\n    The node to execute the command on\n\nFor more information check https://redis.io/commands/cluster-myid/",
              "signature": "(self, target_node: 'TargetNodesT') -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_myshardid",
              "doc": "Returns the shard ID of the node.\n\nFor more information see https://redis.io/commands/cluster-myshardid/",
              "signature": "(self, target_nodes=None)"
            },
            {
              "name": "cluster_nodes",
              "doc": "Get Cluster config for the node.\nSends to random node in the cluster\n\nFor more information see https://redis.io/commands/cluster-nodes",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_replicas",
              "doc": "Provides a list of replica nodes replicating from the specified primary\ntarget node.\n\nFor more information see https://redis.io/commands/cluster-replicas",
              "signature": "(self, node_id: str, target_nodes: Optional[ForwardRef('TargetNodesT')] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_replicate",
              "doc": "Reconfigure a node as a slave of the specified master node\n\nFor more information see https://redis.io/commands/cluster-replicate",
              "signature": "(self, target_nodes: 'TargetNodesT', node_id: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_reset",
              "doc": "Reset a Redis Cluster node\n\nIf 'soft' is True then it will send 'SOFT' argument\nIf 'soft' is False then it will send 'HARD' argument\n\nFor more information see https://redis.io/commands/cluster-reset",
              "signature": "(self, soft: bool = True, target_nodes: Optional[ForwardRef('TargetNodesT')] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_save_config",
              "doc": "Forces the node to save cluster state on disk\n\nFor more information see https://redis.io/commands/cluster-saveconfig",
              "signature": "(self, target_nodes: Optional[ForwardRef('TargetNodesT')] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_set_config_epoch",
              "doc": "Set the configuration epoch in a new node\n\nFor more information see https://redis.io/commands/cluster-set-config-epoch",
              "signature": "(self, epoch: int, target_nodes: Optional[ForwardRef('TargetNodesT')] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_setslot",
              "doc": "Bind an hash slot to a specific node\n\n:target_node: 'ClusterNode'\n    The node to execute the command on\n\nFor more information see https://redis.io/commands/cluster-setslot",
              "signature": "(self, target_node: 'TargetNodesT', node_id: str, slot_id: int, state: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_setslot_stable",
              "doc": "Clears migrating / importing state from the slot.\nIt determines by it self what node the slot is in and sends it there.\n\nFor more information see https://redis.io/commands/cluster-setslot",
              "signature": "(self, slot_id: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cluster_shards",
              "doc": "Returns details about the shards of the cluster.\n\nFor more information see https://redis.io/commands/cluster-shards",
              "signature": "(self, target_nodes=None)"
            },
            {
              "name": "cluster_slots",
              "doc": "Get array of Cluster slot to node mappings\n\nFor more information see https://redis.io/commands/cluster-slots",
              "signature": "(self, target_nodes: Optional[ForwardRef('TargetNodesT')] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cms",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'CMSBloom'"
            },
            {
              "name": "command",
              "doc": "Returns dict reply of details about all Redis commands.\n\nFor more information see https://redis.io/commands/command",
              "signature": "(self, **kwargs)"
            },
            {
              "name": "command_count",
              "doc": null,
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "command_docs",
              "doc": "This function throws a NotImplementedError since it is intentionally\nnot supported.",
              "signature": "(self, *args)"
            },
            {
              "name": "command_getkeys",
              "doc": null,
              "signature": "(self, *args) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "command_getkeysandflags",
              "doc": "Returns array of keys from a full Redis command and their usage flags.\n\nFor more information see https://redis.io/commands/command-getkeysandflags",
              "signature": "(self, *args: List[str]) -> List[Union[str, List[str]]]"
            },
            {
              "name": "command_info",
              "doc": null,
              "signature": "(self, **kwargs) -> None"
            },
            {
              "name": "command_list",
              "doc": "Return an array of the server's command names.\nYou can use one of the following filters:\n``module``: get the commands that belong to the module\n``category``: get the commands in the ACL category\n``pattern``: get the commands that match the given pattern\n\nFor more information see https://redis.io/commands/command-list/",
              "signature": "(self, module: Optional[str] = None, category: Optional[str] = None, pattern: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "config_get",
              "doc": "Return a dictionary of configuration based on the ``pattern``\n\nFor more information see https://redis.io/commands/config-get",
              "signature": "(self, pattern: Union[bytes, str, memoryview] = '*', *args: List[Union[bytes, str, memoryview]], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "config_resetstat",
              "doc": "Reset runtime statistics\n\nFor more information see https://redis.io/commands/config-resetstat",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "config_rewrite",
              "doc": "Rewrite config file with the minimal change to reflect running config.\n\nFor more information see https://redis.io/commands/config-rewrite",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "config_set",
              "doc": "Set config item ``name`` with ``value``\n\nFor more information see https://redis.io/commands/config-set",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float], *args: List[Union[bytes, bytearray, memoryview, str, int, float]], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "copy",
              "doc": "Copy the value stored in the ``source`` key to the ``destination`` key.\n\n``destination_db`` an alternative destination database. By default,\nthe ``destination`` key is created in the source Redis database.\n\n``replace`` whether the ``destination`` key should be removed before\ncopying the value to it. By default, the value is not copied if\nthe ``destination`` key already exists.\n\nFor more information see https://redis.io/commands/copy",
              "signature": "(self, source: str, destination: str, destination_db: Optional[str] = None, replace: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "dbsize",
              "doc": "Returns the number of keys in the current database\n\nFor more information see https://redis.io/commands/dbsize",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "debug_object",
              "doc": "Returns version specific meta information about a given key\n\nFor more information see https://redis.io/commands/debug-object",
              "signature": "(self, key: Union[bytes, str, memoryview], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "debug_segfault",
              "doc": null,
              "signature": "(self, **kwargs) -> None"
            },
            {
              "name": "decr",
              "doc": "Decrements the value of ``key`` by ``amount``.  If no key exists,\nthe value will be initialized as 0 - ``amount``\n\nFor more information see https://redis.io/commands/decrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: int = 1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "decrby",
              "doc": "Decrements the value of ``key`` by ``amount``.  If no key exists,\nthe value will be initialized as 0 - ``amount``\n\nFor more information see https://redis.io/commands/decrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: int = 1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "delete",
              "doc": "Deletes the given keys in the cluster.\nThe keys are first split up into slots\nand then an DEL command is sent for every slot\n\nNon-existent keys are ignored.\nReturns the number of keys that were deleted.\n\nFor more information see https://redis.io/commands/del",
              "signature": "(self, *keys: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "determine_slot",
              "doc": "Figure out what slot to use based on args.\n\nRaises a RedisClusterException if there's a missing key and we can't\n    determine what slots to map the command to; or, if the keys don't\n    all map to the same key slot.",
              "signature": "(self, *args) -> int"
            },
            {
              "name": "disconnect_connection_pools",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "dump",
              "doc": "Return a serialized version of the value stored at the specified key.\nIf key does not exist a nil bulk reply is returned.\n\nFor more information see https://redis.io/commands/dump",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "echo",
              "doc": "Echo the string back from the server\n\nFor more information see https://redis.io/commands/echo",
              "signature": "(self, value: Union[bytes, bytearray, memoryview, str, int, float], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "eval",
              "doc": "Execute the Lua ``script``, specifying the ``numkeys`` the script\nwill touch and the key names and argument values in ``keys_and_args``.\nReturns the result of the script.\n\nIn practice, use the object returned by ``register_script``. This\nfunction exists purely for Redis API completion.\n\nFor more information see  https://redis.io/commands/eval",
              "signature": "(self, script: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "eval_ro",
              "doc": "The read-only variant of the EVAL command\n\nExecute the read-only Lua ``script`` specifying the ``numkeys`` the script\nwill touch and the key names and argument values in ``keys_and_args``.\nReturns the result of the script.\n\nFor more information see  https://redis.io/commands/eval_ro",
              "signature": "(self, script: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "evalsha",
              "doc": "Use the ``sha`` to execute a Lua script already registered via EVAL\nor SCRIPT LOAD. Specify the ``numkeys`` the script will touch and the\nkey names and argument values in ``keys_and_args``. Returns the result\nof the script.\n\nIn practice, use the object returned by ``register_script``. This\nfunction exists purely for Redis API completion.\n\nFor more information see  https://redis.io/commands/evalsha",
              "signature": "(self, sha: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "evalsha_ro",
              "doc": "The read-only variant of the EVALSHA command\n\nUse the ``sha`` to execute a read-only Lua script already registered via EVAL\nor SCRIPT LOAD. Specify the ``numkeys`` the script will touch and the\nkey names and argument values in ``keys_and_args``. Returns the result\nof the script.\n\nFor more information see  https://redis.io/commands/evalsha_ro",
              "signature": "(self, sha: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "execute_command",
              "doc": null,
              "signature": "(self, *args, **kwargs)"
            },
            {
              "name": "exists",
              "doc": "Returns the number of ``names`` that exist in the\nwhole cluster. The keys are first split up into slots\nand then an EXISTS command is sent for every slot\n\nFor more information see https://redis.io/commands/exists",
              "signature": "(self, *keys: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "expire",
              "doc": "Set an expire flag on key ``name`` for ``time`` seconds with given\n``option``. ``time`` can be represented by an integer or a Python timedelta\nobject.\n\nValid options are:\n    NX -> Set expiry only when the key has no expiry\n    XX -> Set expiry only when the key has an existing expiry\n    GT -> Set expiry only when the new expiry is greater than current one\n    LT -> Set expiry only when the new expiry is less than current one\n\nFor more information see https://redis.io/commands/expire",
              "signature": "(self, name: Union[bytes, str, memoryview], time: Union[int, datetime.timedelta], nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "expireat",
              "doc": "Set an expire flag on key ``name`` with given ``option``. ``when``\ncan be represented as an integer indicating unix time or a Python\ndatetime object.\n\nValid options are:\n    -> NX -- Set expiry only when the key has no expiry\n    -> XX -- Set expiry only when the key has an existing expiry\n    -> GT -- Set expiry only when the new expiry is greater than current one\n    -> LT -- Set expiry only when the new expiry is less than current one\n\nFor more information see https://redis.io/commands/expireat",
              "signature": "(self, name: Union[bytes, str, memoryview], when: Union[int, datetime.datetime], nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "expiretime",
              "doc": "Returns the absolute Unix timestamp (since January 1, 1970) in seconds\nat which the given key will expire.\n\nFor more information see https://redis.io/commands/expiretime",
              "signature": "(self, key: str) -> int"
            },
            {
              "name": "failover",
              "doc": "This function throws a NotImplementedError since it is intentionally\nnot supported.",
              "signature": "(self)"
            },
            {
              "name": "fcall",
              "doc": "Invoke a function.\n\nFor more information see https://redis.io/commands/fcall",
              "signature": "(self, function, numkeys: int, *keys_and_args: Any) -> Union[Awaitable[str], str]"
            },
            {
              "name": "fcall_ro",
              "doc": "This is a read-only variant of the FCALL command that cannot\nexecute commands that modify data.\n\nFor more information see https://redis.io/commands/fcall_ro",
              "signature": "(self, function, numkeys: int, *keys_and_args: Any) -> Union[Awaitable[str], str]"
            },
            {
              "name": "flushall",
              "doc": "Delete all keys in all databases on the current host.\n\n``asynchronous`` indicates whether the operation is\nexecuted asynchronously by the server.\n\nFor more information see https://redis.io/commands/flushall",
              "signature": "(self, asynchronous: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "flushdb",
              "doc": "Delete all keys in the current database.\n\n``asynchronous`` indicates whether the operation is\nexecuted asynchronously by the server.\n\nFor more information see https://redis.io/commands/flushdb",
              "signature": "(self, asynchronous: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "ft",
              "doc": "Access the search namespace, providing support for redis search.",
              "signature": "(self, index_name='idx') -> 'Search'"
            },
            {
              "name": "function_delete",
              "doc": "Delete the library called ``library`` and all its functions.\n\nFor more information see https://redis.io/commands/function-delete",
              "signature": "(self, library: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_dump",
              "doc": "Return the serialized payload of loaded libraries.\n\nFor more information see https://redis.io/commands/function-dump",
              "signature": "(self) -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_flush",
              "doc": "Deletes all the libraries.\n\nFor more information see https://redis.io/commands/function-flush",
              "signature": "(self, mode: str = 'SYNC') -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_kill",
              "doc": "Kill a function that is currently executing.\n\nFor more information see https://redis.io/commands/function-kill",
              "signature": "(self) -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_list",
              "doc": "Return information about the functions and libraries.\n\nArgs:\n\n    library: specify a pattern for matching library names\n    withcode: cause the server to include the libraries source implementation\n        in the reply",
              "signature": "(self, library: Optional[str] = '*', withcode: Optional[bool] = False) -> Union[Awaitable[List], List]"
            },
            {
              "name": "function_load",
              "doc": "Load a library to Redis.\n:param code: the source code (must start with\nShebang statement that provides a metadata about the library)\n:param replace: changes the behavior to overwrite the existing library\nwith the new contents.\nReturn the library name that was loaded.\n\nFor more information see https://redis.io/commands/function-load",
              "signature": "(self, code: str, replace: Optional[bool] = False) -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_restore",
              "doc": "Restore libraries from the serialized ``payload``.\nYou can use the optional policy argument to provide a policy\nfor handling existing libraries.\n\nFor more information see https://redis.io/commands/function-restore",
              "signature": "(self, payload: str, policy: Optional[str] = 'APPEND') -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_stats",
              "doc": "Return information about the function that's currently running\nand information about the available execution engines.\n\nFor more information see https://redis.io/commands/function-stats",
              "signature": "(self) -> Union[Awaitable[List], List]"
            },
            {
              "name": "geoadd",
              "doc": "Add the specified geospatial items to the specified key identified\nby the ``name`` argument. The Geospatial items are given as ordered\nmembers of the ``values`` argument, each item or place is formed by\nthe triad longitude, latitude and name.\n\nNote: You can use ZREM to remove elements.\n\n``nx`` forces ZADD to only create new elements and not to update\nscores for elements that already exist.\n\n``xx`` forces ZADD to only update scores of elements that already\nexist. New elements will not be added.\n\n``ch`` modifies the return value to be the numbers of elements changed.\nChanged elements include new elements that were added and elements\nwhose scores changed.\n\nFor more information see https://redis.io/commands/geoadd",
              "signature": "(self, name: Union[bytes, str, memoryview], values: Sequence[Union[bytes, bytearray, memoryview, str, int, float]], nx: bool = False, xx: bool = False, ch: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geodist",
              "doc": "Return the distance between ``place1`` and ``place2`` members of the\n``name`` key.\nThe units must be one of the following : m, km mi, ft. By default\nmeters are used.\n\nFor more information see https://redis.io/commands/geodist",
              "signature": "(self, name: Union[bytes, str, memoryview], place1: Union[bytes, bytearray, memoryview, str, int, float], place2: Union[bytes, bytearray, memoryview, str, int, float], unit: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geohash",
              "doc": "Return the geo hash string for each item of ``values`` members of\nthe specified key identified by the ``name`` argument.\n\nFor more information see https://redis.io/commands/geohash",
              "signature": "(self, name: Union[bytes, str, memoryview], *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geopos",
              "doc": "Return the positions of each item of ``values`` as members of\nthe specified key identified by the ``name`` argument. Each position\nis represented by the pairs lon and lat.\n\nFor more information see https://redis.io/commands/geopos",
              "signature": "(self, name: Union[bytes, str, memoryview], *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "georadius",
              "doc": "Return the members of the specified key identified by the\n``name`` argument which are within the borders of the area specified\nwith the ``latitude`` and ``longitude`` location and the maximum\ndistance from the center specified by the ``radius`` value.\n\nThe units must be one of the following : m, km mi, ft. By default\n\n``withdist`` indicates to return the distances of each place.\n\n``withcoord`` indicates to return the latitude and longitude of\neach place.\n\n``withhash`` indicates to return the geohash string of each place.\n\n``count`` indicates to return the number of elements up to N.\n\n``sort`` indicates to return the places in a sorted way, ASC for\nnearest to fairest and DESC for fairest to nearest.\n\n``store`` indicates to save the places names in a sorted set named\nwith a specific key, each element of the destination sorted set is\npopulated with the score got from the original geo sorted set.\n\n``store_dist`` indicates to save the places names in a sorted set\nnamed with a specific key, instead of ``store`` the sorted set\ndestination score is set with the distance.\n\nFor more information see https://redis.io/commands/georadius",
              "signature": "(self, name: Union[bytes, str, memoryview], longitude: float, latitude: float, radius: float, unit: Optional[str] = None, withdist: bool = False, withcoord: bool = False, withhash: bool = False, count: Optional[int] = None, sort: Optional[str] = None, store: Union[bytes, str, memoryview, NoneType] = None, store_dist: Union[bytes, str, memoryview, NoneType] = None, any: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "georadiusbymember",
              "doc": "This command is exactly like ``georadius`` with the sole difference\nthat instead of taking, as the center of the area to query, a longitude\nand latitude value, it takes the name of a member already existing\ninside the geospatial index represented by the sorted set.\n\nFor more information see https://redis.io/commands/georadiusbymember",
              "signature": "(self, name: Union[bytes, str, memoryview], member: Union[bytes, bytearray, memoryview, str, int, float], radius: float, unit: Optional[str] = None, withdist: bool = False, withcoord: bool = False, withhash: bool = False, count: Optional[int] = None, sort: Optional[str] = None, store: Union[bytes, str, memoryview, NoneType] = None, store_dist: Union[bytes, str, memoryview, NoneType] = None, any: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geosearch",
              "doc": "Return the members of specified key identified by the\n``name`` argument, which are within the borders of the\narea specified by a given shape. This command extends the\nGEORADIUS command, so in addition to searching within circular\nareas, it supports searching within rectangular areas.\n\nThis command should be used in place of the deprecated\nGEORADIUS and GEORADIUSBYMEMBER commands.\n\n``member`` Use the position of the given existing\n member in the sorted set. Can't be given with ``longitude``\n and ``latitude``.\n\n``longitude`` and ``latitude`` Use the position given by\nthis coordinates. Can't be given with ``member``\n``radius`` Similar to GEORADIUS, search inside circular\narea according the given radius. Can't be given with\n``height`` and ``width``.\n``height`` and ``width`` Search inside an axis-aligned\nrectangle, determined by the given height and width.\nCan't be given with ``radius``\n\n``unit`` must be one of the following : m, km, mi, ft.\n`m` for meters (the default value), `km` for kilometers,\n`mi` for miles and `ft` for feet.\n\n``sort`` indicates to return the places in a sorted way,\nASC for nearest to furthest and DESC for furthest to nearest.\n\n``count`` limit the results to the first count matching items.\n\n``any`` is set to True, the command will return as soon as\nenough matches are found. Can't be provided without ``count``\n\n``withdist`` indicates to return the distances of each place.\n``withcoord`` indicates to return the latitude and longitude of\neach place.\n\n``withhash`` indicates to return the geohash string of each place.\n\nFor more information see https://redis.io/commands/geosearch",
              "signature": "(self, name: Union[bytes, str, memoryview], member: Union[bytes, bytearray, memoryview, str, int, float, NoneType] = None, longitude: Optional[float] = None, latitude: Optional[float] = None, unit: str = 'm', radius: Optional[float] = None, width: Optional[float] = None, height: Optional[float] = None, sort: Optional[str] = None, count: Optional[int] = None, any: bool = False, withcoord: bool = False, withdist: bool = False, withhash: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geosearchstore",
              "doc": "This command is like GEOSEARCH, but stores the result in\n``dest``. By default, it stores the results in the destination\nsorted set with their geospatial information.\nif ``store_dist`` set to True, the command will stores the\nitems in a sorted set populated with their distance from the\ncenter of the circle or box, as a floating-point number.\n\nFor more information see https://redis.io/commands/geosearchstore",
              "signature": "(self, dest: Union[bytes, str, memoryview], name: Union[bytes, str, memoryview], member: Union[bytes, bytearray, memoryview, str, int, float, NoneType] = None, longitude: Optional[float] = None, latitude: Optional[float] = None, unit: str = 'm', radius: Optional[float] = None, width: Optional[float] = None, height: Optional[float] = None, sort: Optional[str] = None, count: Optional[int] = None, any: bool = False, storedist: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "get",
              "doc": "Return the value at key ``name``, or None if the key doesn't exist\n\nFor more information see https://redis.io/commands/get",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "get_connection_kwargs",
              "doc": "Get the connections' key-word arguments",
              "signature": "(self)"
            },
            {
              "name": "get_default_node",
              "doc": "Get the cluster's default node",
              "signature": "(self)"
            },
            {
              "name": "get_encoder",
              "doc": "Get the connections' encoder",
              "signature": "(self)"
            },
            {
              "name": "get_node",
              "doc": null,
              "signature": "(self, host=None, port=None, node_name=None)"
            },
            {
              "name": "get_node_from_key",
              "doc": "Get the node that holds the key's slot.\nIf replica set to True but the slot doesn't have any replicas, None is\nreturned.",
              "signature": "(self, key, replica=False)"
            },
            {
              "name": "get_nodes",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "get_primaries",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "get_random_node",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "get_redis_connection",
              "doc": null,
              "signature": "(self, node: 'ClusterNode') -> redis.client.Redis"
            },
            {
              "name": "get_replicas",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "getbit",
              "doc": "Returns an integer indicating the value of ``offset`` in ``name``\n\nFor more information see https://redis.io/commands/getbit",
              "signature": "(self, name: Union[bytes, str, memoryview], offset: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "getdel",
              "doc": "Get the value at key ``name`` and delete the key. This command\nis similar to GET, except for the fact that it also deletes\nthe key on success (if and only if the key's value type\nis a string).\n\nFor more information see https://redis.io/commands/getdel",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "getex",
              "doc": "Get the value of key and optionally set its expiration.\nGETEX is similar to GET, but is a write command with\nadditional options. All time parameters can be given as\ndatetime.timedelta or integers.\n\n``ex`` sets an expire flag on key ``name`` for ``ex`` seconds.\n\n``px`` sets an expire flag on key ``name`` for ``px`` milliseconds.\n\n``exat`` sets an expire flag on key ``name`` for ``ex`` seconds,\nspecified in unix time.\n\n``pxat`` sets an expire flag on key ``name`` for ``ex`` milliseconds,\nspecified in unix time.\n\n``persist`` remove the time to live associated with ``name``.\n\nFor more information see https://redis.io/commands/getex",
              "signature": "(self, name: Union[bytes, str, memoryview], ex: Union[int, datetime.timedelta, NoneType] = None, px: Union[int, datetime.timedelta, NoneType] = None, exat: Union[int, datetime.datetime, NoneType] = None, pxat: Union[int, datetime.datetime, NoneType] = None, persist: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "getrange",
              "doc": "Returns the substring of the string value stored at ``key``,\ndetermined by the offsets ``start`` and ``end`` (both are inclusive)\n\nFor more information see https://redis.io/commands/getrange",
              "signature": "(self, key: Union[bytes, str, memoryview], start: int, end: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "getset",
              "doc": "Sets the value at key ``name`` to ``value``\nand returns the old value at key ``name`` atomically.\n\nAs per Redis 6.2, GETSET is considered deprecated.\nPlease use SET with GET parameter in new code.\n\nFor more information see https://redis.io/commands/getset",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hdel",
              "doc": "Delete ``keys`` from hash ``name``\n\nFor more information see https://redis.io/commands/hdel",
              "signature": "(self, name: str, *keys: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hello",
              "doc": "This function throws a NotImplementedError since it is intentionally\nnot supported.",
              "signature": "(self)"
            },
            {
              "name": "hexists",
              "doc": "Returns a boolean indicating if ``key`` exists within hash ``name``\n\nFor more information see https://redis.io/commands/hexists",
              "signature": "(self, name: str, key: str) -> Union[Awaitable[bool], bool]"
            },
            {
              "name": "hexpire",
              "doc": "Sets or updates the expiration time for fields within a hash key, using relative\ntime in seconds.\n\nIf a field already has an expiration time, the behavior of the update can be\ncontrolled using the `nx`, `xx`, `gt`, and `lt` parameters.\n\nThe return value provides detailed information about the outcome for each field.\n\nFor more information, see https://redis.io/commands/hexpire\n\nArgs:\n    name: The name of the hash key.\n    seconds: Expiration time in seconds, relative. Can be an integer, or a\n             Python `timedelta` object.\n    fields: List of fields within the hash to apply the expiration time to.\n    nx: Set expiry only when the field has no expiry.\n    xx: Set expiry only when the field has an existing expiry.\n    gt: Set expiry only when the new expiry is greater than the current one.\n    lt: Set expiry only when the new expiry is less than the current one.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `0` if the specified NX | XX | GT | LT condition was not met.\n        - `1` if the expiration time was set or updated.\n        - `2` if the field was deleted because the specified expiration time is\n          in the past.",
              "signature": "(self, name: Union[bytes, str, memoryview], seconds: Union[int, datetime.timedelta], *fields: str, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hexpireat",
              "doc": "Sets or updates the expiration time for fields within a hash key, using an\nabsolute Unix timestamp in seconds.\n\nIf a field already has an expiration time, the behavior of the update can be\ncontrolled using the `nx`, `xx`, `gt`, and `lt` parameters.\n\nThe return value provides detailed information about the outcome for each field.\n\nFor more information, see https://redis.io/commands/hexpireat\n\nArgs:\n    name: The name of the hash key.\n    unix_time_seconds: Expiration time as Unix timestamp in seconds. Can be an\n                       integer or a Python `datetime` object.\n    fields: List of fields within the hash to apply the expiration time to.\n    nx: Set expiry only when the field has no expiry.\n    xx: Set expiry only when the field has an existing expiration time.\n    gt: Set expiry only when the new expiry is greater than the current one.\n    lt: Set expiry only when the new expiry is less than the current one.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `0` if the specified NX | XX | GT | LT condition was not met.\n        - `1` if the expiration time was set or updated.\n        - `2` if the field was deleted because the specified expiration time is\n          in the past.",
              "signature": "(self, name: Union[bytes, str, memoryview], unix_time_seconds: Union[int, datetime.datetime], *fields: str, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hexpiretime",
              "doc": "Returns the expiration times of hash fields as Unix timestamps in seconds.\n\nFor more information, see https://redis.io/commands/hexpiretime\n\nArgs:\n    key: The hash key.\n    fields: A list of fields within the hash for which to get the expiration\n            time.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expire time.\n        - A positive integer representing the expiration Unix timestamp in\n          seconds, if the field has an associated expiration time.",
              "signature": "(self, key: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hget",
              "doc": "Return the value of ``key`` within the hash ``name``\n\nFor more information see https://redis.io/commands/hget",
              "signature": "(self, name: str, key: str) -> Union[Awaitable[Optional[str]], str, NoneType]"
            },
            {
              "name": "hgetall",
              "doc": "Return a Python dict of the hash's name/value pairs\n\nFor more information see https://redis.io/commands/hgetall",
              "signature": "(self, name: str) -> Union[Awaitable[dict], dict]"
            },
            {
              "name": "hgetdel",
              "doc": "Return the value of ``key`` within the hash ``name`` and\ndelete the field in the hash.\nThis command is similar to HGET, except for the fact that it also deletes\nthe key on success from the hash with the provided ```name```.\n\nAvailable since Redis 8.0\nFor more information see https://redis.io/commands/hgetdel",
              "signature": "(self, name: str, *keys: str) -> Union[Awaitable[Optional[List[Union[str, bytes]]]], List[Union[str, bytes]], NoneType]"
            },
            {
              "name": "hgetex",
              "doc": "Return the values of ``key`` and ``keys`` within the hash ``name``\nand optionally set their expiration.\n\n``ex`` sets an expire flag on ``kyes`` for ``ex`` seconds.\n\n``px`` sets an expire flag on ``keys`` for ``px`` milliseconds.\n\n``exat`` sets an expire flag on ``keys`` for ``ex`` seconds,\nspecified in unix time.\n\n``pxat`` sets an expire flag on ``keys`` for ``ex`` milliseconds,\nspecified in unix time.\n\n``persist`` remove the time to live associated with the ``keys``.\n\nAvailable since Redis 8.0\nFor more information see https://redis.io/commands/hgetex",
              "signature": "(self, name: Union[bytes, str, memoryview], *keys: str, ex: Union[int, datetime.timedelta, NoneType] = None, px: Union[int, datetime.timedelta, NoneType] = None, exat: Union[int, datetime.datetime, NoneType] = None, pxat: Union[int, datetime.datetime, NoneType] = None, persist: bool = False) -> Union[Awaitable[Optional[List[Union[str, bytes]]]], List[Union[str, bytes]], NoneType]"
            },
            {
              "name": "hincrby",
              "doc": "Increment the value of ``key`` in hash ``name`` by ``amount``\n\nFor more information see https://redis.io/commands/hincrby",
              "signature": "(self, name: str, key: str, amount: int = 1) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hincrbyfloat",
              "doc": "Increment the value of ``key`` in hash ``name`` by floating ``amount``\n\nFor more information see https://redis.io/commands/hincrbyfloat",
              "signature": "(self, name: str, key: str, amount: float = 1.0) -> Union[Awaitable[float], float]"
            },
            {
              "name": "hkeys",
              "doc": "Return the list of keys within hash ``name``\n\nFor more information see https://redis.io/commands/hkeys",
              "signature": "(self, name: str) -> Union[Awaitable[List], List]"
            },
            {
              "name": "hlen",
              "doc": "Return the number of elements in hash ``name``\n\nFor more information see https://redis.io/commands/hlen",
              "signature": "(self, name: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hmget",
              "doc": "Returns a list of values ordered identically to ``keys``\n\nFor more information see https://redis.io/commands/hmget",
              "signature": "(self, name: str, keys: List, *args: List) -> Union[Awaitable[List], List]"
            },
            {
              "name": "hmset",
              "doc": "Set key to value within hash ``name`` for each corresponding\nkey and value from the ``mapping`` dict.\n\nFor more information see https://redis.io/commands/hmset",
              "signature": "(self, name: str, mapping: dict) -> Union[Awaitable[str], str]"
            },
            {
              "name": "hpersist",
              "doc": "Removes the expiration time for each specified field in a hash.\n\nFor more information, see https://redis.io/commands/hpersist\n\nArgs:\n    name: The name of the hash key.\n    fields: A list of fields within the hash from which to remove the\n            expiration time.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expiration time.\n        - `1` if the expiration time was successfully removed from the field.",
              "signature": "(self, name: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hpexpire",
              "doc": "Sets or updates the expiration time for fields within a hash key, using relative\ntime in milliseconds.\n\nIf a field already has an expiration time, the behavior of the update can be\ncontrolled using the `nx`, `xx`, `gt`, and `lt` parameters.\n\nThe return value provides detailed information about the outcome for each field.\n\nFor more information, see https://redis.io/commands/hpexpire\n\nArgs:\n    name: The name of the hash key.\n    milliseconds: Expiration time in milliseconds, relative. Can be an integer,\n                  or a Python `timedelta` object.\n    fields: List of fields within the hash to apply the expiration time to.\n    nx: Set expiry only when the field has no expiry.\n    xx: Set expiry only when the field has an existing expiry.\n    gt: Set expiry only when the new expiry is greater than the current one.\n    lt: Set expiry only when the new expiry is less than the current one.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `0` if the specified NX | XX | GT | LT condition was not met.\n        - `1` if the expiration time was set or updated.\n        - `2` if the field was deleted because the specified expiration time is\n          in the past.",
              "signature": "(self, name: Union[bytes, str, memoryview], milliseconds: Union[int, datetime.timedelta], *fields: str, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hpexpireat",
              "doc": "Sets or updates the expiration time for fields within a hash key, using an\nabsolute Unix timestamp in milliseconds.\n\nIf a field already has an expiration time, the behavior of the update can be\ncontrolled using the `nx`, `xx`, `gt`, and `lt` parameters.\n\nThe return value provides detailed information about the outcome for each field.\n\nFor more information, see https://redis.io/commands/hpexpireat\n\nArgs:\n    name: The name of the hash key.\n    unix_time_milliseconds: Expiration time as Unix timestamp in milliseconds.\n                            Can be an integer or a Python `datetime` object.\n    fields: List of fields within the hash to apply the expiry.\n    nx: Set expiry only when the field has no expiry.\n    xx: Set expiry only when the field has an existing expiry.\n    gt: Set expiry only when the new expiry is greater than the current one.\n    lt: Set expiry only when the new expiry is less than the current one.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `0` if the specified NX | XX | GT | LT condition was not met.\n        - `1` if the expiration time was set or updated.\n        - `2` if the field was deleted because the specified expiration time is\n          in the past.",
              "signature": "(self, name: Union[bytes, str, memoryview], unix_time_milliseconds: Union[int, datetime.datetime], *fields: str, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hpexpiretime",
              "doc": "Returns the expiration times of hash fields as Unix timestamps in milliseconds.\n\nFor more information, see https://redis.io/commands/hpexpiretime\n\nArgs:\n    key: The hash key.\n    fields: A list of fields within the hash for which to get the expiration\n            time.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expire time.\n        - A positive integer representing the expiration Unix timestamp in\n          milliseconds, if the field has an associated expiration time.",
              "signature": "(self, key: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hpttl",
              "doc": "Returns the TTL (Time To Live) in milliseconds for each specified field within a\nhash key.\n\nFor more information, see https://redis.io/commands/hpttl\n\nArgs:\n    key: The hash key.\n    fields: A list of fields within the hash for which to get the TTL.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expire time.\n        - A positive integer representing the TTL in milliseconds if the field\n          has an associated expiration time.",
              "signature": "(self, key: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hrandfield",
              "doc": "Return a random field from the hash value stored at key.\n\ncount: if the argument is positive, return an array of distinct fields.\nIf called with a negative count, the behavior changes and the command\nis allowed to return the same field multiple times. In this case,\nthe number of returned fields is the absolute value of the\nspecified count.\nwithvalues: The optional WITHVALUES modifier changes the reply so it\nincludes the respective values of the randomly selected hash fields.\n\nFor more information see https://redis.io/commands/hrandfield",
              "signature": "(self, key: str, count: Optional[int] = None, withvalues: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hscan",
              "doc": "Incrementally return key/value slices in a hash. Also return a cursor\nindicating the scan position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\n``no_values`` indicates to return only the keys, without values.\n\nFor more information see https://redis.io/commands/hscan",
              "signature": "(self, name: Union[bytes, str, memoryview], cursor: int = 0, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, no_values: Optional[bool] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hscan_iter",
              "doc": "Make an iterator using the HSCAN command so that the client doesn't\nneed to remember the cursor position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\n``no_values`` indicates to return only the keys, without values",
              "signature": "(self, name: str, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, no_values: Optional[bool] = None) -> Iterator"
            },
            {
              "name": "hset",
              "doc": "Set ``key`` to ``value`` within hash ``name``,\n``mapping`` accepts a dict of key/value pairs that will be\nadded to hash ``name``.\n``items`` accepts a list of key/value pairs that will be\nadded to hash ``name``.\nReturns the number of fields that were added.\n\nFor more information see https://redis.io/commands/hset",
              "signature": "(self, name: str, key: Optional[str] = None, value: Optional[str] = None, mapping: Optional[dict] = None, items: Optional[list] = None) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hsetex",
              "doc": "Set ``key`` to ``value`` within hash ``name``\n\n``mapping`` accepts a dict of key/value pairs that will be\nadded to hash ``name``.\n\n``items`` accepts a list of key/value pairs that will be\nadded to hash ``name``.\n\n``ex`` sets an expire flag on ``keys`` for ``ex`` seconds.\n\n``px`` sets an expire flag on ``keys`` for ``px`` milliseconds.\n\n``exat`` sets an expire flag on ``keys`` for ``ex`` seconds,\n    specified in unix time.\n\n``pxat`` sets an expire flag on ``keys`` for ``ex`` milliseconds,\n    specified in unix time.\n\n``data_persist_option`` can be set to ``FNX`` or ``FXX`` to control the\n    behavior of the command.\n    ``FNX`` will set the value for each provided key to each\n        provided value only if all do not already exist.\n    ``FXX`` will set the value for each provided key to each\n        provided value only if all already exist.\n\n``keepttl`` if True, retain the time to live associated with the keys.\n\nReturns the number of fields that were added.\n\nAvailable since Redis 8.0\nFor more information see https://redis.io/commands/hsetex",
              "signature": "(self, name: str, key: Optional[str] = None, value: Optional[str] = None, mapping: Optional[dict] = None, items: Optional[list] = None, ex: Union[int, datetime.timedelta, NoneType] = None, px: Union[int, datetime.timedelta, NoneType] = None, exat: Union[int, datetime.datetime, NoneType] = None, pxat: Union[int, datetime.datetime, NoneType] = None, data_persist_option: Optional[redis.commands.core.HashDataPersistOptions] = None, keepttl: bool = False) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hsetnx",
              "doc": "Set ``key`` to ``value`` within hash ``name`` if ``key`` does not\nexist.  Returns 1 if HSETNX created a field, otherwise 0.\n\nFor more information see https://redis.io/commands/hsetnx",
              "signature": "(self, name: str, key: str, value: str) -> Union[Awaitable[bool], bool]"
            },
            {
              "name": "hstrlen",
              "doc": "Return the number of bytes stored in the value of ``key``\nwithin hash ``name``\n\nFor more information see https://redis.io/commands/hstrlen",
              "signature": "(self, name: str, key: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "httl",
              "doc": "Returns the TTL (Time To Live) in seconds for each specified field within a hash\nkey.\n\nFor more information, see https://redis.io/commands/httl\n\nArgs:\n    key: The hash key.\n    fields: A list of fields within the hash for which to get the TTL.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expire time.\n        - A positive integer representing the TTL in seconds if the field has\n          an associated expiration time.",
              "signature": "(self, key: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hvals",
              "doc": "Return the list of values within hash ``name``\n\nFor more information see https://redis.io/commands/hvals",
              "signature": "(self, name: str) -> Union[Awaitable[List], List]"
            },
            {
              "name": "incr",
              "doc": "Increments the value of ``key`` by ``amount``.  If no key exists,\nthe value will be initialized as ``amount``\n\nFor more information see https://redis.io/commands/incrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: int = 1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "incrby",
              "doc": "Increments the value of ``key`` by ``amount``.  If no key exists,\nthe value will be initialized as ``amount``\n\nFor more information see https://redis.io/commands/incrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: int = 1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "incrbyfloat",
              "doc": "Increments the value at key ``name`` by floating ``amount``.\nIf no key exists, the value will be initialized as ``amount``\n\nFor more information see https://redis.io/commands/incrbyfloat",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: float = 1.0) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "info",
              "doc": "Returns a dictionary containing information about the Redis server\n\nThe ``section`` option can be used to select a specific section\nof information\n\nThe section option is not supported by older versions of Redis Server,\nand will generate ResponseError\n\nFor more information see https://redis.io/commands/info",
              "signature": "(self, section: Optional[str] = None, *args: List[str], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "json",
              "doc": "Access the json namespace, providing support for redis json.",
              "signature": "(self, encoder=<json.encoder.JSONEncoder object at 0x0000023EF6E34C90>, decoder=<json.decoder.JSONDecoder object at 0x0000023EF6E34B90>) -> 'JSON'"
            },
            {
              "name": "keys",
              "doc": "Returns a list of keys matching ``pattern``\n\nFor more information see https://redis.io/commands/keys",
              "signature": "(self, pattern: Union[bytes, str, memoryview] = '*', **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "keyslot",
              "doc": "Calculate keyslot for a given key.\nSee Keys distribution model in https://redis.io/topics/cluster-spec",
              "signature": "(self, key)"
            },
            {
              "name": "lastsave",
              "doc": "Return a Python datetime object representing the last time the\nRedis database was saved to disk\n\nFor more information see https://redis.io/commands/lastsave",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "latency_doctor",
              "doc": "Raise a NotImplementedError, as the client will not support LATENCY DOCTOR.\nThis funcion is best used within the redis-cli.\n\nFor more information see https://redis.io/commands/latency-doctor",
              "signature": "(self)"
            },
            {
              "name": "latency_graph",
              "doc": "Raise a NotImplementedError, as the client will not support LATENCY GRAPH.\nThis funcion is best used within the redis-cli.\n\nFor more information see https://redis.io/commands/latency-graph.",
              "signature": "(self)"
            },
            {
              "name": "latency_histogram",
              "doc": "This function throws a NotImplementedError since it is intentionally\nnot supported.",
              "signature": "(self, *args)"
            },
            {
              "name": "latency_history",
              "doc": "Returns the raw data of the ``event``'s latency spikes time series.\n\nFor more information see https://redis.io/commands/latency-history",
              "signature": "(self, event: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "latency_latest",
              "doc": "Reports the latest latency events logged.\n\nFor more information see https://redis.io/commands/latency-latest",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "latency_reset",
              "doc": "Resets the latency spikes time series of all, or only some, events.\n\nFor more information see https://redis.io/commands/latency-reset",
              "signature": "(self, *events: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "lcs",
              "doc": "Find the longest common subsequence between ``key1`` and ``key2``.\nIf ``len`` is true the length of the match will will be returned.\nIf ``idx`` is true the match position in each strings will be returned.\n``minmatchlen`` restrict the list of matches to the ones of\nthe given ``minmatchlen``.\nIf ``withmatchlen`` the length of the match also will be returned.\nFor more information see https://redis.io/commands/lcs",
              "signature": "(self, key1: str, key2: str, len: Optional[bool] = False, idx: Optional[bool] = False, minmatchlen: Optional[int] = 0, withmatchlen: Optional[bool] = False) -> Union[str, int, list]"
            },
            {
              "name": "lindex",
              "doc": "Return the item from list ``name`` at position ``index``\n\nNegative indexes are supported and will return an item at the\nend of the list\n\nFor more information see https://redis.io/commands/lindex",
              "signature": "(self, name: str, index: int) -> Union[Awaitable[Optional[str]], str, NoneType]"
            },
            {
              "name": "linsert",
              "doc": "Insert ``value`` in list ``name`` either immediately before or after\n[``where``] ``refvalue``\n\nReturns the new length of the list on success or -1 if ``refvalue``\nis not in the list.\n\nFor more information see https://redis.io/commands/linsert",
              "signature": "(self, name: str, where: str, refvalue: str, value: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "llen",
              "doc": "Return the length of the list ``name``\n\nFor more information see https://redis.io/commands/llen",
              "signature": "(self, name: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "lmove",
              "doc": "Atomically returns and removes the first/last element of a list,\npushing it as the first/last element on the destination list.\nReturns the element being popped and pushed.\n\nFor more information see https://redis.io/commands/lmove",
              "signature": "(self, first_list: str, second_list: str, src: str = 'LEFT', dest: str = 'RIGHT') -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "lmpop",
              "doc": "Pop ``count`` values (default 1) first non-empty list key from the list\nof args provided key names.\n\nFor more information see https://redis.io/commands/lmpop",
              "signature": "(self, num_keys: int, *args: List[str], direction: str, count: Optional[int] = 1) -> Union[Awaitable[list], list]"
            },
            {
              "name": "load_external_module",
              "doc": "This function can be used to add externally defined redis modules,\nand their namespaces to the redis client.\n\n``funcname`` - A string containing the name of the function to create\n``func`` - The function, being added to this class.",
              "signature": "(self, funcname, func)"
            },
            {
              "name": "lock",
              "doc": "Return a new Lock object using key ``name`` that mimics\nthe behavior of threading.Lock.\n\nIf specified, ``timeout`` indicates a maximum life for the lock.\nBy default, it will remain locked until release() is called.\n\n``sleep`` indicates the amount of time to sleep per loop iteration\nwhen the lock is in blocking mode and another client is currently\nholding the lock.\n\n``blocking`` indicates whether calling ``acquire`` should block until\nthe lock has been acquired or to fail immediately, causing ``acquire``\nto return False and the lock not being acquired. Defaults to True.\nNote this value can be overridden by passing a ``blocking``\nargument to ``acquire``.\n\n``blocking_timeout`` indicates the maximum amount of time in seconds to\nspend trying to acquire the lock. A value of ``None`` indicates\ncontinue trying forever. ``blocking_timeout`` can be specified as a\nfloat or integer, both representing the number of seconds to wait.\n\n``lock_class`` forces the specified lock implementation. Note that as\nof redis-py 3.0, the only lock class we implement is ``Lock`` (which is\na Lua-based lock). So, it's unlikely you'll need this parameter, unless\nyou have created your own custom lock class.\n\n``thread_local`` indicates whether the lock token is placed in\nthread-local storage. By default, the token is placed in thread local\nstorage so that a thread only sees its token, not a token set by\nanother thread. Consider the following timeline:\n\n    time: 0, thread-1 acquires `my-lock`, with a timeout of 5 seconds.\n             thread-1 sets the token to \"abc\"\n    time: 1, thread-2 blocks trying to acquire `my-lock` using the\n             Lock instance.\n    time: 5, thread-1 has not yet completed. redis expires the lock\n             key.\n    time: 5, thread-2 acquired `my-lock` now that it's available.\n             thread-2 sets the token to \"xyz\"\n    time: 6, thread-1 finishes its work and calls release(). if the\n             token is *not* stored in thread local storage, then\n             thread-1 would see the token value as \"xyz\" and would be\n             able to successfully release the thread-2's lock.\n\n``raise_on_release_error`` indicates whether to raise an exception when\nthe lock is no longer owned when exiting the context manager. By default,\nthis is True, meaning an exception will be raised. If False, the warning\nwill be logged and the exception will be suppressed.\n\nIn some use cases it's necessary to disable thread local storage. For\nexample, if you have code where one thread acquires a lock and passes\nthat lock instance to a worker thread to release later. If thread\nlocal storage isn't disabled in this case, the worker thread won't see\nthe token set by the thread that acquired the lock. Our assumption\nis that these cases aren't common and as such default to using\nthread local storage.",
              "signature": "(self, name, timeout=None, sleep=0.1, blocking=True, blocking_timeout=None, lock_class=None, thread_local=True, raise_on_release_error: bool = True)"
            },
            {
              "name": "lolwut",
              "doc": "Get the Redis version and a piece of generative computer art\n\nSee: https://redis.io/commands/lolwut",
              "signature": "(self, *version_numbers: Union[str, float], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "lpop",
              "doc": "Removes and returns the first elements of the list ``name``.\n\nBy default, the command pops a single element from the beginning of\nthe list. When provided with the optional ``count`` argument, the reply\nwill consist of up to count elements, depending on the list's length.\n\nFor more information see https://redis.io/commands/lpop",
              "signature": "(self, name: str, count: Optional[int] = None) -> Union[Awaitable[Union[str, List, NoneType]], str, List, NoneType]"
            },
            {
              "name": "lpos",
              "doc": "Get position of ``value`` within the list ``name``\n\n If specified, ``rank`` indicates the \"rank\" of the first element to\n return in case there are multiple copies of ``value`` in the list.\n By default, LPOS returns the position of the first occurrence of\n ``value`` in the list. When ``rank`` 2, LPOS returns the position of\n the second ``value`` in the list. If ``rank`` is negative, LPOS\n searches the list in reverse. For example, -1 would return the\n position of the last occurrence of ``value`` and -2 would return the\n position of the next to last occurrence of ``value``.\n\n If specified, ``count`` indicates that LPOS should return a list of\n up to ``count`` positions. A ``count`` of 2 would return a list of\n up to 2 positions. A ``count`` of 0 returns a list of all positions\n matching ``value``. When ``count`` is specified and but ``value``\n does not exist in the list, an empty list is returned.\n\n If specified, ``maxlen`` indicates the maximum number of list\n elements to scan. A ``maxlen`` of 1000 will only return the\n position(s) of items within the first 1000 entries in the list.\n A ``maxlen`` of 0 (the default) will scan the entire list.\n\n For more information see https://redis.io/commands/lpos",
              "signature": "(self, name: str, value: str, rank: Optional[int] = None, count: Optional[int] = None, maxlen: Optional[int] = None) -> Union[str, List, NoneType]"
            },
            {
              "name": "lpush",
              "doc": "Push ``values`` onto the head of the list ``name``\n\nFor more information see https://redis.io/commands/lpush",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "lpushx",
              "doc": "Push ``value`` onto the head of the list ``name`` if ``name`` exists\n\nFor more information see https://redis.io/commands/lpushx",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "lrange",
              "doc": "Return a slice of the list ``name`` between\nposition ``start`` and ``end``\n\n``start`` and ``end`` can be negative numbers just like\nPython slicing notation\n\nFor more information see https://redis.io/commands/lrange",
              "signature": "(self, name: str, start: int, end: int) -> Union[Awaitable[list], list]"
            },
            {
              "name": "lrem",
              "doc": "Remove the first ``count`` occurrences of elements equal to ``value``\nfrom the list stored at ``name``.\n\nThe count argument influences the operation in the following ways:\n    count > 0: Remove elements equal to value moving from head to tail.\n    count < 0: Remove elements equal to value moving from tail to head.\n    count = 0: Remove all elements equal to value.\n\n    For more information see https://redis.io/commands/lrem",
              "signature": "(self, name: str, count: int, value: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "lset",
              "doc": "Set element at ``index`` of list ``name`` to ``value``\n\nFor more information see https://redis.io/commands/lset",
              "signature": "(self, name: str, index: int, value: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "ltrim",
              "doc": "Trim the list ``name``, removing all values not within the slice\nbetween ``start`` and ``end``\n\n``start`` and ``end`` can be negative numbers just like\nPython slicing notation\n\nFor more information see https://redis.io/commands/ltrim",
              "signature": "(self, name: str, start: int, end: int) -> Union[Awaitable[str], str]"
            },
            {
              "name": "memory_doctor",
              "doc": null,
              "signature": "(self, **kwargs) -> None"
            },
            {
              "name": "memory_help",
              "doc": null,
              "signature": "(self, **kwargs) -> None"
            },
            {
              "name": "memory_malloc_stats",
              "doc": "Return an internal statistics report from the memory allocator.\n\nSee: https://redis.io/commands/memory-malloc-stats",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "memory_purge",
              "doc": "Attempts to purge dirty pages for reclamation by allocator\n\nFor more information see https://redis.io/commands/memory-purge",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "memory_stats",
              "doc": "Return a dictionary of memory stats\n\nFor more information see https://redis.io/commands/memory-stats",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "memory_usage",
              "doc": "Return the total memory usage for key, its value and associated\nadministrative overheads.\n\nFor nested data structures, ``samples`` is the number of elements to\nsample. If left unspecified, the server's default is 5. Use 0 to sample\nall elements.\n\nFor more information see https://redis.io/commands/memory-usage",
              "signature": "(self, key: Union[bytes, str, memoryview], samples: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "mget",
              "doc": "Returns a list of values ordered identically to ``keys``\n\nFor more information see https://redis.io/commands/mget",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], *args: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "mget_nonatomic",
              "doc": "Splits the keys into different slots and then calls MGET\nfor the keys of every slot. This operation will not be atomic\nif keys belong to more than one slot.\n\nReturns a list of values ordered identically to ``keys``\n\nFor more information see https://redis.io/commands/mget",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], *args: Union[bytes, str, memoryview]) -> List[Optional[Any]]"
            },
            {
              "name": "migrate",
              "doc": "Migrate 1 or more keys from the current Redis server to a different\nserver specified by the ``host``, ``port`` and ``destination_db``.\n\nThe ``timeout``, specified in milliseconds, indicates the maximum\ntime the connection between the two servers can be idle before the\ncommand is interrupted.\n\nIf ``copy`` is True, the specified ``keys`` are NOT deleted from\nthe source server.\n\nIf ``replace`` is True, this operation will overwrite the keys\non the destination server if they exist.\n\nIf ``auth`` is specified, authenticate to the destination server with\nthe password provided.\n\nFor more information see https://redis.io/commands/migrate",
              "signature": "(self, host: str, port: int, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], destination_db: int, timeout: int, copy: bool = False, replace: bool = False, auth: Optional[str] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "module_list",
              "doc": "Returns a list of dictionaries containing the name and version of\nall loaded modules.\n\nFor more information see https://redis.io/commands/module-list",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "module_load",
              "doc": "Loads the module from ``path``.\nPasses all ``*args`` to the module, during loading.\nRaises ``ModuleError`` if a module is not found at ``path``.\n\nFor more information see https://redis.io/commands/module-load",
              "signature": "(self, path, *args) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "module_loadex",
              "doc": "Loads a module from a dynamic library at runtime with configuration directives.\n\nFor more information see https://redis.io/commands/module-loadex",
              "signature": "(self, path: str, options: Optional[List[str]] = None, args: Optional[List[str]] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "module_unload",
              "doc": "Unloads the module ``name``.\nRaises ``ModuleError`` if ``name`` is not in loaded modules.\n\nFor more information see https://redis.io/commands/module-unload",
              "signature": "(self, name) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "monitor",
              "doc": "Returns a Monitor object for the specified target node.\nThe default cluster node will be selected if no target node was\nspecified.\nMonitor is useful for handling the MONITOR command to the redis server.\nnext_command() method returns one command from monitor\nlisten() method yields commands from monitor.",
              "signature": "(self, target_node=None)"
            },
            {
              "name": "move",
              "doc": "Moves the key ``name`` to a different Redis database ``db``\n\nFor more information see https://redis.io/commands/move",
              "signature": "(self, name: Union[bytes, str, memoryview], db: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "mset",
              "doc": "Sets key/values based on a mapping. Mapping is a dictionary of\nkey/value pairs. Both keys and values should be strings or types that\ncan be cast to a string via str().\n\nFor more information see https://redis.io/commands/mset",
              "signature": "(self, mapping: Mapping[~AnyKeyT, Union[bytes, bytearray, memoryview, str, int, float]]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "mset_nonatomic",
              "doc": "Sets key/values based on a mapping. Mapping is a dictionary of\nkey/value pairs. Both keys and values should be strings or types that\ncan be cast to a string via str().\n\nSplits the keys into different slots and then calls MSET\nfor the keys of every slot. This operation will not be atomic\nif keys belong to more than one slot.\n\nFor more information see https://redis.io/commands/mset",
              "signature": "(self, mapping: Mapping[~AnyKeyT, Union[bytes, bytearray, memoryview, str, int, float]]) -> List[bool]"
            },
            {
              "name": "msetnx",
              "doc": "Sets key/values based on a mapping if none of the keys are already set.\nMapping is a dictionary of key/value pairs. Both keys and values\nshould be strings or types that can be cast to a string via str().\nReturns a boolean indicating if the operation was successful.\n\nFor more information see https://redis.io/commands/msetnx",
              "signature": "(self, mapping: Mapping[~AnyKeyT, Union[bytes, bytearray, memoryview, str, int, float]]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "object",
              "doc": "Return the encoding, idletime, or refcount about the key",
              "signature": "(self, infotype: str, key: Union[bytes, str, memoryview], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "on_connect",
              "doc": "Initialize the connection, authenticate and select a database and send\n READONLY if it is set during object initialization.",
              "signature": "(self, connection)"
            },
            {
              "name": "persist",
              "doc": "Removes an expiration on ``name``\n\nFor more information see https://redis.io/commands/persist",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pexpire",
              "doc": "Set an expire flag on key ``name`` for ``time`` milliseconds\nwith given ``option``. ``time`` can be represented by an\ninteger or a Python timedelta object.\n\nValid options are:\n    NX -> Set expiry only when the key has no expiry\n    XX -> Set expiry only when the key has an existing expiry\n    GT -> Set expiry only when the new expiry is greater than current one\n    LT -> Set expiry only when the new expiry is less than current one\n\nFor more information see https://redis.io/commands/pexpire",
              "signature": "(self, name: Union[bytes, str, memoryview], time: Union[int, datetime.timedelta], nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pexpireat",
              "doc": "Set an expire flag on key ``name`` with given ``option``. ``when``\ncan be represented as an integer representing unix time in\nmilliseconds (unix time * 1000) or a Python datetime object.\n\nValid options are:\n    NX -> Set expiry only when the key has no expiry\n    XX -> Set expiry only when the key has an existing expiry\n    GT -> Set expiry only when the new expiry is greater than current one\n    LT -> Set expiry only when the new expiry is less than current one\n\nFor more information see https://redis.io/commands/pexpireat",
              "signature": "(self, name: Union[bytes, str, memoryview], when: Union[int, datetime.datetime], nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pexpiretime",
              "doc": "Returns the absolute Unix timestamp (since January 1, 1970) in milliseconds\nat which the given key will expire.\n\nFor more information see https://redis.io/commands/pexpiretime",
              "signature": "(self, key: str) -> int"
            },
            {
              "name": "pfadd",
              "doc": "Adds the specified elements to the specified HyperLogLog.\n\nFor more information see https://redis.io/commands/pfadd",
              "signature": "(self, name: Union[bytes, str, memoryview], *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pfcount",
              "doc": "Return the approximated cardinality of\nthe set observed by the HyperLogLog at key(s).\n\nFor more information see https://redis.io/commands/pfcount",
              "signature": "(self, *sources: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pfmerge",
              "doc": "Merge N different HyperLogLogs into a single one.\n\nFor more information see https://redis.io/commands/pfmerge",
              "signature": "(self, dest: Union[bytes, str, memoryview], *sources: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "ping",
              "doc": "Ping the Redis server\n\nFor more information see https://redis.io/commands/ping",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pipeline",
              "doc": "Cluster impl:\n    Pipelines do not work in cluster mode the same way they\n    do in normal mode. Create a clone of this object so\n    that simulating pipelines will work correctly. Each\n    command will be called directly when used and\n    when calling execute() will only return the result stack.",
              "signature": "(self, transaction=None, shard_hint=None)"
            },
            {
              "name": "psetex",
              "doc": "Set the value of key ``name`` to ``value`` that expires in ``time_ms``\nmilliseconds. ``time_ms`` can be represented by an integer or a Python\ntimedelta object\n\nFor more information see https://redis.io/commands/psetex",
              "signature": "(self, name: Union[bytes, str, memoryview], time_ms: Union[int, datetime.timedelta], value: Union[bytes, bytearray, memoryview, str, int, float])"
            },
            {
              "name": "psync",
              "doc": "Initiates a replication stream from the master.\nNewer version for `sync`.\n\nFor more information see https://redis.io/commands/sync",
              "signature": "(self, replicationid: str, offset: int)"
            },
            {
              "name": "pttl",
              "doc": "Returns the number of milliseconds until the key ``name`` will expire\n\nFor more information see https://redis.io/commands/pttl",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "publish",
              "doc": "Publish ``message`` on ``channel``.\nReturns the number of subscribers the message was delivered to.\n\nFor more information see https://redis.io/commands/publish",
              "signature": "(self, channel: Union[bytes, str, memoryview], message: Union[bytes, bytearray, memoryview, str, int, float], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub",
              "doc": "Allows passing a ClusterNode, or host&port, to get a pubsub instance\nconnected to the specified node",
              "signature": "(self, node=None, host=None, port=None, **kwargs)"
            },
            {
              "name": "pubsub_channels",
              "doc": "Return a list of channels that have at least one subscriber\n\nFor more information see https://redis.io/commands/pubsub-channels",
              "signature": "(self, pattern: Union[bytes, str, memoryview] = '*', **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub_numpat",
              "doc": "Returns the number of subscriptions to patterns\n\nFor more information see https://redis.io/commands/pubsub-numpat",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub_numsub",
              "doc": "Return a list of (channel, number of subscribers) tuples\nfor each channel given in ``*args``\n\nFor more information see https://redis.io/commands/pubsub-numsub",
              "signature": "(self, *args: Union[bytes, str, memoryview], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub_shardchannels",
              "doc": "Return a list of shard_channels that have at least one subscriber\n\nFor more information see https://redis.io/commands/pubsub-shardchannels",
              "signature": "(self, pattern: Union[bytes, str, memoryview] = '*', **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub_shardnumsub",
              "doc": "Return a list of (shard_channel, number of subscribers) tuples\nfor each channel given in ``*args``\n\nFor more information see https://redis.io/commands/pubsub-shardnumsub",
              "signature": "(self, *args: Union[bytes, str, memoryview], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "quit",
              "doc": "Ask the server to close the connection.\n\nFor more information see https://redis.io/commands/quit",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "randomkey",
              "doc": "Returns the name of a random key\n\nFor more information see https://redis.io/commands/randomkey",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "readonly",
              "doc": "Enables read queries.\nThe command will be sent to the default cluster node if target_nodes is\nnot specified.\n\nFor more information see https://redis.io/commands/readonly",
              "signature": "(self, target_nodes: Optional[ForwardRef('TargetNodesT')] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "readwrite",
              "doc": "Disables read queries.\nThe command will be sent to the default cluster node if target_nodes is\nnot specified.\n\nFor more information see https://redis.io/commands/readwrite",
              "signature": "(self, target_nodes: Optional[ForwardRef('TargetNodesT')] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "register_script",
              "doc": "Register a Lua ``script`` specifying the ``keys`` it will touch.\nReturns a Script object that is callable and hides the complexity of\ndeal with scripts, keys, and shas. This is the preferred way to work\nwith Lua scripts.",
              "signature": "(self: 'redis.client.Redis', script: Union[bytes, str, memoryview]) -> redis.commands.core.Script"
            },
            {
              "name": "rename",
              "doc": "Rename key ``src`` to ``dst``\n\nFor more information see https://redis.io/commands/rename",
              "signature": "(self, src: Union[bytes, str, memoryview], dst: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "renamenx",
              "doc": "Rename key ``src`` to ``dst`` if ``dst`` doesn't already exist\n\nFor more information see https://redis.io/commands/renamenx",
              "signature": "(self, src: Union[bytes, str, memoryview], dst: Union[bytes, str, memoryview])"
            },
            {
              "name": "replace_default_node",
              "doc": "Replace the default cluster node.\nA random cluster node will be chosen if target_node isn't passed, and primaries\nwill be prioritized. The default node will not be changed if there are no other\nnodes in the cluster.\n\nArgs:\n    target_node (ClusterNode, optional): Target node to replace the default\n    node. Defaults to None.",
              "signature": "(self, target_node: 'ClusterNode' = None) -> None"
            },
            {
              "name": "replicaof",
              "doc": "Make the server a replica of another instance, or promote it as master.\n\nFor more information see https://redis.io/commands/replicaof",
              "signature": "(self, *args, **kwargs) -> NoReturn"
            },
            {
              "name": "reset",
              "doc": "Perform a full reset on the connection's server side contenxt.\n\nSee: https://redis.io/commands/reset",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "restore",
              "doc": "Create a key using the provided serialized value, previously obtained\nusing DUMP.\n\n``replace`` allows an existing key on ``name`` to be overridden. If\nit's not specified an error is raised on collision.\n\n``absttl`` if True, specified ``ttl`` should represent an absolute Unix\ntimestamp in milliseconds in which the key will expire. (Redis 5.0 or\ngreater).\n\n``idletime`` Used for eviction, this is the number of seconds the\nkey must be idle, prior to execution.\n\n``frequency`` Used for eviction, this is the frequency counter of\nthe object stored at the key, prior to execution.\n\nFor more information see https://redis.io/commands/restore",
              "signature": "(self, name: Union[bytes, str, memoryview], ttl: float, value: Union[bytes, bytearray, memoryview, str, int, float], replace: bool = False, absttl: bool = False, idletime: Optional[int] = None, frequency: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "role",
              "doc": "Provide information on the role of a Redis instance in\nthe context of replication, by returning if the instance\nis currently a master, slave, or sentinel.\n\nFor more information see https://redis.io/commands/role",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "rpop",
              "doc": "Removes and returns the last elements of the list ``name``.\n\nBy default, the command pops a single element from the end of the list.\nWhen provided with the optional ``count`` argument, the reply will\nconsist of up to count elements, depending on the list's length.\n\nFor more information see https://redis.io/commands/rpop",
              "signature": "(self, name: str, count: Optional[int] = None) -> Union[Awaitable[Union[str, List, NoneType]], str, List, NoneType]"
            },
            {
              "name": "rpoplpush",
              "doc": "RPOP a value off of the ``src`` list and atomically LPUSH it\non to the ``dst`` list.  Returns the value.\n\nFor more information see https://redis.io/commands/rpoplpush",
              "signature": "(self, src: str, dst: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "rpush",
              "doc": "Push ``values`` onto the tail of the list ``name``\n\nFor more information see https://redis.io/commands/rpush",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "rpushx",
              "doc": "Push ``value`` onto the tail of the list ``name`` if ``name`` exists\n\nFor more information see https://redis.io/commands/rpushx",
              "signature": "(self, name: str, *values: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "sadd",
              "doc": "Add ``value(s)`` to set ``name``\n\nFor more information see https://redis.io/commands/sadd",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "save",
              "doc": "Tell the Redis server to save its data to disk,\nblocking until the save is complete\n\nFor more information see https://redis.io/commands/save",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "scan",
              "doc": "Incrementally return lists of key names. Also return a cursor\nindicating the scan position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` provides a hint to Redis about the number of keys to\n    return per batch.\n\n``_type`` filters the returned values by a particular Redis type.\n    Stock Redis instances allow for the following types:\n    HASH, LIST, SET, STREAM, STRING, ZSET\n    Additionally, Redis modules can expose other types as well.\n\nFor more information see https://redis.io/commands/scan",
              "signature": "(self, cursor: int = 0, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, _type: Optional[str] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "scan_iter",
              "doc": "Make an iterator using the SCAN command so that the client doesn't\nneed to remember the cursor position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` provides a hint to Redis about the number of keys to\n    return per batch.\n\n``_type`` filters the returned values by a particular Redis type.\n    Stock Redis instances allow for the following types:\n    HASH, LIST, SET, STREAM, STRING, ZSET\n    Additionally, Redis modules can expose other types as well.",
              "signature": "(self, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, _type: Optional[str] = None, **kwargs) -> Iterator"
            },
            {
              "name": "scard",
              "doc": "Return the number of elements in set ``name``\n\nFor more information see https://redis.io/commands/scard",
              "signature": "(self, name: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "script_debug",
              "doc": null,
              "signature": "(self, *args) -> None"
            },
            {
              "name": "script_exists",
              "doc": "Check if a script exists in the script cache by specifying the SHAs of\neach script as ``args``. Returns a list of boolean values indicating if\nif each already script exists in the cache_data.\n\nFor more information see  https://redis.io/commands/script-exists",
              "signature": "(self, *args: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "script_flush",
              "doc": "Flush all scripts from the script cache_data.\n\n``sync_type`` is by default SYNC (synchronous) but it can also be\n              ASYNC.\n\nFor more information see  https://redis.io/commands/script-flush",
              "signature": "(self, sync_type: Union[Literal['SYNC'], Literal['ASYNC']] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "script_kill",
              "doc": "Kill the currently executing Lua script\n\nFor more information see https://redis.io/commands/script-kill",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "script_load",
              "doc": "Load a Lua ``script`` into the script cache_data. Returns the SHA.\n\nFor more information see https://redis.io/commands/script-load",
              "signature": "(self, script: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sdiff",
              "doc": "Return the difference of sets specified by ``keys``\n\nFor more information see https://redis.io/commands/sdiff",
              "signature": "(self, keys: List, *args: List) -> Union[Awaitable[list], list]"
            },
            {
              "name": "sdiffstore",
              "doc": "Store the difference of sets specified by ``keys`` into a new\nset named ``dest``.  Returns the number of keys in the new set.\n\nFor more information see https://redis.io/commands/sdiffstore",
              "signature": "(self, dest: str, keys: List, *args: List) -> Union[Awaitable[int], int]"
            },
            {
              "name": "select",
              "doc": "Select the Redis logical database at index.\n\nSee: https://redis.io/commands/select",
              "signature": "(self, index: int, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "set",
              "doc": "Set the value at key ``name`` to ``value``\n\n``ex`` sets an expire flag on key ``name`` for ``ex`` seconds.\n\n``px`` sets an expire flag on key ``name`` for ``px`` milliseconds.\n\n``nx`` if set to True, set the value at key ``name`` to ``value`` only\n    if it does not exist.\n\n``xx`` if set to True, set the value at key ``name`` to ``value`` only\n    if it already exists.\n\n``keepttl`` if True, retain the time to live associated with the key.\n    (Available since Redis 6.0)\n\n``get`` if True, set the value at key ``name`` to ``value`` and return\n    the old value stored at key, or None if the key did not exist.\n    (Available since Redis 6.2)\n\n``exat`` sets an expire flag on key ``name`` for ``ex`` seconds,\n    specified in unix time.\n\n``pxat`` sets an expire flag on key ``name`` for ``ex`` milliseconds,\n    specified in unix time.\n\nFor more information see https://redis.io/commands/set",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float], ex: Union[int, datetime.timedelta, NoneType] = None, px: Union[int, datetime.timedelta, NoneType] = None, nx: bool = False, xx: bool = False, keepttl: bool = False, get: bool = False, exat: Union[int, datetime.datetime, NoneType] = None, pxat: Union[int, datetime.datetime, NoneType] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "set_default_node",
              "doc": "Set the default node of the cluster.\n:param node: 'ClusterNode'\n:return True if the default node was set, else False",
              "signature": "(self, node)"
            },
            {
              "name": "set_response_callback",
              "doc": "Set a custom Response Callback",
              "signature": "(self, command, callback)"
            },
            {
              "name": "set_retry",
              "doc": null,
              "signature": "(self, retry: redis.retry.Retry) -> None"
            },
            {
              "name": "setbit",
              "doc": "Flag the ``offset`` in ``name`` as ``value``. Returns an integer\nindicating the previous value of ``offset``.\n\nFor more information see https://redis.io/commands/setbit",
              "signature": "(self, name: Union[bytes, str, memoryview], offset: int, value: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "setex",
              "doc": "Set the value of key ``name`` to ``value`` that expires in ``time``\nseconds. ``time`` can be represented by an integer or a Python\ntimedelta object.\n\nFor more information see https://redis.io/commands/setex",
              "signature": "(self, name: Union[bytes, str, memoryview], time: Union[int, datetime.timedelta], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "setnx",
              "doc": "Set the value of key ``name`` to ``value`` if key doesn't exist\n\nFor more information see https://redis.io/commands/setnx",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "setrange",
              "doc": "Overwrite bytes in the value of ``name`` starting at ``offset`` with\n``value``. If ``offset`` plus the length of ``value`` exceeds the\nlength of the original value, the new value will be larger than before.\nIf ``offset`` exceeds the length of the original value, null bytes\nwill be used to pad between the end of the previous value and the start\nof what's being injected.\n\nReturns the length of the new string.\n\nFor more information see https://redis.io/commands/setrange",
              "signature": "(self, name: Union[bytes, str, memoryview], offset: int, value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "shutdown",
              "doc": "Shutdown the Redis server.  If Redis has persistence configured,\ndata will be flushed before shutdown.\nIt is possible to specify modifiers to alter the behavior of the command:\n``save`` will force a DB saving operation even if no save points are configured.\n``nosave`` will prevent a DB saving operation even if one or more save points\nare configured.\n``now`` skips waiting for lagging replicas, i.e. it bypasses the first step in\nthe shutdown sequence.\n``force`` ignores any errors that would normally prevent the server from exiting\n``abort`` cancels an ongoing shutdown and cannot be combined with other flags.\n\nFor more information see https://redis.io/commands/shutdown",
              "signature": "(self, save: bool = False, nosave: bool = False, now: bool = False, force: bool = False, abort: bool = False, **kwargs) -> None"
            },
            {
              "name": "sinter",
              "doc": "Return the intersection of sets specified by ``keys``\n\nFor more information see https://redis.io/commands/sinter",
              "signature": "(self, keys: List, *args: List) -> Union[Awaitable[list], list]"
            },
            {
              "name": "sintercard",
              "doc": "Return the cardinality of the intersect of multiple sets specified by ``keys``.\n\nWhen LIMIT provided (defaults to 0 and means unlimited), if the intersection\ncardinality reaches limit partway through the computation, the algorithm will\nexit and yield limit as the cardinality\n\nFor more information see https://redis.io/commands/sintercard",
              "signature": "(self, numkeys: int, keys: List[str], limit: int = 0) -> Union[Awaitable[int], int]"
            },
            {
              "name": "sinterstore",
              "doc": "Store the intersection of sets specified by ``keys`` into a new\nset named ``dest``.  Returns the number of keys in the new set.\n\nFor more information see https://redis.io/commands/sinterstore",
              "signature": "(self, dest: str, keys: List, *args: List) -> Union[Awaitable[int], int]"
            },
            {
              "name": "sismember",
              "doc": "Return whether ``value`` is a member of set ``name``:\n- 1 if the value is a member of the set.\n- 0 if the value is not a member of the set or if key does not exist.\n\nFor more information see https://redis.io/commands/sismember",
              "signature": "(self, name: str, value: str) -> Union[Awaitable[Union[Literal[0], Literal[1]]], Literal[0], Literal[1]]"
            },
            {
              "name": "slaveof",
              "doc": "Make the server a replica of another instance, or promote it as master.\n\nFor more information see https://redis.io/commands/slaveof",
              "signature": "(self, *args, **kwargs) -> NoReturn"
            },
            {
              "name": "slowlog_get",
              "doc": "Get the entries from the slowlog. If ``num`` is specified, get the\nmost recent ``num`` items.\n\nFor more information see https://redis.io/commands/slowlog-get",
              "signature": "(self, num: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "slowlog_len",
              "doc": "Get the number of items in the slowlog\n\nFor more information see https://redis.io/commands/slowlog-len",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "slowlog_reset",
              "doc": "Remove all items in the slowlog\n\nFor more information see https://redis.io/commands/slowlog-reset",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "smembers",
              "doc": "Return all members of the set ``name``\n\nFor more information see https://redis.io/commands/smembers",
              "signature": "(self, name: str) -> Union[Awaitable[Set], Set]"
            },
            {
              "name": "smismember",
              "doc": "Return whether each value in ``values`` is a member of the set ``name``\nas a list of ``int`` in the order of ``values``:\n- 1 if the value is a member of the set.\n- 0 if the value is not a member of the set or if key does not exist.\n\nFor more information see https://redis.io/commands/smismember",
              "signature": "(self, name: str, values: List, *args: List) -> Union[Awaitable[List[Union[Literal[0], Literal[1]]]], List[Union[Literal[0], Literal[1]]]]"
            },
            {
              "name": "smove",
              "doc": "Move ``value`` from set ``src`` to set ``dst`` atomically\n\nFor more information see https://redis.io/commands/smove",
              "signature": "(self, src: str, dst: str, value: str) -> Union[Awaitable[bool], bool]"
            },
            {
              "name": "sort",
              "doc": "Sort and return the list, set or sorted set at ``name``.\n\n``start`` and ``num`` allow for paging through the sorted data\n\n``by`` allows using an external key to weight and sort the items.\n    Use an \"*\" to indicate where in the key the item value is located\n\n``get`` allows for returning items from external keys rather than the\n    sorted data itself.  Use an \"*\" to indicate where in the key\n    the item value is located\n\n``desc`` allows for reversing the sort\n\n``alpha`` allows for sorting lexicographically rather than numerically\n\n``store`` allows for storing the result of the sort into\n    the key ``store``\n\n``groups`` if set to True and if ``get`` contains at least two\n    elements, sort will return a list of tuples, each containing the\n    values fetched from the arguments to ``get``.\n\nFor more information see https://redis.io/commands/sort",
              "signature": "(self, name: str, start: Optional[int] = None, num: Optional[int] = None, by: Optional[str] = None, get: Optional[List[str]] = None, desc: bool = False, alpha: bool = False, store: Optional[str] = None, groups: Optional[bool] = False) -> Union[List, int]"
            },
            {
              "name": "sort_ro",
              "doc": "Returns the elements contained in the list, set or sorted set at key.\n(read-only variant of the SORT command)\n\n``start`` and ``num`` allow for paging through the sorted data\n\n``by`` allows using an external key to weight and sort the items.\n    Use an \"*\" to indicate where in the key the item value is located\n\n``get`` allows for returning items from external keys rather than the\n    sorted data itself.  Use an \"*\" to indicate where in the key\n    the item value is located\n\n``desc`` allows for reversing the sort\n\n``alpha`` allows for sorting lexicographically rather than numerically\n\nFor more information see https://redis.io/commands/sort_ro",
              "signature": "(self, key: str, start: Optional[int] = None, num: Optional[int] = None, by: Optional[str] = None, get: Optional[List[str]] = None, desc: bool = False, alpha: bool = False) -> list"
            },
            {
              "name": "spop",
              "doc": "Remove and return a random member of set ``name``\n\nFor more information see https://redis.io/commands/spop",
              "signature": "(self, name: str, count: Optional[int] = None) -> Union[str, List, NoneType]"
            },
            {
              "name": "spublish",
              "doc": "Posts a message to the given shard channel.\nReturns the number of clients that received the message\n\nFor more information see https://redis.io/commands/spublish",
              "signature": "(self, shard_channel: Union[bytes, str, memoryview], message: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "srandmember",
              "doc": "If ``number`` is None, returns a random member of set ``name``.\n\nIf ``number`` is supplied, returns a list of ``number`` random\nmembers of set ``name``. Note this is only available when running\nRedis 2.6+.\n\nFor more information see https://redis.io/commands/srandmember",
              "signature": "(self, name: str, number: Optional[int] = None) -> Union[str, List, NoneType]"
            },
            {
              "name": "srem",
              "doc": "Remove ``values`` from set ``name``\n\nFor more information see https://redis.io/commands/srem",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "sscan",
              "doc": "Incrementally return lists of elements in a set. Also return a cursor\nindicating the scan position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\nFor more information see https://redis.io/commands/sscan",
              "signature": "(self, name: Union[bytes, str, memoryview], cursor: int = 0, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sscan_iter",
              "doc": "Make an iterator using the SSCAN command so that the client doesn't\nneed to remember the cursor position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns",
              "signature": "(self, name: Union[bytes, str, memoryview], match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None) -> Iterator"
            },
            {
              "name": "stralgo",
              "doc": "Implements complex algorithms that operate on strings.\nRight now the only algorithm implemented is the LCS algorithm\n(longest common substring). However new algorithms could be\nimplemented in the future.\n\n``algo`` Right now must be LCS\n``value1`` and ``value2`` Can be two strings or two keys\n``specific_argument`` Specifying if the arguments to the algorithm\nwill be keys or strings. strings is the default.\n``len`` Returns just the len of the match.\n``idx`` Returns the match positions in each string.\n``minmatchlen`` Restrict the list of matches to the ones of a given\nminimal length. Can be provided only when ``idx`` set to True.\n``withmatchlen`` Returns the matches with the len of the match.\nCan be provided only when ``idx`` set to True.\n\nFor more information see https://redis.io/commands/stralgo",
              "signature": "(self, algo: Literal['LCS'], value1: Union[bytes, str, memoryview], value2: Union[bytes, str, memoryview], specific_argument: Union[Literal['strings'], Literal['keys']] = 'strings', len: bool = False, idx: bool = False, minmatchlen: Optional[int] = None, withmatchlen: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "strlen",
              "doc": "Return the number of bytes stored in the value of ``name``\n\nFor more information see https://redis.io/commands/strlen",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "substr",
              "doc": "Return a substring of the string at key ``name``. ``start`` and ``end``\nare 0-based integers specifying the portion of the string to return.",
              "signature": "(self, name: Union[bytes, str, memoryview], start: int, end: int = -1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sunion",
              "doc": "Return the union of sets specified by ``keys``\n\nFor more information see https://redis.io/commands/sunion",
              "signature": "(self, keys: List, *args: List) -> Union[Awaitable[List], List]"
            },
            {
              "name": "sunionstore",
              "doc": "Store the union of sets specified by ``keys`` into a new\nset named ``dest``.  Returns the number of keys in the new set.\n\nFor more information see https://redis.io/commands/sunionstore",
              "signature": "(self, dest: str, keys: List, *args: List) -> Union[Awaitable[int], int]"
            },
            {
              "name": "swapdb",
              "doc": "Swaps two Redis databases.\n\nFor more information see https://redis.io/commands/swapdb",
              "signature": "(self, *args, **kwargs) -> NoReturn"
            },
            {
              "name": "sync",
              "doc": "Initiates a replication stream from the master.\n\nFor more information see https://redis.io/commands/sync",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "tdigest",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'TDigestBloom'"
            },
            {
              "name": "time",
              "doc": "Returns the server time as a 2-item tuple of ints:\n(seconds since epoch, microseconds into this second).\n\nFor more information see https://redis.io/commands/time",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "topk",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'TOPKBloom'"
            },
            {
              "name": "touch",
              "doc": "Updates the last access time of given keys across the\ncluster.\n\nThe keys are first split up into slots\nand then an TOUCH command is sent for every slot\n\nNon-existent keys are ignored.\nReturns the number of keys that were touched.\n\nFor more information see https://redis.io/commands/touch",
              "signature": "(self, *keys: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "transaction",
              "doc": "Convenience method for executing the callable `func` as a transaction\nwhile watching all keys specified in `watches`. The 'func' callable\nshould expect a single argument which is a Pipeline object.",
              "signature": "(self, func, *watches, **kwargs)"
            },
            {
              "name": "ts",
              "doc": "Access the timeseries namespace, providing support for\nredis timeseries data.",
              "signature": "(self) -> 'TimeSeries'"
            },
            {
              "name": "ttl",
              "doc": "Returns the number of seconds until the key ``name`` will expire\n\nFor more information see https://redis.io/commands/ttl",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "type",
              "doc": "Returns the type of key ``name``\n\nFor more information see https://redis.io/commands/type",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "unlink",
              "doc": "Remove the specified keys in a different thread.\n\nThe keys are first split up into slots\nand then an TOUCH command is sent for every slot\n\nNon-existent keys are ignored.\nReturns the number of keys that were unlinked.\n\nFor more information see https://redis.io/commands/unlink",
              "signature": "(self, *keys: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "unwatch",
              "doc": "Unwatches all previously watched keys for a transaction\n\nFor more information see https://redis.io/commands/unwatch",
              "signature": "(self) -> None"
            },
            {
              "name": "vset",
              "doc": "Access the VectorSet commands namespace.",
              "signature": "(self) -> 'VectorSet'"
            },
            {
              "name": "wait",
              "doc": "Redis synchronous replication\nThat returns the number of replicas that processed the query when\nwe finally have at least ``num_replicas``, or when the ``timeout`` was\nreached.\n\nFor more information see https://redis.io/commands/wait",
              "signature": "(self, num_replicas: int, timeout: int, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "waitaof",
              "doc": "This command blocks the current client until all previous write\ncommands by that client are acknowledged as having been fsynced\nto the AOF of the local Redis and/or at least the specified number\nof replicas.\n\nFor more information see https://redis.io/commands/waitaof",
              "signature": "(self, num_local: int, num_replicas: int, timeout: int, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "watch",
              "doc": "Watches the values at keys ``names``, or None if the key doesn't exist\n\nFor more information see https://redis.io/commands/watch",
              "signature": "(self, *names: Union[bytes, str, memoryview]) -> None"
            },
            {
              "name": "xack",
              "doc": "Acknowledges the successful processing of one or more messages.\n\nArgs:\n    name: name of the stream.\n    groupname: name of the consumer group.\n    *ids: message ids to acknowledge.\n\nFor more information see https://redis.io/commands/xack",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], *ids: Union[int, bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xadd",
              "doc": "Add to a stream.\nname: name of the stream\nfields: dict of field/value pairs to insert into the stream\nid: Location to insert this record. By default it is appended.\nmaxlen: truncate old stream members beyond this size.\nCan't be specified with minid.\napproximate: actual stream length may be slightly more than maxlen\nnomkstream: When set to true, do not make a stream\nminid: the minimum id in the stream to query.\nCan't be specified with maxlen.\nlimit: specifies the maximum number of entries to retrieve\n\nFor more information see https://redis.io/commands/xadd",
              "signature": "(self, name: Union[bytes, str, memoryview], fields: Dict[Union[bytes, bytearray, memoryview, str, int, float], Union[bytes, bytearray, memoryview, str, int, float]], id: Union[int, bytes, str, memoryview] = '*', maxlen: Optional[int] = None, approximate: bool = True, nomkstream: bool = False, minid: Union[int, bytes, str, memoryview, NoneType] = None, limit: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xautoclaim",
              "doc": "Transfers ownership of pending stream entries that match the specified\ncriteria. Conceptually, equivalent to calling XPENDING and then XCLAIM,\nbut provides a more straightforward way to deal with message delivery\nfailures via SCAN-like semantics.\nname: name of the stream.\ngroupname: name of the consumer group.\nconsumername: name of a consumer that claims the message.\nmin_idle_time: filter messages that were idle less than this amount of\nmilliseconds.\nstart_id: filter messages with equal or greater ID.\ncount: optional integer, upper limit of the number of entries that the\ncommand attempts to claim. Set to 100 by default.\njustid: optional boolean, false by default. Return just an array of IDs\nof messages successfully claimed, without returning the actual message\n\nFor more information see https://redis.io/commands/xautoclaim",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], consumername: Union[bytes, str, memoryview], min_idle_time: int, start_id: Union[int, bytes, str, memoryview] = '0-0', count: Optional[int] = None, justid: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xclaim",
              "doc": "Changes the ownership of a pending message.\n\nname: name of the stream.\n\ngroupname: name of the consumer group.\n\nconsumername: name of a consumer that claims the message.\n\nmin_idle_time: filter messages that were idle less than this amount of\nmilliseconds\n\nmessage_ids: non-empty list or tuple of message IDs to claim\n\nidle: optional. Set the idle time (last time it was delivered) of the\nmessage in ms\n\ntime: optional integer. This is the same as idle but instead of a\nrelative amount of milliseconds, it sets the idle time to a specific\nUnix time (in milliseconds).\n\nretrycount: optional integer. set the retry counter to the specified\nvalue. This counter is incremented every time a message is delivered\nagain.\n\nforce: optional boolean, false by default. Creates the pending message\nentry in the PEL even if certain specified IDs are not already in the\nPEL assigned to a different client.\n\njustid: optional boolean, false by default. Return just an array of IDs\nof messages successfully claimed, without returning the actual message\n\nFor more information see https://redis.io/commands/xclaim",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], consumername: Union[bytes, str, memoryview], min_idle_time: int, message_ids: Union[List[Union[int, bytes, str, memoryview]], Tuple[Union[int, bytes, str, memoryview]]], idle: Optional[int] = None, time: Optional[int] = None, retrycount: Optional[int] = None, force: bool = False, justid: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xdel",
              "doc": "Deletes one or more messages from a stream.\n\nArgs:\n    name: name of the stream.\n    *ids: message ids to delete.\n\nFor more information see https://redis.io/commands/xdel",
              "signature": "(self, name: Union[bytes, str, memoryview], *ids: Union[int, bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_create",
              "doc": "Create a new consumer group associated with a stream.\nname: name of the stream.\ngroupname: name of the consumer group.\nid: ID of the last item in the stream to consider already delivered.\n\nFor more information see https://redis.io/commands/xgroup-create",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], id: Union[int, bytes, str, memoryview] = '$', mkstream: bool = False, entries_read: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_createconsumer",
              "doc": "Consumers in a consumer group are auto-created every time a new\nconsumer name is mentioned by some command.\nThey can be explicitly created by using this command.\nname: name of the stream.\ngroupname: name of the consumer group.\nconsumername: name of consumer to create.\n\nSee: https://redis.io/commands/xgroup-createconsumer",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], consumername: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_delconsumer",
              "doc": "Remove a specific consumer from a consumer group.\nReturns the number of pending messages that the consumer had before it\nwas deleted.\nname: name of the stream.\ngroupname: name of the consumer group.\nconsumername: name of consumer to delete\n\nFor more information see https://redis.io/commands/xgroup-delconsumer",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], consumername: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_destroy",
              "doc": "Destroy a consumer group.\nname: name of the stream.\ngroupname: name of the consumer group.\n\nFor more information see https://redis.io/commands/xgroup-destroy",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_setid",
              "doc": "Set the consumer group last delivered ID to something else.\nname: name of the stream.\ngroupname: name of the consumer group.\nid: ID of the last item in the stream to consider already delivered.\n\nFor more information see https://redis.io/commands/xgroup-setid",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], id: Union[int, bytes, str, memoryview], entries_read: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xinfo_consumers",
              "doc": "Returns general information about the consumers in the group.\nname: name of the stream.\ngroupname: name of the consumer group.\n\nFor more information see https://redis.io/commands/xinfo-consumers",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xinfo_groups",
              "doc": "Returns general information about the consumer groups of the stream.\nname: name of the stream.\n\nFor more information see https://redis.io/commands/xinfo-groups",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xinfo_stream",
              "doc": "Returns general information about the stream.\nname: name of the stream.\nfull: optional boolean, false by default. Return full summary\n\nFor more information see https://redis.io/commands/xinfo-stream",
              "signature": "(self, name: Union[bytes, str, memoryview], full: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xlen",
              "doc": "Returns the number of elements in a given stream.\n\nFor more information see https://redis.io/commands/xlen",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xpending",
              "doc": "Returns information about pending messages of a group.\nname: name of the stream.\ngroupname: name of the consumer group.\n\nFor more information see https://redis.io/commands/xpending",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xpending_range",
              "doc": "Returns information about pending messages, in a range.\n\nname: name of the stream.\ngroupname: name of the consumer group.\nidle: available from  version 6.2. filter entries by their\nidle-time, given in milliseconds (optional).\nmin: minimum stream ID.\nmax: maximum stream ID.\ncount: number of messages to return\nconsumername: name of a consumer to filter by (optional).",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], min: Union[int, bytes, str, memoryview], max: Union[int, bytes, str, memoryview], count: int, consumername: Union[bytes, str, memoryview, NoneType] = None, idle: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xrange",
              "doc": "Read stream values within an interval.\n\nname: name of the stream.\n\nstart: first stream ID. defaults to '-',\n       meaning the earliest available.\n\nfinish: last stream ID. defaults to '+',\n        meaning the latest available.\n\ncount: if set, only return this many items, beginning with the\n       earliest available.\n\nFor more information see https://redis.io/commands/xrange",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[int, bytes, str, memoryview] = '-', max: Union[int, bytes, str, memoryview] = '+', count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xread",
              "doc": "Block and monitor multiple streams for new data.\n\nstreams: a dict of stream names to stream IDs, where\n           IDs indicate the last ID already seen.\n\ncount: if set, only return this many items, beginning with the\n       earliest available.\n\nblock: number of milliseconds to wait, if nothing already present.\n\nFor more information see https://redis.io/commands/xread",
              "signature": "(self, streams: Dict[Union[bytes, str, memoryview], Union[int, bytes, str, memoryview]], count: Optional[int] = None, block: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xreadgroup",
              "doc": "Read from a stream via a consumer group.\n\ngroupname: name of the consumer group.\n\nconsumername: name of the requesting consumer.\n\nstreams: a dict of stream names to stream IDs, where\n       IDs indicate the last ID already seen.\n\ncount: if set, only return this many items, beginning with the\n       earliest available.\n\nblock: number of milliseconds to wait, if nothing already present.\nnoack: do not add messages to the PEL\n\nFor more information see https://redis.io/commands/xreadgroup",
              "signature": "(self, groupname: str, consumername: str, streams: Dict[Union[bytes, str, memoryview], Union[int, bytes, str, memoryview]], count: Optional[int] = None, block: Optional[int] = None, noack: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xrevrange",
              "doc": "Read stream values within an interval, in reverse order.\n\nname: name of the stream\n\nstart: first stream ID. defaults to '+',\n       meaning the latest available.\n\nfinish: last stream ID. defaults to '-',\n        meaning the earliest available.\n\ncount: if set, only return this many items, beginning with the\n       latest available.\n\nFor more information see https://redis.io/commands/xrevrange",
              "signature": "(self, name: Union[bytes, str, memoryview], max: Union[int, bytes, str, memoryview] = '+', min: Union[int, bytes, str, memoryview] = '-', count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xtrim",
              "doc": "Trims old messages from a stream.\nname: name of the stream.\nmaxlen: truncate old stream messages beyond this size\nCan't be specified with minid.\napproximate: actual stream length may be slightly more than maxlen\nminid: the minimum id in the stream to query\nCan't be specified with maxlen.\nlimit: specifies the maximum number of entries to retrieve\n\nFor more information see https://redis.io/commands/xtrim",
              "signature": "(self, name: Union[bytes, str, memoryview], maxlen: Optional[int] = None, approximate: bool = True, minid: Union[int, bytes, str, memoryview, NoneType] = None, limit: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zadd",
              "doc": "Set any number of element-name, score pairs to the key ``name``. Pairs\nare specified as a dict of element-names keys to score values.\n\n``nx`` forces ZADD to only create new elements and not to update\nscores for elements that already exist.\n\n``xx`` forces ZADD to only update scores of elements that already\nexist. New elements will not be added.\n\n``ch`` modifies the return value to be the numbers of elements changed.\nChanged elements include new elements that were added and elements\nwhose scores changed.\n\n``incr`` modifies ZADD to behave like ZINCRBY. In this mode only a\nsingle element/score pair can be specified and the score is the amount\nthe existing score will be incremented by. When using this mode the\nreturn value of ZADD will be the new score of the element.\n\n``LT`` Only update existing elements if the new score is less than\nthe current score. This flag doesn't prevent adding new elements.\n\n``GT`` Only update existing elements if the new score is greater than\nthe current score. This flag doesn't prevent adding new elements.\n\nThe return value of ZADD varies based on the mode specified. With no\noptions, ZADD returns the number of new elements added to the sorted\nset.\n\n``NX``, ``LT``, and ``GT`` are mutually exclusive options.\n\nSee: https://redis.io/commands/ZADD",
              "signature": "(self, name: Union[bytes, str, memoryview], mapping: Mapping[~AnyKeyT, Union[bytes, bytearray, memoryview, str, int, float]], nx: bool = False, xx: bool = False, ch: bool = False, incr: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zcard",
              "doc": "Return the number of elements in the sorted set ``name``\n\nFor more information see https://redis.io/commands/zcard",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zcount",
              "doc": "Returns the number of elements in the sorted set at key ``name`` with\na score between ``min`` and ``max``.\n\nFor more information see https://redis.io/commands/zcount",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[float, str], max: Union[float, str]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zdiff",
              "doc": "Returns the difference between the first and all successive input\nsorted sets provided in ``keys``.\n\nFor more information see https://redis.io/commands/zdiff",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], withscores: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zdiffstore",
              "doc": "Computes the difference between the first and all successive input\nsorted sets provided in ``keys`` and stores the result in ``dest``.\n\nFor more information see https://redis.io/commands/zdiffstore",
              "signature": "(self, dest: Union[bytes, str, memoryview], keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zincrby",
              "doc": "Increment the score of ``value`` in sorted set ``name`` by ``amount``\n\nFor more information see https://redis.io/commands/zincrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: float, value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zinter",
              "doc": "Return the intersect of multiple sorted sets specified by ``keys``.\nWith the ``aggregate`` option, it is possible to specify how the\nresults of the union are aggregated. This option defaults to SUM,\nwhere the score of an element is summed across the inputs where it\nexists. When this option is set to either MIN or MAX, the resulting\nset will contain the minimum or maximum score of an element across\nthe inputs where it exists.\n\nFor more information see https://redis.io/commands/zinter",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], aggregate: Optional[str] = None, withscores: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zintercard",
              "doc": "Return the cardinality of the intersect of multiple sorted sets\nspecified by ``keys``.\nWhen LIMIT provided (defaults to 0 and means unlimited), if the intersection\ncardinality reaches limit partway through the computation, the algorithm will\nexit and yield limit as the cardinality\n\nFor more information see https://redis.io/commands/zintercard",
              "signature": "(self, numkeys: int, keys: List[str], limit: int = 0) -> Union[Awaitable[int], int]"
            },
            {
              "name": "zinterstore",
              "doc": "Intersect multiple sorted sets specified by ``keys`` into a new\nsorted set, ``dest``. Scores in the destination will be aggregated\nbased on the ``aggregate``. This option defaults to SUM, where the\nscore of an element is summed across the inputs where it exists.\nWhen this option is set to either MIN or MAX, the resulting set will\ncontain the minimum or maximum score of an element across the inputs\nwhere it exists.\n\nFor more information see https://redis.io/commands/zinterstore",
              "signature": "(self, dest: Union[bytes, str, memoryview], keys: Union[Sequence[Union[bytes, str, memoryview]], Mapping[~AnyKeyT, float]], aggregate: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zlexcount",
              "doc": "Return the number of items in the sorted set ``name`` between the\nlexicographical range ``min`` and ``max``.\n\nFor more information see https://redis.io/commands/zlexcount",
              "signature": "(self, name, min, max)"
            },
            {
              "name": "zmpop",
              "doc": "Pop ``count`` values (default 1) off of the first non-empty sorted set\nnamed in the ``keys`` list.\nFor more information see https://redis.io/commands/zmpop",
              "signature": "(self, num_keys: int, keys: List[str], min: Optional[bool] = False, max: Optional[bool] = False, count: Optional[int] = 1) -> Union[Awaitable[list], list]"
            },
            {
              "name": "zmscore",
              "doc": "Returns the scores associated with the specified members\nin the sorted set stored at key.\n``members`` should be a list of the member name.\nReturn type is a list of score.\nIf the member does not exist, a None will be returned\nin corresponding position.\n\nFor more information see https://redis.io/commands/zmscore",
              "signature": "(self, key: Union[bytes, str, memoryview], members: List[str]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zpopmax",
              "doc": "Remove and return up to ``count`` members with the highest scores\nfrom the sorted set ``name``.\n\nFor more information see https://redis.io/commands/zpopmax",
              "signature": "(self, name: Union[bytes, str, memoryview], count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zpopmin",
              "doc": "Remove and return up to ``count`` members with the lowest scores\nfrom the sorted set ``name``.\n\nFor more information see https://redis.io/commands/zpopmin",
              "signature": "(self, name: Union[bytes, str, memoryview], count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrandmember",
              "doc": "Return a random element from the sorted set value stored at key.\n\n``count`` if the argument is positive, return an array of distinct\nfields. If called with a negative count, the behavior changes and\nthe command is allowed to return the same field multiple times.\nIn this case, the number of returned fields is the absolute value\nof the specified count.\n\n``withscores`` The optional WITHSCORES modifier changes the reply so it\nincludes the respective scores of the randomly selected elements from\nthe sorted set.\n\nFor more information see https://redis.io/commands/zrandmember",
              "signature": "(self, key: Union[bytes, str, memoryview], count: Optional[int] = None, withscores: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrange",
              "doc": "Return a range of values from sorted set ``name`` between\n``start`` and ``end`` sorted in ascending order.\n\n``start`` and ``end`` can be negative, indicating the end of the range.\n\n``desc`` a boolean indicating whether to sort the results in reversed\norder.\n\n``withscores`` indicates to return the scores along with the values.\nThe return type is a list of (value, score) pairs.\n\n``score_cast_func`` a callable used to cast the score return value.\n\n``byscore`` when set to True, returns the range of elements from the\nsorted set having scores equal or between ``start`` and ``end``.\n\n``bylex`` when set to True, returns the range of elements from the\nsorted set between the ``start`` and ``end`` lexicographical closed\nrange intervals.\nValid ``start`` and ``end`` must start with ( or [, in order to specify\nwhether the range interval is exclusive or inclusive, respectively.\n\n``offset`` and ``num`` are specified, then return a slice of the range.\nCan't be provided when using ``bylex``.\n\nFor more information see https://redis.io/commands/zrange",
              "signature": "(self, name: Union[bytes, str, memoryview], start: int, end: int, desc: bool = False, withscores: bool = False, score_cast_func: Union[type, Callable] = <class 'float'>, byscore: bool = False, bylex: bool = False, offset: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrangebylex",
              "doc": "Return the lexicographical range of values from sorted set ``name``\nbetween ``min`` and ``max``.\n\nIf ``start`` and ``num`` are specified, then return a slice of the\nrange.\n\nFor more information see https://redis.io/commands/zrangebylex",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[bytes, bytearray, memoryview, str, int, float], max: Union[bytes, bytearray, memoryview, str, int, float], start: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrangebyscore",
              "doc": "Return a range of values from the sorted set ``name`` with scores\nbetween ``min`` and ``max``.\n\nIf ``start`` and ``num`` are specified, then return a slice\nof the range.\n\n``withscores`` indicates to return the scores along with the values.\nThe return type is a list of (value, score) pairs\n\n`score_cast_func`` a callable used to cast the score return value\n\nFor more information see https://redis.io/commands/zrangebyscore",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[float, str], max: Union[float, str], start: Optional[int] = None, num: Optional[int] = None, withscores: bool = False, score_cast_func: Union[type, Callable] = <class 'float'>) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrangestore",
              "doc": "Stores in ``dest`` the result of a range of values from sorted set\n``name`` between ``start`` and ``end`` sorted in ascending order.\n\n``start`` and ``end`` can be negative, indicating the end of the range.\n\n``byscore`` when set to True, returns the range of elements from the\nsorted set having scores equal or between ``start`` and ``end``.\n\n``bylex`` when set to True, returns the range of elements from the\nsorted set between the ``start`` and ``end`` lexicographical closed\nrange intervals.\nValid ``start`` and ``end`` must start with ( or [, in order to specify\nwhether the range interval is exclusive or inclusive, respectively.\n\n``desc`` a boolean indicating whether to sort the results in reversed\norder.\n\n``offset`` and ``num`` are specified, then return a slice of the range.\nCan't be provided when using ``bylex``.\n\nFor more information see https://redis.io/commands/zrangestore",
              "signature": "(self, dest: Union[bytes, str, memoryview], name: Union[bytes, str, memoryview], start: int, end: int, byscore: bool = False, bylex: bool = False, desc: bool = False, offset: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrank",
              "doc": "Returns a 0-based value indicating the rank of ``value`` in sorted set\n``name``.\nThe optional WITHSCORE argument supplements the command's\nreply with the score of the element returned.\n\nFor more information see https://redis.io/commands/zrank",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float], withscore: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrem",
              "doc": "Remove member ``values`` from sorted set ``name``\n\nFor more information see https://redis.io/commands/zrem",
              "signature": "(self, name: Union[bytes, str, memoryview], *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zremrangebylex",
              "doc": "Remove all elements in the sorted set ``name`` between the\nlexicographical range specified by ``min`` and ``max``.\n\nReturns the number of elements removed.\n\nFor more information see https://redis.io/commands/zremrangebylex",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[bytes, bytearray, memoryview, str, int, float], max: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zremrangebyrank",
              "doc": "Remove all elements in the sorted set ``name`` with ranks between\n``min`` and ``max``. Values are 0-based, ordered from smallest score\nto largest. Values can be negative indicating the highest scores.\nReturns the number of elements removed\n\nFor more information see https://redis.io/commands/zremrangebyrank",
              "signature": "(self, name: Union[bytes, str, memoryview], min: int, max: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zremrangebyscore",
              "doc": "Remove all elements in the sorted set ``name`` with scores\nbetween ``min`` and ``max``. Returns the number of elements removed.\n\nFor more information see https://redis.io/commands/zremrangebyscore",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[float, str], max: Union[float, str]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrevrange",
              "doc": "Return a range of values from sorted set ``name`` between\n``start`` and ``end`` sorted in descending order.\n\n``start`` and ``end`` can be negative, indicating the end of the range.\n\n``withscores`` indicates to return the scores along with the values\nThe return type is a list of (value, score) pairs\n\n``score_cast_func`` a callable used to cast the score return value\n\nFor more information see https://redis.io/commands/zrevrange",
              "signature": "(self, name: Union[bytes, str, memoryview], start: int, end: int, withscores: bool = False, score_cast_func: Union[type, Callable] = <class 'float'>) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrevrangebylex",
              "doc": "Return the reversed lexicographical range of values from sorted set\n``name`` between ``max`` and ``min``.\n\nIf ``start`` and ``num`` are specified, then return a slice of the\nrange.\n\nFor more information see https://redis.io/commands/zrevrangebylex",
              "signature": "(self, name: Union[bytes, str, memoryview], max: Union[bytes, bytearray, memoryview, str, int, float], min: Union[bytes, bytearray, memoryview, str, int, float], start: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrevrangebyscore",
              "doc": "Return a range of values from the sorted set ``name`` with scores\nbetween ``min`` and ``max`` in descending order.\n\nIf ``start`` and ``num`` are specified, then return a slice\nof the range.\n\n``withscores`` indicates to return the scores along with the values.\nThe return type is a list of (value, score) pairs\n\n``score_cast_func`` a callable used to cast the score return value\n\nFor more information see https://redis.io/commands/zrevrangebyscore",
              "signature": "(self, name: Union[bytes, str, memoryview], max: Union[float, str], min: Union[float, str], start: Optional[int] = None, num: Optional[int] = None, withscores: bool = False, score_cast_func: Union[type, Callable] = <class 'float'>)"
            },
            {
              "name": "zrevrank",
              "doc": "Returns a 0-based value indicating the descending rank of\n``value`` in sorted set ``name``.\nThe optional ``withscore`` argument supplements the command's\nreply with the score of the element returned.\n\nFor more information see https://redis.io/commands/zrevrank",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float], withscore: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zscan",
              "doc": "Incrementally return lists of elements in a sorted set. Also return a\ncursor indicating the scan position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\n``score_cast_func`` a callable used to cast the score return value\n\nFor more information see https://redis.io/commands/zscan",
              "signature": "(self, name: Union[bytes, str, memoryview], cursor: int = 0, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, score_cast_func: Union[type, Callable] = <class 'float'>) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zscan_iter",
              "doc": "Make an iterator using the ZSCAN command so that the client doesn't\nneed to remember the cursor position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\n``score_cast_func`` a callable used to cast the score return value",
              "signature": "(self, name: Union[bytes, str, memoryview], match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, score_cast_func: Union[type, Callable] = <class 'float'>) -> Iterator"
            },
            {
              "name": "zscore",
              "doc": "Return the score of element ``value`` in sorted set ``name``\n\nFor more information see https://redis.io/commands/zscore",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zunion",
              "doc": "Return the union of multiple sorted sets specified by ``keys``.\n``keys`` can be provided as dictionary of keys and their weights.\nScores will be aggregated based on the ``aggregate``, or SUM if\nnone is provided.\n\nFor more information see https://redis.io/commands/zunion",
              "signature": "(self, keys: Union[Sequence[Union[bytes, str, memoryview]], Mapping[~AnyKeyT, float]], aggregate: Optional[str] = None, withscores: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zunionstore",
              "doc": "Union multiple sorted sets specified by ``keys`` into\na new sorted set, ``dest``. Scores in the destination will be\naggregated based on the ``aggregate``, or SUM if none is provided.\n\nFor more information see https://redis.io/commands/zunionstore",
              "signature": "(self, dest: Union[bytes, str, memoryview], keys: Union[Sequence[Union[bytes, str, memoryview]], Mapping[~AnyKeyT, float]], aggregate: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            }
          ]
        },
        {
          "name": "RedisClusterException",
          "doc": "Base exception for the RedisCluster client",
          "functions": []
        },
        {
          "name": "RedisError",
          "doc": "Common base class for all non-exit exceptions.",
          "functions": []
        },
        {
          "name": "ResponseError",
          "doc": "Common base class for all non-exit exceptions.",
          "functions": []
        },
        {
          "name": "SSLConnection",
          "doc": "Manages SSL connections to and from the Redis server(s).\nThis class extends the Connection class, adding SSL functionality, and making\nuse of ssl.SSLContext (https://docs.python.org/3/library/ssl.html#ssl.SSLContext)",
          "functions": [
            {
              "name": "__del__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Constructor\n\nArgs:\n    ssl_keyfile: Path to an ssl private key. Defaults to None.\n    ssl_certfile: Path to an ssl certificate. Defaults to None.\n    ssl_cert_reqs: The string value for the SSLContext.verify_mode (none, optional, required), or an ssl.VerifyMode. Defaults to \"required\".\n    ssl_ca_certs: The path to a file of concatenated CA certificates in PEM format. Defaults to None.\n    ssl_ca_data: Either an ASCII string of one or more PEM-encoded certificates or a bytes-like object of DER-encoded certificates.\n    ssl_check_hostname: If set, match the hostname during the SSL handshake. Defaults to False.\n    ssl_ca_path: The path to a directory containing several CA certificates in PEM format. Defaults to None.\n    ssl_password: Password for unlocking an encrypted private key. Defaults to None.\n\n    ssl_validate_ocsp: If set, perform a full ocsp validation (i.e not a stapled verification)\n    ssl_validate_ocsp_stapled: If set, perform a validation on a stapled ocsp response\n    ssl_ocsp_context: A fully initialized OpenSSL.SSL.Context object to be used in verifying the ssl_ocsp_expected_cert\n    ssl_ocsp_expected_cert: A PEM armoured string containing the expected certificate to be returned from the ocsp verification service.\n    ssl_min_version: The lowest supported SSL version. It affects the supported SSL versions of the SSLContext. None leaves the default provided by ssl module.\n    ssl_ciphers: A string listing the ciphers that are allowed to be used. Defaults to None, which means that the default ciphers are used. See https://docs.python.org/3/library/ssl.html#ssl.SSLContext.set_ciphers for more information.\n\nRaises:\n    RedisError",
              "signature": "(self, ssl_keyfile=None, ssl_certfile=None, ssl_cert_reqs='required', ssl_ca_certs=None, ssl_ca_data=None, ssl_check_hostname=True, ssl_ca_path=None, ssl_password=None, ssl_validate_ocsp=False, ssl_validate_ocsp_stapled=False, ssl_ocsp_context=None, ssl_ocsp_expected_cert=None, ssl_min_version=None, ssl_ciphers=None, **kwargs)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "_connect",
              "doc": "Wrap the socket with SSL support, handling potential errors.",
              "signature": "(self)"
            },
            {
              "name": "_construct_command_packer",
              "doc": null,
              "signature": "(self, packer)"
            },
            {
              "name": "_error_message",
              "doc": null,
              "signature": "(self, exception)"
            },
            {
              "name": "_host_error",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_ping_failed",
              "doc": "Function to call when PING fails",
              "signature": "(self, error)"
            },
            {
              "name": "_send_ping",
              "doc": "Send PING, expect PONG in return",
              "signature": "(self)"
            },
            {
              "name": "_wrap_socket_with_ssl",
              "doc": "Wraps the socket with SSL support.\n\nArgs:\n    sock: The plain socket to wrap with SSL.\n\nReturns:\n    An SSL wrapped socket.",
              "signature": "(self, sock)"
            },
            {
              "name": "can_read",
              "doc": "Poll the socket to see if there's data that can be read.",
              "signature": "(self, timeout=0)"
            },
            {
              "name": "check_health",
              "doc": "Check the health of the connection with a PING/PONG",
              "signature": "(self)"
            },
            {
              "name": "connect",
              "doc": "Connects to the Redis server if not already connected",
              "signature": "(self)"
            },
            {
              "name": "connect_check_health",
              "doc": null,
              "signature": "(self, check_health: bool = True)"
            },
            {
              "name": "deregister_connect_callback",
              "doc": "De-register a previously registered callback.  It will no-longer receive\nnotifications on connection events.  Calling this is not required when the\nlistener goes away, since the callbacks are kept as weak methods.",
              "signature": "(self, callback)"
            },
            {
              "name": "disconnect",
              "doc": "Disconnects from the Redis server",
              "signature": "(self, *args)"
            },
            {
              "name": "get_protocol",
              "doc": null,
              "signature": "(self) -> Union[int, str]"
            },
            {
              "name": "on_connect",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "on_connect_check_health",
              "doc": "Initialize the connection, authenticate and select a database",
              "signature": "(self, check_health: bool = True)"
            },
            {
              "name": "pack_command",
              "doc": "Pack a series of arguments into the Redis protocol",
              "signature": "(self, *args)"
            },
            {
              "name": "pack_commands",
              "doc": "Pack multiple commands into the Redis protocol",
              "signature": "(self, commands)"
            },
            {
              "name": "re_auth",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "read_response",
              "doc": "Read the response from a previously sent command",
              "signature": "(self, disable_decoding=False, *, disconnect_on_error=True, push_request=False)"
            },
            {
              "name": "register_connect_callback",
              "doc": "Register a callback to be called when the connection is established either\ninitially or reconnected.  This allows listeners to issue commands that\nare ephemeral to the connection, for example pub/sub subscription or\nkey tracking.  The callback must be a _method_ and will be kept as\na weak reference.",
              "signature": "(self, callback)"
            },
            {
              "name": "repr_pieces",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "send_command",
              "doc": "Pack and send a command to the Redis server",
              "signature": "(self, *args, **kwargs)"
            },
            {
              "name": "send_packed_command",
              "doc": "Send an already packed command to the Redis server",
              "signature": "(self, command, check_health=True)"
            },
            {
              "name": "set_parser",
              "doc": "Creates a new instance of parser_class with socket size:\n_socket_read_size and assigns it to the parser for the connection\n:param parser_class: The required parser class",
              "signature": "(self, parser_class)"
            },
            {
              "name": "set_re_auth_token",
              "doc": null,
              "signature": "(self, token: redis.auth.token.TokenInterface)"
            }
          ]
        },
        {
          "name": "Sentinel",
          "doc": "Redis Sentinel cluster client\n\n>>> from redis.sentinel import Sentinel\n>>> sentinel = Sentinel([('localhost', 26379)], socket_timeout=0.1)\n>>> master = sentinel.master_for('mymaster', socket_timeout=0.1)\n>>> master.set('foo', 'bar')\n>>> slave = sentinel.slave_for('mymaster', socket_timeout=0.1)\n>>> slave.get('foo')\nb'bar'\n\n``sentinels`` is a list of sentinel nodes. Each node is represented by\na pair (hostname, port).\n\n``min_other_sentinels`` defined a minimum number of peers for a sentinel.\nWhen querying a sentinel, if it doesn't meet this threshold, responses\nfrom that sentinel won't be considered valid.\n\n``sentinel_kwargs`` is a dictionary of connection arguments used when\nconnecting to sentinel instances. Any argument that can be passed to\na normal Redis connection can be specified here. If ``sentinel_kwargs`` is\nnot specified, any socket_timeout and socket_keepalive options specified\nin ``connection_kwargs`` will be used.\n\n``connection_kwargs`` are keyword arguments that will be used when\nestablishing a connection to a Redis server.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, sentinels, min_other_sentinels=0, sentinel_kwargs=None, force_master_ip=None, **connection_kwargs)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "check_master_state",
              "doc": null,
              "signature": "(self, state, service_name)"
            },
            {
              "name": "discover_master",
              "doc": "Asks sentinel servers for the Redis master's address corresponding\nto the service labeled ``service_name``.\n\nReturns a pair (address, port) or raises MasterNotFoundError if no\nmaster is found.",
              "signature": "(self, service_name)"
            },
            {
              "name": "discover_slaves",
              "doc": "Returns a list of alive slaves for service ``service_name``",
              "signature": "(self, service_name)"
            },
            {
              "name": "execute_command",
              "doc": "Execute Sentinel command in sentinel nodes.\nonce - If set to True, then execute the resulting command on a single\nnode at random, rather than across the entire sentinel cluster.",
              "signature": "(self, *args, **kwargs)"
            },
            {
              "name": "filter_slaves",
              "doc": "Remove slaves that are in an ODOWN or SDOWN state",
              "signature": "(self, slaves)"
            },
            {
              "name": "master_for",
              "doc": "Returns a redis client instance for the ``service_name`` master.\nSentinel client will detect failover and reconnect Redis clients\nautomatically.\n\nA :py:class:`~redis.sentinel.SentinelConnectionPool` class is\nused to retrieve the master's address before establishing a new\nconnection.\n\nNOTE: If the master's address has changed, any cached connections to\nthe old master are closed.\n\nBy default clients will be a :py:class:`~redis.Redis` instance.\nSpecify a different class to the ``redis_class`` argument if you\ndesire something different.\n\nThe ``connection_pool_class`` specifies the connection pool to\nuse.  The :py:class:`~redis.sentinel.SentinelConnectionPool`\nwill be used by default.\n\nAll other keyword arguments are merged with any connection_kwargs\npassed to this class and passed to the connection pool as keyword\narguments to be used to initialize Redis connections.",
              "signature": "(self, service_name, redis_class=<class 'redis.client.Redis'>, connection_pool_class=<class 'redis.sentinel.SentinelConnectionPool'>, **kwargs)"
            },
            {
              "name": "sentinel",
              "doc": "Redis Sentinel's SENTINEL command.",
              "signature": "(self, *args)"
            },
            {
              "name": "sentinel_ckquorum",
              "doc": "Check if the current Sentinel configuration is able to reach the\nquorum needed to failover a master, and the majority needed to\nauthorize the failover.\n\nThis command should be used in monitoring systems to check if a\nSentinel deployment is ok.",
              "signature": "(self, new_master_name)"
            },
            {
              "name": "sentinel_failover",
              "doc": "Force a failover as if the master was not reachable, and without\nasking for agreement to other Sentinels (however a new version of the\nconfiguration will be published so that the other Sentinels will\nupdate their configurations).",
              "signature": "(self, new_master_name)"
            },
            {
              "name": "sentinel_flushconfig",
              "doc": "Force Sentinel to rewrite its configuration on disk, including the\ncurrent Sentinel state.\n\nNormally Sentinel rewrites the configuration every time something\nchanges in its state (in the context of the subset of the state which\nis persisted on disk across restart).\nHowever sometimes it is possible that the configuration file is lost\nbecause of operation errors, disk failures, package upgrade scripts or\nconfiguration managers. In those cases a way to to force Sentinel to\nrewrite the configuration file is handy.\n\nThis command works even if the previous configuration file is\ncompletely missing.",
              "signature": "(self)"
            },
            {
              "name": "sentinel_get_master_addr_by_name",
              "doc": "Returns a (host, port) pair for the given ``service_name``",
              "signature": "(self, service_name)"
            },
            {
              "name": "sentinel_master",
              "doc": "Returns a dictionary containing the specified masters state.",
              "signature": "(self, service_name)"
            },
            {
              "name": "sentinel_masters",
              "doc": "Returns a list of dictionaries containing each master's state.",
              "signature": "(self)"
            },
            {
              "name": "sentinel_monitor",
              "doc": "Add a new master to Sentinel to be monitored",
              "signature": "(self, name, ip, port, quorum)"
            },
            {
              "name": "sentinel_remove",
              "doc": "Remove a master from Sentinel's monitoring",
              "signature": "(self, name)"
            },
            {
              "name": "sentinel_reset",
              "doc": "This command will reset all the masters with matching name.\nThe pattern argument is a glob-style pattern.\n\nThe reset process clears any previous state in a master (including a\nfailover in progress), and removes every slave and sentinel already\ndiscovered and associated with the master.",
              "signature": "(self, pattern)"
            },
            {
              "name": "sentinel_sentinels",
              "doc": "Returns a list of sentinels for ``service_name``",
              "signature": "(self, service_name)"
            },
            {
              "name": "sentinel_set",
              "doc": "Set Sentinel monitoring parameters for a given master",
              "signature": "(self, name, option, value)"
            },
            {
              "name": "sentinel_slaves",
              "doc": "Returns a list of slaves for ``service_name``",
              "signature": "(self, service_name)"
            },
            {
              "name": "slave_for",
              "doc": "Returns redis client instance for the ``service_name`` slave(s).\n\nA SentinelConnectionPool class is used to retrieve the slave's\naddress before establishing a new connection.\n\nBy default clients will be a :py:class:`~redis.Redis` instance.\nSpecify a different class to the ``redis_class`` argument if you\ndesire something different.\n\nThe ``connection_pool_class`` specifies the connection pool to use.\nThe SentinelConnectionPool will be used by default.\n\nAll other keyword arguments are merged with any connection_kwargs\npassed to this class and passed to the connection pool as keyword\narguments to be used to initialize Redis connections.",
              "signature": "(self, service_name, redis_class=<class 'redis.client.Redis'>, connection_pool_class=<class 'redis.sentinel.SentinelConnectionPool'>, **kwargs)"
            }
          ]
        },
        {
          "name": "SentinelConnectionPool",
          "doc": "Sentinel backed connection pool.\n\nIf ``check_connection`` flag is set to True, SentinelManagedConnection\nsends a PING command right after establishing the connection.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, service_name, sentinel_manager, **kwargs)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "_checkpid",
              "doc": null,
              "signature": "(self) -> None"
            },
            {
              "name": "_mock",
              "doc": "Dummy functions, needs to be passed as error callback to retry object.\n:param error:\n:return:",
              "signature": "(self, error: redis.exceptions.RedisError)"
            },
            {
              "name": "close",
              "doc": "Close the pool, disconnecting all connections",
              "signature": "(self) -> None"
            },
            {
              "name": "disconnect",
              "doc": "Disconnects connections in the pool\n\nIf ``inuse_connections`` is True, disconnect connections that are\ncurrent in use, potentially by other threads. Otherwise only disconnect\nconnections that are idle in the pool.",
              "signature": "(self, inuse_connections: bool = True) -> None"
            },
            {
              "name": "get_connection",
              "doc": "Get a connection from the pool",
              "signature": "(self, command_name=None, *keys, **options) -> 'Connection'"
            },
            {
              "name": "get_encoder",
              "doc": "Return an encoder based on encoding settings",
              "signature": "(self) -> redis._parsers.encoders.Encoder"
            },
            {
              "name": "get_master_address",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "get_protocol",
              "doc": "Returns:\n    The RESP protocol version, or ``None`` if the protocol is not specified,\n    in which case the server default will be used.",
              "signature": "(self)"
            },
            {
              "name": "make_connection",
              "doc": "Create a new connection",
              "signature": "(self) -> 'ConnectionInterface'"
            },
            {
              "name": "owns_connection",
              "doc": null,
              "signature": "(self, connection)"
            },
            {
              "name": "re_auth_callback",
              "doc": null,
              "signature": "(self, token: redis.auth.token.TokenInterface)"
            },
            {
              "name": "release",
              "doc": "Releases the connection back to the pool",
              "signature": "(self, connection: 'Connection') -> None"
            },
            {
              "name": "reset",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "rotate_slaves",
              "doc": "Round-robin slave balancer",
              "signature": "(self)"
            },
            {
              "name": "set_retry",
              "doc": null,
              "signature": "(self, retry: redis.retry.Retry) -> None"
            }
          ]
        },
        {
          "name": "SentinelManagedConnection",
          "doc": "Manages TCP communication to and from a Redis server",
          "functions": [
            {
              "name": "__del__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize a new Connection.\nTo specify a retry policy for specific errors, first set\n`retry_on_error` to a list of the error/s to retry on, then set\n`retry` to a valid `Retry` object.\nTo retry on TimeoutError, `retry_on_timeout` can also be set to `True`.",
              "signature": "(self, **kwargs)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "_connect",
              "doc": "Create a TCP socket connection",
              "signature": "(self)"
            },
            {
              "name": "_connect_retry",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_construct_command_packer",
              "doc": null,
              "signature": "(self, packer)"
            },
            {
              "name": "_error_message",
              "doc": null,
              "signature": "(self, exception)"
            },
            {
              "name": "_host_error",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_ping_failed",
              "doc": "Function to call when PING fails",
              "signature": "(self, error)"
            },
            {
              "name": "_send_ping",
              "doc": "Send PING, expect PONG in return",
              "signature": "(self)"
            },
            {
              "name": "can_read",
              "doc": "Poll the socket to see if there's data that can be read.",
              "signature": "(self, timeout=0)"
            },
            {
              "name": "check_health",
              "doc": "Check the health of the connection with a PING/PONG",
              "signature": "(self)"
            },
            {
              "name": "connect",
              "doc": "Connects to the Redis server if not already connected",
              "signature": "(self)"
            },
            {
              "name": "connect_check_health",
              "doc": null,
              "signature": "(self, check_health: bool = True)"
            },
            {
              "name": "connect_to",
              "doc": null,
              "signature": "(self, address)"
            },
            {
              "name": "deregister_connect_callback",
              "doc": "De-register a previously registered callback.  It will no-longer receive\nnotifications on connection events.  Calling this is not required when the\nlistener goes away, since the callbacks are kept as weak methods.",
              "signature": "(self, callback)"
            },
            {
              "name": "disconnect",
              "doc": "Disconnects from the Redis server",
              "signature": "(self, *args)"
            },
            {
              "name": "get_protocol",
              "doc": null,
              "signature": "(self) -> Union[int, str]"
            },
            {
              "name": "on_connect",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "on_connect_check_health",
              "doc": "Initialize the connection, authenticate and select a database",
              "signature": "(self, check_health: bool = True)"
            },
            {
              "name": "pack_command",
              "doc": "Pack a series of arguments into the Redis protocol",
              "signature": "(self, *args)"
            },
            {
              "name": "pack_commands",
              "doc": "Pack multiple commands into the Redis protocol",
              "signature": "(self, commands)"
            },
            {
              "name": "re_auth",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "read_response",
              "doc": "Read the response from a previously sent command",
              "signature": "(self, disable_decoding=False, *, disconnect_on_error: Optional[bool] = False, push_request: Optional[bool] = False)"
            },
            {
              "name": "register_connect_callback",
              "doc": "Register a callback to be called when the connection is established either\ninitially or reconnected.  This allows listeners to issue commands that\nare ephemeral to the connection, for example pub/sub subscription or\nkey tracking.  The callback must be a _method_ and will be kept as\na weak reference.",
              "signature": "(self, callback)"
            },
            {
              "name": "repr_pieces",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "send_command",
              "doc": "Pack and send a command to the Redis server",
              "signature": "(self, *args, **kwargs)"
            },
            {
              "name": "send_packed_command",
              "doc": "Send an already packed command to the Redis server",
              "signature": "(self, command, check_health=True)"
            },
            {
              "name": "set_parser",
              "doc": "Creates a new instance of parser_class with socket size:\n_socket_read_size and assigns it to the parser for the connection\n:param parser_class: The required parser class",
              "signature": "(self, parser_class)"
            },
            {
              "name": "set_re_auth_token",
              "doc": null,
              "signature": "(self, token: redis.auth.token.TokenInterface)"
            }
          ]
        },
        {
          "name": "SentinelManagedSSLConnection",
          "doc": "Manages SSL connections to and from the Redis server(s).\nThis class extends the Connection class, adding SSL functionality, and making\nuse of ssl.SSLContext (https://docs.python.org/3/library/ssl.html#ssl.SSLContext)",
          "functions": [
            {
              "name": "__del__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize a new Connection.\nTo specify a retry policy for specific errors, first set\n`retry_on_error` to a list of the error/s to retry on, then set\n`retry` to a valid `Retry` object.\nTo retry on TimeoutError, `retry_on_timeout` can also be set to `True`.",
              "signature": "(self, **kwargs)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "_connect",
              "doc": "Wrap the socket with SSL support, handling potential errors.",
              "signature": "(self)"
            },
            {
              "name": "_connect_retry",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_construct_command_packer",
              "doc": null,
              "signature": "(self, packer)"
            },
            {
              "name": "_error_message",
              "doc": null,
              "signature": "(self, exception)"
            },
            {
              "name": "_host_error",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_ping_failed",
              "doc": "Function to call when PING fails",
              "signature": "(self, error)"
            },
            {
              "name": "_send_ping",
              "doc": "Send PING, expect PONG in return",
              "signature": "(self)"
            },
            {
              "name": "_wrap_socket_with_ssl",
              "doc": "Wraps the socket with SSL support.\n\nArgs:\n    sock: The plain socket to wrap with SSL.\n\nReturns:\n    An SSL wrapped socket.",
              "signature": "(self, sock)"
            },
            {
              "name": "can_read",
              "doc": "Poll the socket to see if there's data that can be read.",
              "signature": "(self, timeout=0)"
            },
            {
              "name": "check_health",
              "doc": "Check the health of the connection with a PING/PONG",
              "signature": "(self)"
            },
            {
              "name": "connect",
              "doc": "Connects to the Redis server if not already connected",
              "signature": "(self)"
            },
            {
              "name": "connect_check_health",
              "doc": null,
              "signature": "(self, check_health: bool = True)"
            },
            {
              "name": "connect_to",
              "doc": null,
              "signature": "(self, address)"
            },
            {
              "name": "deregister_connect_callback",
              "doc": "De-register a previously registered callback.  It will no-longer receive\nnotifications on connection events.  Calling this is not required when the\nlistener goes away, since the callbacks are kept as weak methods.",
              "signature": "(self, callback)"
            },
            {
              "name": "disconnect",
              "doc": "Disconnects from the Redis server",
              "signature": "(self, *args)"
            },
            {
              "name": "get_protocol",
              "doc": null,
              "signature": "(self) -> Union[int, str]"
            },
            {
              "name": "on_connect",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "on_connect_check_health",
              "doc": "Initialize the connection, authenticate and select a database",
              "signature": "(self, check_health: bool = True)"
            },
            {
              "name": "pack_command",
              "doc": "Pack a series of arguments into the Redis protocol",
              "signature": "(self, *args)"
            },
            {
              "name": "pack_commands",
              "doc": "Pack multiple commands into the Redis protocol",
              "signature": "(self, commands)"
            },
            {
              "name": "re_auth",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "read_response",
              "doc": "Read the response from a previously sent command",
              "signature": "(self, disable_decoding=False, *, disconnect_on_error: Optional[bool] = False, push_request: Optional[bool] = False)"
            },
            {
              "name": "register_connect_callback",
              "doc": "Register a callback to be called when the connection is established either\ninitially or reconnected.  This allows listeners to issue commands that\nare ephemeral to the connection, for example pub/sub subscription or\nkey tracking.  The callback must be a _method_ and will be kept as\na weak reference.",
              "signature": "(self, callback)"
            },
            {
              "name": "repr_pieces",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "send_command",
              "doc": "Pack and send a command to the Redis server",
              "signature": "(self, *args, **kwargs)"
            },
            {
              "name": "send_packed_command",
              "doc": "Send an already packed command to the Redis server",
              "signature": "(self, command, check_health=True)"
            },
            {
              "name": "set_parser",
              "doc": "Creates a new instance of parser_class with socket size:\n_socket_read_size and assigns it to the parser for the connection\n:param parser_class: The required parser class",
              "signature": "(self, parser_class)"
            },
            {
              "name": "set_re_auth_token",
              "doc": null,
              "signature": "(self, token: redis.auth.token.TokenInterface)"
            }
          ]
        },
        {
          "name": "Redis",
          "doc": "Implementation of the Redis protocol.\n\nThis abstract class provides a Python interface to all Redis commands\nand an implementation of the Redis protocol.\n\nPipelines derive from this, implementing how\nthe commands are sent and received to the Redis server. Based on\nconfiguration, an instance will either use a ConnectionPool, or\nConnection object to talk to redis.\n\nIt is not safe to pass PubSub or Pipeline objects between threads.",
          "functions": [
            {
              "name": "__contains__",
              "doc": "Returns the number of ``names`` that exist\n\nFor more information see https://redis.io/commands/exists",
              "signature": "(self, *names: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "__del__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__delitem__",
              "doc": null,
              "signature": "(self, name: Union[bytes, str, memoryview])"
            },
            {
              "name": "__enter__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__exit__",
              "doc": null,
              "signature": "(self, exc_type, exc_value, traceback)"
            },
            {
              "name": "__getitem__",
              "doc": "Return the value at key ``name``, raises a KeyError if the key\ndoesn't exist.",
              "signature": "(self, name: Union[bytes, str, memoryview])"
            },
            {
              "name": "__init__",
              "doc": "Initialize a new Redis client.\n\nTo specify a retry policy for specific errors, you have two options:\n\n1. Set the `retry_on_error` to a list of the error/s to retry on, and\nyou can also set `retry` to a valid `Retry` object(in case the default\none is not appropriate) - with this approach the retries will be triggered\non the default errors specified in the Retry object enriched with the\nerrors specified in `retry_on_error`.\n\n2. Define a `Retry` object with configured 'supported_errors' and set\nit to the `retry` parameter - with this approach you completely redefine\nthe errors on which retries will happen.\n\n`retry_on_timeout` is deprecated - please include the TimeoutError\neither in the Retry object or in the `retry_on_error` list.\n\nWhen 'connection_pool' is provided - the retry configuration of the\nprovided pool will be used.\n\nArgs:\n\nsingle_connection_client:\n    if `True`, connection pool is not used. In that case `Redis`\n    instance use is not thread safe.",
              "signature": "(self, host: str = 'localhost', port: int = 6379, db: int = 0, password: Optional[str] = None, socket_timeout: Optional[float] = None, socket_connect_timeout: Optional[float] = None, socket_keepalive: Optional[bool] = None, socket_keepalive_options: Optional[Mapping[int, Union[int, bytes]]] = None, connection_pool: Optional[redis.connection.ConnectionPool] = None, unix_socket_path: Optional[str] = None, encoding: str = 'utf-8', encoding_errors: str = 'strict', decode_responses: bool = False, retry_on_timeout: bool = False, retry: redis.retry.Retry = <redis.retry.Retry object at 0x0000023EF683A6D0>, retry_on_error: Optional[List[Type[Exception]]] = None, ssl: bool = False, ssl_keyfile: Optional[str] = None, ssl_certfile: Optional[str] = None, ssl_cert_reqs: Union[str, ForwardRef('ssl.VerifyMode')] = 'required', ssl_ca_certs: Optional[str] = None, ssl_ca_path: Optional[str] = None, ssl_ca_data: Optional[str] = None, ssl_check_hostname: bool = True, ssl_password: Optional[str] = None, ssl_validate_ocsp: bool = False, ssl_validate_ocsp_stapled: bool = False, ssl_ocsp_context: Optional[ForwardRef('OpenSSL.SSL.Context')] = None, ssl_ocsp_expected_cert: Optional[str] = None, ssl_min_version: Optional[ForwardRef('ssl.TLSVersion')] = None, ssl_ciphers: Optional[str] = None, max_connections: Optional[int] = None, single_connection_client: bool = False, health_check_interval: int = 0, client_name: Optional[str] = None, lib_name: Optional[str] = 'redis-py', lib_version: Optional[str] = '6.2.0', username: Optional[str] = None, redis_connect_func: Optional[Callable[[], NoneType]] = None, credential_provider: Optional[redis.credentials.CredentialProvider] = None, protocol: Optional[int] = 2, cache: Optional[redis.cache.CacheInterface] = None, cache_config: Optional[redis.cache.CacheConfig] = None, event_dispatcher: Optional[redis.event.EventDispatcher] = None) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "__setitem__",
              "doc": null,
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float])"
            },
            {
              "name": "_close_connection",
              "doc": "Close the connection before retrying.\n\nThe supported exceptions are already checked in the\nretry object so we don't need to do it here.\n\nAfter we disconnect the connection, it will try to reconnect and\ndo a health check as part of the send_command logic(on connection level).",
              "signature": "(self, conn) -> None"
            },
            {
              "name": "_eval",
              "doc": null,
              "signature": "(self, command: str, script: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "_evalsha",
              "doc": null,
              "signature": "(self, command: str, sha: str, numkeys: int, *keys_and_args: list) -> Union[Awaitable[str], str]"
            },
            {
              "name": "_execute_command",
              "doc": "Execute a command and return a parsed response",
              "signature": "(self, *args, **options)"
            },
            {
              "name": "_fcall",
              "doc": null,
              "signature": "(self, command: str, function, numkeys: int, *keys_and_args: Any) -> Union[Awaitable[str], str]"
            },
            {
              "name": "_georadiusgeneric",
              "doc": null,
              "signature": "(self, command: str, *args: Union[bytes, bytearray, memoryview, str, int, float], **kwargs: Union[bytes, bytearray, memoryview, str, int, float, NoneType]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "_geosearchgeneric",
              "doc": null,
              "signature": "(self, command: str, *args: Union[bytes, bytearray, memoryview, str, int, float], **kwargs: Union[bytes, bytearray, memoryview, str, int, float, NoneType]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "_send_command_parse_response",
              "doc": "Send a command and parse the response",
              "signature": "(self, conn, command_name, *args, **options)"
            },
            {
              "name": "_zaggregate",
              "doc": null,
              "signature": "(self, command: str, dest: Union[bytes, str, memoryview, NoneType], keys: Union[Sequence[Union[bytes, str, memoryview]], Mapping[~AnyKeyT, float]], aggregate: Optional[str] = None, **options) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "_zrange",
              "doc": null,
              "signature": "(self, command, dest: Union[bytes, str, memoryview, NoneType], name: Union[bytes, str, memoryview], start: int, end: int, desc: bool = False, byscore: bool = False, bylex: bool = False, withscores: bool = False, score_cast_func: Union[type, Callable, NoneType] = <class 'float'>, offset: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_cat",
              "doc": "Returns a list of categories or commands within a category.\n\nIf ``category`` is not supplied, returns a list of all categories.\nIf ``category`` is supplied, returns a list of all commands within\nthat category.\n\nFor more information see https://redis.io/commands/acl-cat",
              "signature": "(self, category: Optional[str] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_deluser",
              "doc": "Delete the ACL for the specified ``username``\\s\n\nFor more information see https://redis.io/commands/acl-deluser",
              "signature": "(self, *username: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_dryrun",
              "doc": "Simulate the execution of a given command by a given ``username``.\n\nFor more information see https://redis.io/commands/acl-dryrun",
              "signature": "(self, username, *args, **kwargs)"
            },
            {
              "name": "acl_genpass",
              "doc": "Generate a random password value.\nIf ``bits`` is supplied then use this number of bits, rounded to\nthe next multiple of 4.\nSee: https://redis.io/commands/acl-genpass",
              "signature": "(self, bits: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_getuser",
              "doc": "Get the ACL details for the specified ``username``.\n\nIf ``username`` does not exist, return None\n\nFor more information see https://redis.io/commands/acl-getuser",
              "signature": "(self, username: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_help",
              "doc": "The ACL HELP command returns helpful text describing\nthe different subcommands.\n\nFor more information see https://redis.io/commands/acl-help",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_list",
              "doc": "Return a list of all ACLs on the server\n\nFor more information see https://redis.io/commands/acl-list",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_load",
              "doc": "Load ACL rules from the configured ``aclfile``.\n\nNote that the server must be configured with the ``aclfile``\ndirective to be able to load ACL rules from an aclfile.\n\nFor more information see https://redis.io/commands/acl-load",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_log",
              "doc": "Get ACL logs as a list.\n:param int count: Get logs[0:count].\n:rtype: List.\n\nFor more information see https://redis.io/commands/acl-log",
              "signature": "(self, count: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_log_reset",
              "doc": "Reset ACL logs.\n:rtype: Boolean.\n\nFor more information see https://redis.io/commands/acl-log",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_save",
              "doc": "Save ACL rules to the configured ``aclfile``.\n\nNote that the server must be configured with the ``aclfile``\ndirective to be able to save ACL rules to an aclfile.\n\nFor more information see https://redis.io/commands/acl-save",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_setuser",
              "doc": "Create or update an ACL user.\n\nCreate or update the ACL for `username`. If the user already exists,\nthe existing ACL is completely overwritten and replaced with the\nspecified values.\n\nFor more information, see https://redis.io/commands/acl-setuser\n\nArgs:\n    username: The name of the user whose ACL is to be created or updated.\n    enabled: Indicates whether the user should be allowed to authenticate.\n             Defaults to `False`.\n    nopass: Indicates whether the user can authenticate without a password.\n            This cannot be `True` if `passwords` are also specified.\n    passwords: A list of plain text passwords to add to or remove from the user.\n               Each password must be prefixed with a '+' to add or a '-' to\n               remove. For convenience, a single prefixed string can be used\n               when adding or removing a single password.\n    hashed_passwords: A list of SHA-256 hashed passwords to add to or remove\n                      from the user. Each hashed password must be prefixed with\n                      a '+' to add or a '-' to remove. For convenience, a single\n                      prefixed string can be used when adding or removing a\n                      single password.\n    categories: A list of strings representing category permissions. Each string\n                must be prefixed with either a '+' to add the category\n                permission or a '-' to remove the category permission.\n    commands: A list of strings representing command permissions. Each string\n              must be prefixed with either a '+' to add the command permission\n              or a '-' to remove the command permission.\n    keys: A list of key patterns to grant the user access to. Key patterns allow\n          ``'*'`` to support wildcard matching. For example, ``'*'`` grants\n          access to all keys while ``'cache:*'`` grants access to all keys that\n          are prefixed with ``cache:``.\n          `keys` should not be prefixed with a ``'~'``.\n    reset: Indicates whether the user should be fully reset prior to applying\n           the new ACL. Setting this to `True` will remove all existing\n           passwords, flags, and privileges from the user and then apply the\n           specified rules. If `False`, the user's existing passwords, flags,\n           and privileges will be kept and any new specified rules will be\n           applied on top.\n    reset_keys: Indicates whether the user's key permissions should be reset\n                prior to applying any new key permissions specified in `keys`.\n                If `False`, the user's existing key permissions will be kept and\n                any new specified key permissions will be applied on top.\n    reset_channels: Indicates whether the user's channel permissions should be\n                    reset prior to applying any new channel permissions\n                    specified in `channels`. If `False`, the user's existing\n                    channel permissions will be kept and any new specified\n                    channel permissions will be applied on top.\n    reset_passwords: Indicates whether to remove all existing passwords and the\n                     `nopass` flag from the user prior to applying any new\n                     passwords specified in `passwords` or `hashed_passwords`.\n                     If `False`, the user's existing passwords and `nopass`\n                     status will be kept and any new specified passwords or\n                     hashed passwords will be applied on top.",
              "signature": "(self, username: str, enabled: bool = False, nopass: bool = False, passwords: Union[str, Iterable[str], NoneType] = None, hashed_passwords: Union[str, Iterable[str], NoneType] = None, categories: Optional[Iterable[str]] = None, commands: Optional[Iterable[str]] = None, keys: Optional[Iterable[Union[bytes, str, memoryview]]] = None, channels: Optional[Iterable[Union[bytes, str, memoryview]]] = None, selectors: Optional[Iterable[Tuple[str, Union[bytes, str, memoryview]]]] = None, reset: bool = False, reset_keys: bool = False, reset_channels: bool = False, reset_passwords: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_users",
              "doc": "Returns a list of all registered users on the server.\n\nFor more information see https://redis.io/commands/acl-users",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "acl_whoami",
              "doc": "Get the username for the current connection\n\nFor more information see https://redis.io/commands/acl-whoami",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "append",
              "doc": "Appends the string ``value`` to the value at ``key``. If ``key``\ndoesn't already exist, create it with a value of ``value``.\nReturns the new length of the value at ``key``.\n\nFor more information see https://redis.io/commands/append",
              "signature": "(self, key: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "auth",
              "doc": "Authenticates the user. If you do not pass username, Redis will try to\nauthenticate for the \"default\" user. If you do pass username, it will\nauthenticate for the given user.\nFor more information see https://redis.io/commands/auth",
              "signature": "(self, password: str, username: Optional[str] = None, **kwargs)"
            },
            {
              "name": "bf",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'BFBloom'"
            },
            {
              "name": "bgrewriteaof",
              "doc": "Tell the Redis server to rewrite the AOF file from data in memory.\n\nFor more information see https://redis.io/commands/bgrewriteaof",
              "signature": "(self, **kwargs)"
            },
            {
              "name": "bgsave",
              "doc": "Tell the Redis server to save its data to disk.  Unlike save(),\nthis method is asynchronous and returns immediately.\n\nFor more information see https://redis.io/commands/bgsave",
              "signature": "(self, schedule: bool = True, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bitcount",
              "doc": "Returns the count of set bits in the value of ``key``.  Optional\n``start`` and ``end`` parameters indicate which bytes to consider\n\nFor more information see https://redis.io/commands/bitcount",
              "signature": "(self, key: Union[bytes, str, memoryview], start: Optional[int] = None, end: Optional[int] = None, mode: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bitfield",
              "doc": "Return a BitFieldOperation instance to conveniently construct one or\nmore bitfield operations on ``key``.\n\nFor more information see https://redis.io/commands/bitfield",
              "signature": "(self: Union[ForwardRef('redis.client.Redis'), ForwardRef('redis.asyncio.client.Redis')], key: Union[bytes, str, memoryview], default_overflow: Optional[str] = None) -> redis.commands.core.BitFieldOperation"
            },
            {
              "name": "bitfield_ro",
              "doc": "Return an array of the specified bitfield values\nwhere the first value is found using ``encoding`` and ``offset``\nparameters and remaining values are result of corresponding\nencoding/offset pairs in optional list ``items``\nRead-only variant of the BITFIELD command.\n\nFor more information see https://redis.io/commands/bitfield_ro",
              "signature": "(self: Union[ForwardRef('redis.client.Redis'), ForwardRef('redis.asyncio.client.Redis')], key: Union[bytes, str, memoryview], encoding: str, offset: Union[int, str], items: Optional[list] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bitop",
              "doc": "Perform a bitwise operation using ``operation`` between ``keys`` and\nstore the result in ``dest``.\n\nFor more information see https://redis.io/commands/bitop",
              "signature": "(self, operation: str, dest: Union[bytes, str, memoryview], *keys: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bitpos",
              "doc": "Return the position of the first bit set to 1 or 0 in a string.\n``start`` and ``end`` defines search range. The range is interpreted\nas a range of bytes and not a range of bits, so start=0 and end=2\nmeans to look at the first three bytes.\n\nFor more information see https://redis.io/commands/bitpos",
              "signature": "(self, key: Union[bytes, str, memoryview], bit: int, start: Optional[int] = None, end: Optional[int] = None, mode: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "blmove",
              "doc": "Blocking version of lmove.\n\nFor more information see https://redis.io/commands/blmove",
              "signature": "(self, first_list: str, second_list: str, timeout: int, src: str = 'LEFT', dest: str = 'RIGHT') -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "blmpop",
              "doc": "Pop ``count`` values (default 1) from first non-empty in the list\nof provided key names.\n\nWhen all lists are empty this command blocks the connection until another\nclient pushes to it or until the timeout, timeout of 0 blocks indefinitely\n\nFor more information see https://redis.io/commands/blmpop",
              "signature": "(self, timeout: float, numkeys: int, *args: List[str], direction: str, count: Optional[int] = 1) -> Optional[list]"
            },
            {
              "name": "blpop",
              "doc": "LPOP a value off of the first non-empty list\nnamed in the ``keys`` list.\n\nIf none of the lists in ``keys`` has a value to LPOP, then block\nfor ``timeout`` seconds, or until a value gets pushed on to one\nof the lists.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/blpop",
              "signature": "(self, keys: List, timeout: Union[int, float, NoneType] = 0) -> Union[Awaitable[list], list]"
            },
            {
              "name": "brpop",
              "doc": "RPOP a value off of the first non-empty list\nnamed in the ``keys`` list.\n\nIf none of the lists in ``keys`` has a value to RPOP, then block\nfor ``timeout`` seconds, or until a value gets pushed on to one\nof the lists.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/brpop",
              "signature": "(self, keys: List, timeout: Union[int, float, NoneType] = 0) -> Union[Awaitable[list], list]"
            },
            {
              "name": "brpoplpush",
              "doc": "Pop a value off the tail of ``src``, push it on the head of ``dst``\nand then return it.\n\nThis command blocks until a value is in ``src`` or until ``timeout``\nseconds elapse, whichever is first. A ``timeout`` value of 0 blocks\nforever.\n\nFor more information see https://redis.io/commands/brpoplpush",
              "signature": "(self, src: str, dst: str, timeout: Union[int, float, NoneType] = 0) -> Union[Awaitable[Optional[str]], str, NoneType]"
            },
            {
              "name": "bzmpop",
              "doc": "Pop ``count`` values (default 1) off of the first non-empty sorted set\nnamed in the ``keys`` list.\n\nIf none of the sorted sets in ``keys`` has a value to pop,\nthen block for ``timeout`` seconds, or until a member gets added\nto one of the sorted sets.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/bzmpop",
              "signature": "(self, timeout: float, numkeys: int, keys: List[str], min: Optional[bool] = False, max: Optional[bool] = False, count: Optional[int] = 1) -> Optional[list]"
            },
            {
              "name": "bzpopmax",
              "doc": "ZPOPMAX a value off of the first non-empty sorted set\nnamed in the ``keys`` list.\n\nIf none of the sorted sets in ``keys`` has a value to ZPOPMAX,\nthen block for ``timeout`` seconds, or until a member gets added\nto one of the sorted sets.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/bzpopmax",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], timeout: Union[int, float, bytes, str, memoryview] = 0) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "bzpopmin",
              "doc": "ZPOPMIN a value off of the first non-empty sorted set\nnamed in the ``keys`` list.\n\nIf none of the sorted sets in ``keys`` has a value to ZPOPMIN,\nthen block for ``timeout`` seconds, or until a member gets added\nto one of the sorted sets.\n\nIf timeout is 0, then block indefinitely.\n\nFor more information see https://redis.io/commands/bzpopmin",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], timeout: Union[int, float, bytes, str, memoryview] = 0) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cf",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'CFBloom'"
            },
            {
              "name": "client",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "client_getname",
              "doc": "Returns the current connection name\n\nFor more information see https://redis.io/commands/client-getname",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_getredir",
              "doc": "Returns the ID (an integer) of the client to whom we are\nredirecting tracking notifications.\n\nsee: https://redis.io/commands/client-getredir",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_id",
              "doc": "Returns the current connection id\n\nFor more information see https://redis.io/commands/client-id",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_info",
              "doc": "Returns information and statistics about the current\nclient connection.\n\nFor more information see https://redis.io/commands/client-info",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_kill",
              "doc": "Disconnects the client at ``address`` (ip:port)\n\nFor more information see https://redis.io/commands/client-kill",
              "signature": "(self, address: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_kill_filter",
              "doc": "Disconnects client(s) using a variety of filter options\n:param _id: Kills a client by its unique ID field\n:param _type: Kills a client by type where type is one of 'normal',\n'master', 'slave' or 'pubsub'\n:param addr: Kills a client by its 'address:port'\n:param skipme: If True, then the client calling the command\nwill not get killed even if it is identified by one of the filter\noptions. If skipme is not provided, the server defaults to skipme=True\n:param laddr: Kills a client by its 'local (bind) address:port'\n:param user: Kills a client for a specific user name\n:param maxage: Kills clients that are older than the specified age in seconds",
              "signature": "(self, _id: Optional[str] = None, _type: Optional[str] = None, addr: Optional[str] = None, skipme: Optional[bool] = None, laddr: Optional[bool] = None, user: Optional[str] = None, maxage: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_list",
              "doc": "Returns a list of currently connected clients.\nIf type of client specified, only that type will be returned.\n\n:param _type: optional. one of the client types (normal, master,\n replica, pubsub)\n:param client_id: optional. a list of client ids\n\nFor more information see https://redis.io/commands/client-list",
              "signature": "(self, _type: Optional[str] = None, client_id: List[Union[bytes, bytearray, memoryview, str, int, float]] = [], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_no_evict",
              "doc": "Sets the client eviction mode for the current connection.\n\nFor more information see https://redis.io/commands/client-no-evict",
              "signature": "(self, mode: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "client_no_touch",
              "doc": "# The command controls whether commands sent by the client will alter\n# the LRU/LFU of the keys they access.\n# When turned on, the current client will not change LFU/LRU stats,\n# unless it sends the TOUCH command.\n\nFor more information see https://redis.io/commands/client-no-touch",
              "signature": "(self, mode: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "client_pause",
              "doc": "Suspend all the Redis clients for the specified amount of time.\n\n\nFor more information see https://redis.io/commands/client-pause\n\nArgs:\n    timeout: milliseconds to pause clients\n    all: If true (default) all client commands are blocked.\n         otherwise, clients are only blocked if they attempt to execute\n         a write command.\n\nFor the WRITE mode, some commands have special behavior:\n\n* EVAL/EVALSHA: Will block client for all scripts.\n* PUBLISH: Will block client.\n* PFCOUNT: Will block client.\n* WAIT: Acknowledgments will be delayed, so this command will\n    appear blocked.",
              "signature": "(self, timeout: int, all: bool = True, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_reply",
              "doc": "Enable and disable redis server replies.\n\n``reply`` Must be ON OFF or SKIP,\nON - The default most with server replies to commands\nOFF - Disable server responses to commands\nSKIP - Skip the response of the immediately following command.\n\nNote: When setting OFF or SKIP replies, you will need a client object\nwith a timeout specified in seconds, and will need to catch the\nTimeoutError.\nThe test_client_reply unit test illustrates this, and\nconftest.py has a client with a timeout.\n\nSee https://redis.io/commands/client-reply",
              "signature": "(self, reply: Union[Literal['ON'], Literal['OFF'], Literal['SKIP']], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_setinfo",
              "doc": "Sets the current connection library name or version\nFor mor information see https://redis.io/commands/client-setinfo",
              "signature": "(self, attr: str, value: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_setname",
              "doc": "Sets the current connection name\n\nFor more information see https://redis.io/commands/client-setname\n\n.. note::\n   This method sets client name only for **current** connection.\n\n   If you want to set a common name for all connections managed\n   by this client, use ``client_name`` constructor argument.",
              "signature": "(self, name: str, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_tracking",
              "doc": "Enables the tracking feature of the Redis server, that is used\nfor server assisted client side caching.\n\n``on`` indicate for tracking on or tracking off. The dafualt is on.\n\n``clientid`` send invalidation messages to the connection with\nthe specified ID.\n\n``bcast`` enable tracking in broadcasting mode. In this mode\ninvalidation messages are reported for all the prefixes\nspecified, regardless of the keys requested by the connection.\n\n``optin``  when broadcasting is NOT active, normally don't track\nkeys in read only commands, unless they are called immediately\nafter a CLIENT CACHING yes command.\n\n``optout`` when broadcasting is NOT active, normally track keys in\nread only commands, unless they are called immediately after a\nCLIENT CACHING no command.\n\n``noloop`` don't send notifications about keys modified by this\nconnection itself.\n\n``prefix``  for broadcasting, register a given key prefix, so that\nnotifications will be provided only for keys starting with this string.\n\nSee https://redis.io/commands/client-tracking",
              "signature": "(self, on: bool = True, clientid: Optional[int] = None, prefix: Sequence[Union[bytes, str, memoryview]] = [], bcast: bool = False, optin: bool = False, optout: bool = False, noloop: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_tracking_off",
              "doc": "Turn off the tracking mode.\nFor more information about the options look at client_tracking func.\n\nSee https://redis.io/commands/client-tracking",
              "signature": "(self, clientid: Optional[int] = None, prefix: Sequence[Union[bytes, str, memoryview]] = [], bcast: bool = False, optin: bool = False, optout: bool = False, noloop: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_tracking_on",
              "doc": "Turn on the tracking mode.\nFor more information about the options look at client_tracking func.\n\nSee https://redis.io/commands/client-tracking",
              "signature": "(self, clientid: Optional[int] = None, prefix: Sequence[Union[bytes, str, memoryview]] = [], bcast: bool = False, optin: bool = False, optout: bool = False, noloop: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_trackinginfo",
              "doc": "Returns the information about the current client connection's\nuse of the server assisted client side cache.\n\nSee https://redis.io/commands/client-trackinginfo",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_unblock",
              "doc": "Unblocks a connection by its client id.\nIf ``error`` is True, unblocks the client with a special error message.\nIf ``error`` is False (default), the client is unblocked using the\nregular timeout mechanism.\n\nFor more information see https://redis.io/commands/client-unblock",
              "signature": "(self, client_id: int, error: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "client_unpause",
              "doc": "Unpause all redis clients\n\nFor more information see https://redis.io/commands/client-unpause",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "close",
              "doc": null,
              "signature": "(self) -> None"
            },
            {
              "name": "cluster",
              "doc": null,
              "signature": "(self, cluster_arg, *args, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "cms",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'CMSBloom'"
            },
            {
              "name": "command",
              "doc": "Returns dict reply of details about all Redis commands.\n\nFor more information see https://redis.io/commands/command",
              "signature": "(self, **kwargs)"
            },
            {
              "name": "command_count",
              "doc": null,
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "command_docs",
              "doc": "This function throws a NotImplementedError since it is intentionally\nnot supported.",
              "signature": "(self, *args)"
            },
            {
              "name": "command_getkeys",
              "doc": null,
              "signature": "(self, *args) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "command_getkeysandflags",
              "doc": "Returns array of keys from a full Redis command and their usage flags.\n\nFor more information see https://redis.io/commands/command-getkeysandflags",
              "signature": "(self, *args: List[str]) -> List[Union[str, List[str]]]"
            },
            {
              "name": "command_info",
              "doc": null,
              "signature": "(self, **kwargs) -> None"
            },
            {
              "name": "command_list",
              "doc": "Return an array of the server's command names.\nYou can use one of the following filters:\n``module``: get the commands that belong to the module\n``category``: get the commands in the ACL category\n``pattern``: get the commands that match the given pattern\n\nFor more information see https://redis.io/commands/command-list/",
              "signature": "(self, module: Optional[str] = None, category: Optional[str] = None, pattern: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "config_get",
              "doc": "Return a dictionary of configuration based on the ``pattern``\n\nFor more information see https://redis.io/commands/config-get",
              "signature": "(self, pattern: Union[bytes, str, memoryview] = '*', *args: List[Union[bytes, str, memoryview]], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "config_resetstat",
              "doc": "Reset runtime statistics\n\nFor more information see https://redis.io/commands/config-resetstat",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "config_rewrite",
              "doc": "Rewrite config file with the minimal change to reflect running config.\n\nFor more information see https://redis.io/commands/config-rewrite",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "config_set",
              "doc": "Set config item ``name`` with ``value``\n\nFor more information see https://redis.io/commands/config-set",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float], *args: List[Union[bytes, bytearray, memoryview, str, int, float]], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "copy",
              "doc": "Copy the value stored in the ``source`` key to the ``destination`` key.\n\n``destination_db`` an alternative destination database. By default,\nthe ``destination`` key is created in the source Redis database.\n\n``replace`` whether the ``destination`` key should be removed before\ncopying the value to it. By default, the value is not copied if\nthe ``destination`` key already exists.\n\nFor more information see https://redis.io/commands/copy",
              "signature": "(self, source: str, destination: str, destination_db: Optional[str] = None, replace: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "dbsize",
              "doc": "Returns the number of keys in the current database\n\nFor more information see https://redis.io/commands/dbsize",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "debug_object",
              "doc": "Returns version specific meta information about a given key\n\nFor more information see https://redis.io/commands/debug-object",
              "signature": "(self, key: Union[bytes, str, memoryview], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "debug_segfault",
              "doc": null,
              "signature": "(self, **kwargs) -> None"
            },
            {
              "name": "decr",
              "doc": "Decrements the value of ``key`` by ``amount``.  If no key exists,\nthe value will be initialized as 0 - ``amount``\n\nFor more information see https://redis.io/commands/decrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: int = 1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "decrby",
              "doc": "Decrements the value of ``key`` by ``amount``.  If no key exists,\nthe value will be initialized as 0 - ``amount``\n\nFor more information see https://redis.io/commands/decrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: int = 1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "delete",
              "doc": "Delete one or more keys specified by ``names``",
              "signature": "(self, *names: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "dump",
              "doc": "Return a serialized version of the value stored at the specified key.\nIf key does not exist a nil bulk reply is returned.\n\nFor more information see https://redis.io/commands/dump",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "echo",
              "doc": "Echo the string back from the server\n\nFor more information see https://redis.io/commands/echo",
              "signature": "(self, value: Union[bytes, bytearray, memoryview, str, int, float], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "eval",
              "doc": "Execute the Lua ``script``, specifying the ``numkeys`` the script\nwill touch and the key names and argument values in ``keys_and_args``.\nReturns the result of the script.\n\nIn practice, use the object returned by ``register_script``. This\nfunction exists purely for Redis API completion.\n\nFor more information see  https://redis.io/commands/eval",
              "signature": "(self, script: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "eval_ro",
              "doc": "The read-only variant of the EVAL command\n\nExecute the read-only Lua ``script`` specifying the ``numkeys`` the script\nwill touch and the key names and argument values in ``keys_and_args``.\nReturns the result of the script.\n\nFor more information see  https://redis.io/commands/eval_ro",
              "signature": "(self, script: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "evalsha",
              "doc": "Use the ``sha`` to execute a Lua script already registered via EVAL\nor SCRIPT LOAD. Specify the ``numkeys`` the script will touch and the\nkey names and argument values in ``keys_and_args``. Returns the result\nof the script.\n\nIn practice, use the object returned by ``register_script``. This\nfunction exists purely for Redis API completion.\n\nFor more information see  https://redis.io/commands/evalsha",
              "signature": "(self, sha: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "evalsha_ro",
              "doc": "The read-only variant of the EVALSHA command\n\nUse the ``sha`` to execute a read-only Lua script already registered via EVAL\nor SCRIPT LOAD. Specify the ``numkeys`` the script will touch and the\nkey names and argument values in ``keys_and_args``. Returns the result\nof the script.\n\nFor more information see  https://redis.io/commands/evalsha_ro",
              "signature": "(self, sha: str, numkeys: int, *keys_and_args: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "execute_command",
              "doc": null,
              "signature": "(self, *args, **options)"
            },
            {
              "name": "exists",
              "doc": "Returns the number of ``names`` that exist\n\nFor more information see https://redis.io/commands/exists",
              "signature": "(self, *names: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "expire",
              "doc": "Set an expire flag on key ``name`` for ``time`` seconds with given\n``option``. ``time`` can be represented by an integer or a Python timedelta\nobject.\n\nValid options are:\n    NX -> Set expiry only when the key has no expiry\n    XX -> Set expiry only when the key has an existing expiry\n    GT -> Set expiry only when the new expiry is greater than current one\n    LT -> Set expiry only when the new expiry is less than current one\n\nFor more information see https://redis.io/commands/expire",
              "signature": "(self, name: Union[bytes, str, memoryview], time: Union[int, datetime.timedelta], nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "expireat",
              "doc": "Set an expire flag on key ``name`` with given ``option``. ``when``\ncan be represented as an integer indicating unix time or a Python\ndatetime object.\n\nValid options are:\n    -> NX -- Set expiry only when the key has no expiry\n    -> XX -- Set expiry only when the key has an existing expiry\n    -> GT -- Set expiry only when the new expiry is greater than current one\n    -> LT -- Set expiry only when the new expiry is less than current one\n\nFor more information see https://redis.io/commands/expireat",
              "signature": "(self, name: Union[bytes, str, memoryview], when: Union[int, datetime.datetime], nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "expiretime",
              "doc": "Returns the absolute Unix timestamp (since January 1, 1970) in seconds\nat which the given key will expire.\n\nFor more information see https://redis.io/commands/expiretime",
              "signature": "(self, key: str) -> int"
            },
            {
              "name": "failover",
              "doc": "This function throws a NotImplementedError since it is intentionally\nnot supported.",
              "signature": "(self)"
            },
            {
              "name": "fcall",
              "doc": "Invoke a function.\n\nFor more information see https://redis.io/commands/fcall",
              "signature": "(self, function, numkeys: int, *keys_and_args: Any) -> Union[Awaitable[str], str]"
            },
            {
              "name": "fcall_ro",
              "doc": "This is a read-only variant of the FCALL command that cannot\nexecute commands that modify data.\n\nFor more information see https://redis.io/commands/fcall_ro",
              "signature": "(self, function, numkeys: int, *keys_and_args: Any) -> Union[Awaitable[str], str]"
            },
            {
              "name": "flushall",
              "doc": "Delete all keys in all databases on the current host.\n\n``asynchronous`` indicates whether the operation is\nexecuted asynchronously by the server.\n\nFor more information see https://redis.io/commands/flushall",
              "signature": "(self, asynchronous: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "flushdb",
              "doc": "Delete all keys in the current database.\n\n``asynchronous`` indicates whether the operation is\nexecuted asynchronously by the server.\n\nFor more information see https://redis.io/commands/flushdb",
              "signature": "(self, asynchronous: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "ft",
              "doc": "Access the search namespace, providing support for redis search.",
              "signature": "(self, index_name='idx') -> 'Search'"
            },
            {
              "name": "function_delete",
              "doc": "Delete the library called ``library`` and all its functions.\n\nFor more information see https://redis.io/commands/function-delete",
              "signature": "(self, library: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_dump",
              "doc": "Return the serialized payload of loaded libraries.\n\nFor more information see https://redis.io/commands/function-dump",
              "signature": "(self) -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_flush",
              "doc": "Deletes all the libraries.\n\nFor more information see https://redis.io/commands/function-flush",
              "signature": "(self, mode: str = 'SYNC') -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_kill",
              "doc": "Kill a function that is currently executing.\n\nFor more information see https://redis.io/commands/function-kill",
              "signature": "(self) -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_list",
              "doc": "Return information about the functions and libraries.\n\nArgs:\n\n    library: specify a pattern for matching library names\n    withcode: cause the server to include the libraries source implementation\n        in the reply",
              "signature": "(self, library: Optional[str] = '*', withcode: Optional[bool] = False) -> Union[Awaitable[List], List]"
            },
            {
              "name": "function_load",
              "doc": "Load a library to Redis.\n:param code: the source code (must start with\nShebang statement that provides a metadata about the library)\n:param replace: changes the behavior to overwrite the existing library\nwith the new contents.\nReturn the library name that was loaded.\n\nFor more information see https://redis.io/commands/function-load",
              "signature": "(self, code: str, replace: Optional[bool] = False) -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_restore",
              "doc": "Restore libraries from the serialized ``payload``.\nYou can use the optional policy argument to provide a policy\nfor handling existing libraries.\n\nFor more information see https://redis.io/commands/function-restore",
              "signature": "(self, payload: str, policy: Optional[str] = 'APPEND') -> Union[Awaitable[str], str]"
            },
            {
              "name": "function_stats",
              "doc": "Return information about the function that's currently running\nand information about the available execution engines.\n\nFor more information see https://redis.io/commands/function-stats",
              "signature": "(self) -> Union[Awaitable[List], List]"
            },
            {
              "name": "geoadd",
              "doc": "Add the specified geospatial items to the specified key identified\nby the ``name`` argument. The Geospatial items are given as ordered\nmembers of the ``values`` argument, each item or place is formed by\nthe triad longitude, latitude and name.\n\nNote: You can use ZREM to remove elements.\n\n``nx`` forces ZADD to only create new elements and not to update\nscores for elements that already exist.\n\n``xx`` forces ZADD to only update scores of elements that already\nexist. New elements will not be added.\n\n``ch`` modifies the return value to be the numbers of elements changed.\nChanged elements include new elements that were added and elements\nwhose scores changed.\n\nFor more information see https://redis.io/commands/geoadd",
              "signature": "(self, name: Union[bytes, str, memoryview], values: Sequence[Union[bytes, bytearray, memoryview, str, int, float]], nx: bool = False, xx: bool = False, ch: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geodist",
              "doc": "Return the distance between ``place1`` and ``place2`` members of the\n``name`` key.\nThe units must be one of the following : m, km mi, ft. By default\nmeters are used.\n\nFor more information see https://redis.io/commands/geodist",
              "signature": "(self, name: Union[bytes, str, memoryview], place1: Union[bytes, bytearray, memoryview, str, int, float], place2: Union[bytes, bytearray, memoryview, str, int, float], unit: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geohash",
              "doc": "Return the geo hash string for each item of ``values`` members of\nthe specified key identified by the ``name`` argument.\n\nFor more information see https://redis.io/commands/geohash",
              "signature": "(self, name: Union[bytes, str, memoryview], *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geopos",
              "doc": "Return the positions of each item of ``values`` as members of\nthe specified key identified by the ``name`` argument. Each position\nis represented by the pairs lon and lat.\n\nFor more information see https://redis.io/commands/geopos",
              "signature": "(self, name: Union[bytes, str, memoryview], *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "georadius",
              "doc": "Return the members of the specified key identified by the\n``name`` argument which are within the borders of the area specified\nwith the ``latitude`` and ``longitude`` location and the maximum\ndistance from the center specified by the ``radius`` value.\n\nThe units must be one of the following : m, km mi, ft. By default\n\n``withdist`` indicates to return the distances of each place.\n\n``withcoord`` indicates to return the latitude and longitude of\neach place.\n\n``withhash`` indicates to return the geohash string of each place.\n\n``count`` indicates to return the number of elements up to N.\n\n``sort`` indicates to return the places in a sorted way, ASC for\nnearest to fairest and DESC for fairest to nearest.\n\n``store`` indicates to save the places names in a sorted set named\nwith a specific key, each element of the destination sorted set is\npopulated with the score got from the original geo sorted set.\n\n``store_dist`` indicates to save the places names in a sorted set\nnamed with a specific key, instead of ``store`` the sorted set\ndestination score is set with the distance.\n\nFor more information see https://redis.io/commands/georadius",
              "signature": "(self, name: Union[bytes, str, memoryview], longitude: float, latitude: float, radius: float, unit: Optional[str] = None, withdist: bool = False, withcoord: bool = False, withhash: bool = False, count: Optional[int] = None, sort: Optional[str] = None, store: Union[bytes, str, memoryview, NoneType] = None, store_dist: Union[bytes, str, memoryview, NoneType] = None, any: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "georadiusbymember",
              "doc": "This command is exactly like ``georadius`` with the sole difference\nthat instead of taking, as the center of the area to query, a longitude\nand latitude value, it takes the name of a member already existing\ninside the geospatial index represented by the sorted set.\n\nFor more information see https://redis.io/commands/georadiusbymember",
              "signature": "(self, name: Union[bytes, str, memoryview], member: Union[bytes, bytearray, memoryview, str, int, float], radius: float, unit: Optional[str] = None, withdist: bool = False, withcoord: bool = False, withhash: bool = False, count: Optional[int] = None, sort: Optional[str] = None, store: Union[bytes, str, memoryview, NoneType] = None, store_dist: Union[bytes, str, memoryview, NoneType] = None, any: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geosearch",
              "doc": "Return the members of specified key identified by the\n``name`` argument, which are within the borders of the\narea specified by a given shape. This command extends the\nGEORADIUS command, so in addition to searching within circular\nareas, it supports searching within rectangular areas.\n\nThis command should be used in place of the deprecated\nGEORADIUS and GEORADIUSBYMEMBER commands.\n\n``member`` Use the position of the given existing\n member in the sorted set. Can't be given with ``longitude``\n and ``latitude``.\n\n``longitude`` and ``latitude`` Use the position given by\nthis coordinates. Can't be given with ``member``\n``radius`` Similar to GEORADIUS, search inside circular\narea according the given radius. Can't be given with\n``height`` and ``width``.\n``height`` and ``width`` Search inside an axis-aligned\nrectangle, determined by the given height and width.\nCan't be given with ``radius``\n\n``unit`` must be one of the following : m, km, mi, ft.\n`m` for meters (the default value), `km` for kilometers,\n`mi` for miles and `ft` for feet.\n\n``sort`` indicates to return the places in a sorted way,\nASC for nearest to furthest and DESC for furthest to nearest.\n\n``count`` limit the results to the first count matching items.\n\n``any`` is set to True, the command will return as soon as\nenough matches are found. Can't be provided without ``count``\n\n``withdist`` indicates to return the distances of each place.\n``withcoord`` indicates to return the latitude and longitude of\neach place.\n\n``withhash`` indicates to return the geohash string of each place.\n\nFor more information see https://redis.io/commands/geosearch",
              "signature": "(self, name: Union[bytes, str, memoryview], member: Union[bytes, bytearray, memoryview, str, int, float, NoneType] = None, longitude: Optional[float] = None, latitude: Optional[float] = None, unit: str = 'm', radius: Optional[float] = None, width: Optional[float] = None, height: Optional[float] = None, sort: Optional[str] = None, count: Optional[int] = None, any: bool = False, withcoord: bool = False, withdist: bool = False, withhash: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "geosearchstore",
              "doc": "This command is like GEOSEARCH, but stores the result in\n``dest``. By default, it stores the results in the destination\nsorted set with their geospatial information.\nif ``store_dist`` set to True, the command will stores the\nitems in a sorted set populated with their distance from the\ncenter of the circle or box, as a floating-point number.\n\nFor more information see https://redis.io/commands/geosearchstore",
              "signature": "(self, dest: Union[bytes, str, memoryview], name: Union[bytes, str, memoryview], member: Union[bytes, bytearray, memoryview, str, int, float, NoneType] = None, longitude: Optional[float] = None, latitude: Optional[float] = None, unit: str = 'm', radius: Optional[float] = None, width: Optional[float] = None, height: Optional[float] = None, sort: Optional[str] = None, count: Optional[int] = None, any: bool = False, storedist: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "get",
              "doc": "Return the value at key ``name``, or None if the key doesn't exist\n\nFor more information see https://redis.io/commands/get",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "get_cache",
              "doc": null,
              "signature": "(self) -> Optional[redis.cache.CacheInterface]"
            },
            {
              "name": "get_connection_kwargs",
              "doc": "Get the connection's key-word arguments",
              "signature": "(self) -> Dict"
            },
            {
              "name": "get_encoder",
              "doc": "Get the connection pool's encoder",
              "signature": "(self) -> 'Encoder'"
            },
            {
              "name": "get_retry",
              "doc": null,
              "signature": "(self) -> Optional[redis.retry.Retry]"
            },
            {
              "name": "getbit",
              "doc": "Returns an integer indicating the value of ``offset`` in ``name``\n\nFor more information see https://redis.io/commands/getbit",
              "signature": "(self, name: Union[bytes, str, memoryview], offset: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "getdel",
              "doc": "Get the value at key ``name`` and delete the key. This command\nis similar to GET, except for the fact that it also deletes\nthe key on success (if and only if the key's value type\nis a string).\n\nFor more information see https://redis.io/commands/getdel",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "getex",
              "doc": "Get the value of key and optionally set its expiration.\nGETEX is similar to GET, but is a write command with\nadditional options. All time parameters can be given as\ndatetime.timedelta or integers.\n\n``ex`` sets an expire flag on key ``name`` for ``ex`` seconds.\n\n``px`` sets an expire flag on key ``name`` for ``px`` milliseconds.\n\n``exat`` sets an expire flag on key ``name`` for ``ex`` seconds,\nspecified in unix time.\n\n``pxat`` sets an expire flag on key ``name`` for ``ex`` milliseconds,\nspecified in unix time.\n\n``persist`` remove the time to live associated with ``name``.\n\nFor more information see https://redis.io/commands/getex",
              "signature": "(self, name: Union[bytes, str, memoryview], ex: Union[int, datetime.timedelta, NoneType] = None, px: Union[int, datetime.timedelta, NoneType] = None, exat: Union[int, datetime.datetime, NoneType] = None, pxat: Union[int, datetime.datetime, NoneType] = None, persist: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "getrange",
              "doc": "Returns the substring of the string value stored at ``key``,\ndetermined by the offsets ``start`` and ``end`` (both are inclusive)\n\nFor more information see https://redis.io/commands/getrange",
              "signature": "(self, key: Union[bytes, str, memoryview], start: int, end: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "getset",
              "doc": "Sets the value at key ``name`` to ``value``\nand returns the old value at key ``name`` atomically.\n\nAs per Redis 6.2, GETSET is considered deprecated.\nPlease use SET with GET parameter in new code.\n\nFor more information see https://redis.io/commands/getset",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hdel",
              "doc": "Delete ``keys`` from hash ``name``\n\nFor more information see https://redis.io/commands/hdel",
              "signature": "(self, name: str, *keys: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hello",
              "doc": "This function throws a NotImplementedError since it is intentionally\nnot supported.",
              "signature": "(self)"
            },
            {
              "name": "hexists",
              "doc": "Returns a boolean indicating if ``key`` exists within hash ``name``\n\nFor more information see https://redis.io/commands/hexists",
              "signature": "(self, name: str, key: str) -> Union[Awaitable[bool], bool]"
            },
            {
              "name": "hexpire",
              "doc": "Sets or updates the expiration time for fields within a hash key, using relative\ntime in seconds.\n\nIf a field already has an expiration time, the behavior of the update can be\ncontrolled using the `nx`, `xx`, `gt`, and `lt` parameters.\n\nThe return value provides detailed information about the outcome for each field.\n\nFor more information, see https://redis.io/commands/hexpire\n\nArgs:\n    name: The name of the hash key.\n    seconds: Expiration time in seconds, relative. Can be an integer, or a\n             Python `timedelta` object.\n    fields: List of fields within the hash to apply the expiration time to.\n    nx: Set expiry only when the field has no expiry.\n    xx: Set expiry only when the field has an existing expiry.\n    gt: Set expiry only when the new expiry is greater than the current one.\n    lt: Set expiry only when the new expiry is less than the current one.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `0` if the specified NX | XX | GT | LT condition was not met.\n        - `1` if the expiration time was set or updated.\n        - `2` if the field was deleted because the specified expiration time is\n          in the past.",
              "signature": "(self, name: Union[bytes, str, memoryview], seconds: Union[int, datetime.timedelta], *fields: str, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hexpireat",
              "doc": "Sets or updates the expiration time for fields within a hash key, using an\nabsolute Unix timestamp in seconds.\n\nIf a field already has an expiration time, the behavior of the update can be\ncontrolled using the `nx`, `xx`, `gt`, and `lt` parameters.\n\nThe return value provides detailed information about the outcome for each field.\n\nFor more information, see https://redis.io/commands/hexpireat\n\nArgs:\n    name: The name of the hash key.\n    unix_time_seconds: Expiration time as Unix timestamp in seconds. Can be an\n                       integer or a Python `datetime` object.\n    fields: List of fields within the hash to apply the expiration time to.\n    nx: Set expiry only when the field has no expiry.\n    xx: Set expiry only when the field has an existing expiration time.\n    gt: Set expiry only when the new expiry is greater than the current one.\n    lt: Set expiry only when the new expiry is less than the current one.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `0` if the specified NX | XX | GT | LT condition was not met.\n        - `1` if the expiration time was set or updated.\n        - `2` if the field was deleted because the specified expiration time is\n          in the past.",
              "signature": "(self, name: Union[bytes, str, memoryview], unix_time_seconds: Union[int, datetime.datetime], *fields: str, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hexpiretime",
              "doc": "Returns the expiration times of hash fields as Unix timestamps in seconds.\n\nFor more information, see https://redis.io/commands/hexpiretime\n\nArgs:\n    key: The hash key.\n    fields: A list of fields within the hash for which to get the expiration\n            time.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expire time.\n        - A positive integer representing the expiration Unix timestamp in\n          seconds, if the field has an associated expiration time.",
              "signature": "(self, key: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hget",
              "doc": "Return the value of ``key`` within the hash ``name``\n\nFor more information see https://redis.io/commands/hget",
              "signature": "(self, name: str, key: str) -> Union[Awaitable[Optional[str]], str, NoneType]"
            },
            {
              "name": "hgetall",
              "doc": "Return a Python dict of the hash's name/value pairs\n\nFor more information see https://redis.io/commands/hgetall",
              "signature": "(self, name: str) -> Union[Awaitable[dict], dict]"
            },
            {
              "name": "hgetdel",
              "doc": "Return the value of ``key`` within the hash ``name`` and\ndelete the field in the hash.\nThis command is similar to HGET, except for the fact that it also deletes\nthe key on success from the hash with the provided ```name```.\n\nAvailable since Redis 8.0\nFor more information see https://redis.io/commands/hgetdel",
              "signature": "(self, name: str, *keys: str) -> Union[Awaitable[Optional[List[Union[str, bytes]]]], List[Union[str, bytes]], NoneType]"
            },
            {
              "name": "hgetex",
              "doc": "Return the values of ``key`` and ``keys`` within the hash ``name``\nand optionally set their expiration.\n\n``ex`` sets an expire flag on ``kyes`` for ``ex`` seconds.\n\n``px`` sets an expire flag on ``keys`` for ``px`` milliseconds.\n\n``exat`` sets an expire flag on ``keys`` for ``ex`` seconds,\nspecified in unix time.\n\n``pxat`` sets an expire flag on ``keys`` for ``ex`` milliseconds,\nspecified in unix time.\n\n``persist`` remove the time to live associated with the ``keys``.\n\nAvailable since Redis 8.0\nFor more information see https://redis.io/commands/hgetex",
              "signature": "(self, name: Union[bytes, str, memoryview], *keys: str, ex: Union[int, datetime.timedelta, NoneType] = None, px: Union[int, datetime.timedelta, NoneType] = None, exat: Union[int, datetime.datetime, NoneType] = None, pxat: Union[int, datetime.datetime, NoneType] = None, persist: bool = False) -> Union[Awaitable[Optional[List[Union[str, bytes]]]], List[Union[str, bytes]], NoneType]"
            },
            {
              "name": "hincrby",
              "doc": "Increment the value of ``key`` in hash ``name`` by ``amount``\n\nFor more information see https://redis.io/commands/hincrby",
              "signature": "(self, name: str, key: str, amount: int = 1) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hincrbyfloat",
              "doc": "Increment the value of ``key`` in hash ``name`` by floating ``amount``\n\nFor more information see https://redis.io/commands/hincrbyfloat",
              "signature": "(self, name: str, key: str, amount: float = 1.0) -> Union[Awaitable[float], float]"
            },
            {
              "name": "hkeys",
              "doc": "Return the list of keys within hash ``name``\n\nFor more information see https://redis.io/commands/hkeys",
              "signature": "(self, name: str) -> Union[Awaitable[List], List]"
            },
            {
              "name": "hlen",
              "doc": "Return the number of elements in hash ``name``\n\nFor more information see https://redis.io/commands/hlen",
              "signature": "(self, name: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hmget",
              "doc": "Returns a list of values ordered identically to ``keys``\n\nFor more information see https://redis.io/commands/hmget",
              "signature": "(self, name: str, keys: List, *args: List) -> Union[Awaitable[List], List]"
            },
            {
              "name": "hmset",
              "doc": "Set key to value within hash ``name`` for each corresponding\nkey and value from the ``mapping`` dict.\n\nFor more information see https://redis.io/commands/hmset",
              "signature": "(self, name: str, mapping: dict) -> Union[Awaitable[str], str]"
            },
            {
              "name": "hpersist",
              "doc": "Removes the expiration time for each specified field in a hash.\n\nFor more information, see https://redis.io/commands/hpersist\n\nArgs:\n    name: The name of the hash key.\n    fields: A list of fields within the hash from which to remove the\n            expiration time.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expiration time.\n        - `1` if the expiration time was successfully removed from the field.",
              "signature": "(self, name: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hpexpire",
              "doc": "Sets or updates the expiration time for fields within a hash key, using relative\ntime in milliseconds.\n\nIf a field already has an expiration time, the behavior of the update can be\ncontrolled using the `nx`, `xx`, `gt`, and `lt` parameters.\n\nThe return value provides detailed information about the outcome for each field.\n\nFor more information, see https://redis.io/commands/hpexpire\n\nArgs:\n    name: The name of the hash key.\n    milliseconds: Expiration time in milliseconds, relative. Can be an integer,\n                  or a Python `timedelta` object.\n    fields: List of fields within the hash to apply the expiration time to.\n    nx: Set expiry only when the field has no expiry.\n    xx: Set expiry only when the field has an existing expiry.\n    gt: Set expiry only when the new expiry is greater than the current one.\n    lt: Set expiry only when the new expiry is less than the current one.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `0` if the specified NX | XX | GT | LT condition was not met.\n        - `1` if the expiration time was set or updated.\n        - `2` if the field was deleted because the specified expiration time is\n          in the past.",
              "signature": "(self, name: Union[bytes, str, memoryview], milliseconds: Union[int, datetime.timedelta], *fields: str, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hpexpireat",
              "doc": "Sets or updates the expiration time for fields within a hash key, using an\nabsolute Unix timestamp in milliseconds.\n\nIf a field already has an expiration time, the behavior of the update can be\ncontrolled using the `nx`, `xx`, `gt`, and `lt` parameters.\n\nThe return value provides detailed information about the outcome for each field.\n\nFor more information, see https://redis.io/commands/hpexpireat\n\nArgs:\n    name: The name of the hash key.\n    unix_time_milliseconds: Expiration time as Unix timestamp in milliseconds.\n                            Can be an integer or a Python `datetime` object.\n    fields: List of fields within the hash to apply the expiry.\n    nx: Set expiry only when the field has no expiry.\n    xx: Set expiry only when the field has an existing expiry.\n    gt: Set expiry only when the new expiry is greater than the current one.\n    lt: Set expiry only when the new expiry is less than the current one.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `0` if the specified NX | XX | GT | LT condition was not met.\n        - `1` if the expiration time was set or updated.\n        - `2` if the field was deleted because the specified expiration time is\n          in the past.",
              "signature": "(self, name: Union[bytes, str, memoryview], unix_time_milliseconds: Union[int, datetime.datetime], *fields: str, nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hpexpiretime",
              "doc": "Returns the expiration times of hash fields as Unix timestamps in milliseconds.\n\nFor more information, see https://redis.io/commands/hpexpiretime\n\nArgs:\n    key: The hash key.\n    fields: A list of fields within the hash for which to get the expiration\n            time.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expire time.\n        - A positive integer representing the expiration Unix timestamp in\n          milliseconds, if the field has an associated expiration time.",
              "signature": "(self, key: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hpttl",
              "doc": "Returns the TTL (Time To Live) in milliseconds for each specified field within a\nhash key.\n\nFor more information, see https://redis.io/commands/hpttl\n\nArgs:\n    key: The hash key.\n    fields: A list of fields within the hash for which to get the TTL.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expire time.\n        - A positive integer representing the TTL in milliseconds if the field\n          has an associated expiration time.",
              "signature": "(self, key: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hrandfield",
              "doc": "Return a random field from the hash value stored at key.\n\ncount: if the argument is positive, return an array of distinct fields.\nIf called with a negative count, the behavior changes and the command\nis allowed to return the same field multiple times. In this case,\nthe number of returned fields is the absolute value of the\nspecified count.\nwithvalues: The optional WITHVALUES modifier changes the reply so it\nincludes the respective values of the randomly selected hash fields.\n\nFor more information see https://redis.io/commands/hrandfield",
              "signature": "(self, key: str, count: Optional[int] = None, withvalues: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hscan",
              "doc": "Incrementally return key/value slices in a hash. Also return a cursor\nindicating the scan position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\n``no_values`` indicates to return only the keys, without values.\n\nFor more information see https://redis.io/commands/hscan",
              "signature": "(self, name: Union[bytes, str, memoryview], cursor: int = 0, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, no_values: Optional[bool] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hscan_iter",
              "doc": "Make an iterator using the HSCAN command so that the client doesn't\nneed to remember the cursor position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\n``no_values`` indicates to return only the keys, without values",
              "signature": "(self, name: str, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, no_values: Optional[bool] = None) -> Iterator"
            },
            {
              "name": "hset",
              "doc": "Set ``key`` to ``value`` within hash ``name``,\n``mapping`` accepts a dict of key/value pairs that will be\nadded to hash ``name``.\n``items`` accepts a list of key/value pairs that will be\nadded to hash ``name``.\nReturns the number of fields that were added.\n\nFor more information see https://redis.io/commands/hset",
              "signature": "(self, name: str, key: Optional[str] = None, value: Optional[str] = None, mapping: Optional[dict] = None, items: Optional[list] = None) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hsetex",
              "doc": "Set ``key`` to ``value`` within hash ``name``\n\n``mapping`` accepts a dict of key/value pairs that will be\nadded to hash ``name``.\n\n``items`` accepts a list of key/value pairs that will be\nadded to hash ``name``.\n\n``ex`` sets an expire flag on ``keys`` for ``ex`` seconds.\n\n``px`` sets an expire flag on ``keys`` for ``px`` milliseconds.\n\n``exat`` sets an expire flag on ``keys`` for ``ex`` seconds,\n    specified in unix time.\n\n``pxat`` sets an expire flag on ``keys`` for ``ex`` milliseconds,\n    specified in unix time.\n\n``data_persist_option`` can be set to ``FNX`` or ``FXX`` to control the\n    behavior of the command.\n    ``FNX`` will set the value for each provided key to each\n        provided value only if all do not already exist.\n    ``FXX`` will set the value for each provided key to each\n        provided value only if all already exist.\n\n``keepttl`` if True, retain the time to live associated with the keys.\n\nReturns the number of fields that were added.\n\nAvailable since Redis 8.0\nFor more information see https://redis.io/commands/hsetex",
              "signature": "(self, name: str, key: Optional[str] = None, value: Optional[str] = None, mapping: Optional[dict] = None, items: Optional[list] = None, ex: Union[int, datetime.timedelta, NoneType] = None, px: Union[int, datetime.timedelta, NoneType] = None, exat: Union[int, datetime.datetime, NoneType] = None, pxat: Union[int, datetime.datetime, NoneType] = None, data_persist_option: Optional[redis.commands.core.HashDataPersistOptions] = None, keepttl: bool = False) -> Union[Awaitable[int], int]"
            },
            {
              "name": "hsetnx",
              "doc": "Set ``key`` to ``value`` within hash ``name`` if ``key`` does not\nexist.  Returns 1 if HSETNX created a field, otherwise 0.\n\nFor more information see https://redis.io/commands/hsetnx",
              "signature": "(self, name: str, key: str, value: str) -> Union[Awaitable[bool], bool]"
            },
            {
              "name": "hstrlen",
              "doc": "Return the number of bytes stored in the value of ``key``\nwithin hash ``name``\n\nFor more information see https://redis.io/commands/hstrlen",
              "signature": "(self, name: str, key: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "httl",
              "doc": "Returns the TTL (Time To Live) in seconds for each specified field within a hash\nkey.\n\nFor more information, see https://redis.io/commands/httl\n\nArgs:\n    key: The hash key.\n    fields: A list of fields within the hash for which to get the TTL.\n\nReturns:\n    Returns a list which contains for each field in the request:\n        - `-2` if the field does not exist, or if the key does not exist.\n        - `-1` if the field exists but has no associated expire time.\n        - A positive integer representing the TTL in seconds if the field has\n          an associated expiration time.",
              "signature": "(self, key: Union[bytes, str, memoryview], *fields: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "hvals",
              "doc": "Return the list of values within hash ``name``\n\nFor more information see https://redis.io/commands/hvals",
              "signature": "(self, name: str) -> Union[Awaitable[List], List]"
            },
            {
              "name": "incr",
              "doc": "Increments the value of ``key`` by ``amount``.  If no key exists,\nthe value will be initialized as ``amount``\n\nFor more information see https://redis.io/commands/incrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: int = 1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "incrby",
              "doc": "Increments the value of ``key`` by ``amount``.  If no key exists,\nthe value will be initialized as ``amount``\n\nFor more information see https://redis.io/commands/incrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: int = 1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "incrbyfloat",
              "doc": "Increments the value at key ``name`` by floating ``amount``.\nIf no key exists, the value will be initialized as ``amount``\n\nFor more information see https://redis.io/commands/incrbyfloat",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: float = 1.0) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "info",
              "doc": "Returns a dictionary containing information about the Redis server\n\nThe ``section`` option can be used to select a specific section\nof information\n\nThe section option is not supported by older versions of Redis Server,\nand will generate ResponseError\n\nFor more information see https://redis.io/commands/info",
              "signature": "(self, section: Optional[str] = None, *args: List[str], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "json",
              "doc": "Access the json namespace, providing support for redis json.",
              "signature": "(self, encoder=<json.encoder.JSONEncoder object at 0x0000023EF6E34C90>, decoder=<json.decoder.JSONDecoder object at 0x0000023EF6E34B90>) -> 'JSON'"
            },
            {
              "name": "keys",
              "doc": "Returns a list of keys matching ``pattern``\n\nFor more information see https://redis.io/commands/keys",
              "signature": "(self, pattern: Union[bytes, str, memoryview] = '*', **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "lastsave",
              "doc": "Return a Python datetime object representing the last time the\nRedis database was saved to disk\n\nFor more information see https://redis.io/commands/lastsave",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "latency_doctor",
              "doc": "Raise a NotImplementedError, as the client will not support LATENCY DOCTOR.\nThis funcion is best used within the redis-cli.\n\nFor more information see https://redis.io/commands/latency-doctor",
              "signature": "(self)"
            },
            {
              "name": "latency_graph",
              "doc": "Raise a NotImplementedError, as the client will not support LATENCY GRAPH.\nThis funcion is best used within the redis-cli.\n\nFor more information see https://redis.io/commands/latency-graph.",
              "signature": "(self)"
            },
            {
              "name": "latency_histogram",
              "doc": "This function throws a NotImplementedError since it is intentionally\nnot supported.",
              "signature": "(self, *args)"
            },
            {
              "name": "latency_history",
              "doc": "Returns the raw data of the ``event``'s latency spikes time series.\n\nFor more information see https://redis.io/commands/latency-history",
              "signature": "(self, event: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "latency_latest",
              "doc": "Reports the latest latency events logged.\n\nFor more information see https://redis.io/commands/latency-latest",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "latency_reset",
              "doc": "Resets the latency spikes time series of all, or only some, events.\n\nFor more information see https://redis.io/commands/latency-reset",
              "signature": "(self, *events: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "lcs",
              "doc": "Find the longest common subsequence between ``key1`` and ``key2``.\nIf ``len`` is true the length of the match will will be returned.\nIf ``idx`` is true the match position in each strings will be returned.\n``minmatchlen`` restrict the list of matches to the ones of\nthe given ``minmatchlen``.\nIf ``withmatchlen`` the length of the match also will be returned.\nFor more information see https://redis.io/commands/lcs",
              "signature": "(self, key1: str, key2: str, len: Optional[bool] = False, idx: Optional[bool] = False, minmatchlen: Optional[int] = 0, withmatchlen: Optional[bool] = False) -> Union[str, int, list]"
            },
            {
              "name": "lindex",
              "doc": "Return the item from list ``name`` at position ``index``\n\nNegative indexes are supported and will return an item at the\nend of the list\n\nFor more information see https://redis.io/commands/lindex",
              "signature": "(self, name: str, index: int) -> Union[Awaitable[Optional[str]], str, NoneType]"
            },
            {
              "name": "linsert",
              "doc": "Insert ``value`` in list ``name`` either immediately before or after\n[``where``] ``refvalue``\n\nReturns the new length of the list on success or -1 if ``refvalue``\nis not in the list.\n\nFor more information see https://redis.io/commands/linsert",
              "signature": "(self, name: str, where: str, refvalue: str, value: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "llen",
              "doc": "Return the length of the list ``name``\n\nFor more information see https://redis.io/commands/llen",
              "signature": "(self, name: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "lmove",
              "doc": "Atomically returns and removes the first/last element of a list,\npushing it as the first/last element on the destination list.\nReturns the element being popped and pushed.\n\nFor more information see https://redis.io/commands/lmove",
              "signature": "(self, first_list: str, second_list: str, src: str = 'LEFT', dest: str = 'RIGHT') -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "lmpop",
              "doc": "Pop ``count`` values (default 1) first non-empty list key from the list\nof args provided key names.\n\nFor more information see https://redis.io/commands/lmpop",
              "signature": "(self, num_keys: int, *args: List[str], direction: str, count: Optional[int] = 1) -> Union[Awaitable[list], list]"
            },
            {
              "name": "load_external_module",
              "doc": "This function can be used to add externally defined redis modules,\nand their namespaces to the redis client.\n\nfuncname - A string containing the name of the function to create\nfunc - The function, being added to this class.\n\nex: Assume that one has a custom redis module named foomod that\ncreates command named 'foo.dothing' and 'foo.anotherthing' in redis.\nTo load function functions into this namespace:\n\nfrom redis import Redis\nfrom foomodule import F\nr = Redis()\nr.load_external_module(\"foo\", F)\nr.foo().dothing('your', 'arguments')\n\nFor a concrete example see the reimport of the redisjson module in\ntests/test_connection.py::test_loading_external_modules",
              "signature": "(self, funcname, func) -> None"
            },
            {
              "name": "lock",
              "doc": "Return a new Lock object using key ``name`` that mimics\nthe behavior of threading.Lock.\n\nIf specified, ``timeout`` indicates a maximum life for the lock.\nBy default, it will remain locked until release() is called.\n\n``sleep`` indicates the amount of time to sleep per loop iteration\nwhen the lock is in blocking mode and another client is currently\nholding the lock.\n\n``blocking`` indicates whether calling ``acquire`` should block until\nthe lock has been acquired or to fail immediately, causing ``acquire``\nto return False and the lock not being acquired. Defaults to True.\nNote this value can be overridden by passing a ``blocking``\nargument to ``acquire``.\n\n``blocking_timeout`` indicates the maximum amount of time in seconds to\nspend trying to acquire the lock. A value of ``None`` indicates\ncontinue trying forever. ``blocking_timeout`` can be specified as a\nfloat or integer, both representing the number of seconds to wait.\n\n``lock_class`` forces the specified lock implementation. Note that as\nof redis-py 3.0, the only lock class we implement is ``Lock`` (which is\na Lua-based lock). So, it's unlikely you'll need this parameter, unless\nyou have created your own custom lock class.\n\n``thread_local`` indicates whether the lock token is placed in\nthread-local storage. By default, the token is placed in thread local\nstorage so that a thread only sees its token, not a token set by\nanother thread. Consider the following timeline:\n\n    time: 0, thread-1 acquires `my-lock`, with a timeout of 5 seconds.\n             thread-1 sets the token to \"abc\"\n    time: 1, thread-2 blocks trying to acquire `my-lock` using the\n             Lock instance.\n    time: 5, thread-1 has not yet completed. redis expires the lock\n             key.\n    time: 5, thread-2 acquired `my-lock` now that it's available.\n             thread-2 sets the token to \"xyz\"\n    time: 6, thread-1 finishes its work and calls release(). if the\n             token is *not* stored in thread local storage, then\n             thread-1 would see the token value as \"xyz\" and would be\n             able to successfully release the thread-2's lock.\n\n``raise_on_release_error`` indicates whether to raise an exception when\nthe lock is no longer owned when exiting the context manager. By default,\nthis is True, meaning an exception will be raised. If False, the warning\nwill be logged and the exception will be suppressed.\n\nIn some use cases it's necessary to disable thread local storage. For\nexample, if you have code where one thread acquires a lock and passes\nthat lock instance to a worker thread to release later. If thread\nlocal storage isn't disabled in this case, the worker thread won't see\nthe token set by the thread that acquired the lock. Our assumption\nis that these cases aren't common and as such default to using\nthread local storage.",
              "signature": "(self, name: str, timeout: Optional[float] = None, sleep: float = 0.1, blocking: bool = True, blocking_timeout: Optional[float] = None, lock_class: Optional[Any] = None, thread_local: bool = True, raise_on_release_error: bool = True)"
            },
            {
              "name": "lolwut",
              "doc": "Get the Redis version and a piece of generative computer art\n\nSee: https://redis.io/commands/lolwut",
              "signature": "(self, *version_numbers: Union[str, float], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "lpop",
              "doc": "Removes and returns the first elements of the list ``name``.\n\nBy default, the command pops a single element from the beginning of\nthe list. When provided with the optional ``count`` argument, the reply\nwill consist of up to count elements, depending on the list's length.\n\nFor more information see https://redis.io/commands/lpop",
              "signature": "(self, name: str, count: Optional[int] = None) -> Union[Awaitable[Union[str, List, NoneType]], str, List, NoneType]"
            },
            {
              "name": "lpos",
              "doc": "Get position of ``value`` within the list ``name``\n\n If specified, ``rank`` indicates the \"rank\" of the first element to\n return in case there are multiple copies of ``value`` in the list.\n By default, LPOS returns the position of the first occurrence of\n ``value`` in the list. When ``rank`` 2, LPOS returns the position of\n the second ``value`` in the list. If ``rank`` is negative, LPOS\n searches the list in reverse. For example, -1 would return the\n position of the last occurrence of ``value`` and -2 would return the\n position of the next to last occurrence of ``value``.\n\n If specified, ``count`` indicates that LPOS should return a list of\n up to ``count`` positions. A ``count`` of 2 would return a list of\n up to 2 positions. A ``count`` of 0 returns a list of all positions\n matching ``value``. When ``count`` is specified and but ``value``\n does not exist in the list, an empty list is returned.\n\n If specified, ``maxlen`` indicates the maximum number of list\n elements to scan. A ``maxlen`` of 1000 will only return the\n position(s) of items within the first 1000 entries in the list.\n A ``maxlen`` of 0 (the default) will scan the entire list.\n\n For more information see https://redis.io/commands/lpos",
              "signature": "(self, name: str, value: str, rank: Optional[int] = None, count: Optional[int] = None, maxlen: Optional[int] = None) -> Union[str, List, NoneType]"
            },
            {
              "name": "lpush",
              "doc": "Push ``values`` onto the head of the list ``name``\n\nFor more information see https://redis.io/commands/lpush",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "lpushx",
              "doc": "Push ``value`` onto the head of the list ``name`` if ``name`` exists\n\nFor more information see https://redis.io/commands/lpushx",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "lrange",
              "doc": "Return a slice of the list ``name`` between\nposition ``start`` and ``end``\n\n``start`` and ``end`` can be negative numbers just like\nPython slicing notation\n\nFor more information see https://redis.io/commands/lrange",
              "signature": "(self, name: str, start: int, end: int) -> Union[Awaitable[list], list]"
            },
            {
              "name": "lrem",
              "doc": "Remove the first ``count`` occurrences of elements equal to ``value``\nfrom the list stored at ``name``.\n\nThe count argument influences the operation in the following ways:\n    count > 0: Remove elements equal to value moving from head to tail.\n    count < 0: Remove elements equal to value moving from tail to head.\n    count = 0: Remove all elements equal to value.\n\n    For more information see https://redis.io/commands/lrem",
              "signature": "(self, name: str, count: int, value: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "lset",
              "doc": "Set element at ``index`` of list ``name`` to ``value``\n\nFor more information see https://redis.io/commands/lset",
              "signature": "(self, name: str, index: int, value: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "ltrim",
              "doc": "Trim the list ``name``, removing all values not within the slice\nbetween ``start`` and ``end``\n\n``start`` and ``end`` can be negative numbers just like\nPython slicing notation\n\nFor more information see https://redis.io/commands/ltrim",
              "signature": "(self, name: str, start: int, end: int) -> Union[Awaitable[str], str]"
            },
            {
              "name": "memory_doctor",
              "doc": null,
              "signature": "(self, **kwargs) -> None"
            },
            {
              "name": "memory_help",
              "doc": null,
              "signature": "(self, **kwargs) -> None"
            },
            {
              "name": "memory_malloc_stats",
              "doc": "Return an internal statistics report from the memory allocator.\n\nSee: https://redis.io/commands/memory-malloc-stats",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "memory_purge",
              "doc": "Attempts to purge dirty pages for reclamation by allocator\n\nFor more information see https://redis.io/commands/memory-purge",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "memory_stats",
              "doc": "Return a dictionary of memory stats\n\nFor more information see https://redis.io/commands/memory-stats",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "memory_usage",
              "doc": "Return the total memory usage for key, its value and associated\nadministrative overheads.\n\nFor nested data structures, ``samples`` is the number of elements to\nsample. If left unspecified, the server's default is 5. Use 0 to sample\nall elements.\n\nFor more information see https://redis.io/commands/memory-usage",
              "signature": "(self, key: Union[bytes, str, memoryview], samples: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "mget",
              "doc": "Returns a list of values ordered identically to ``keys``\n\nFor more information see https://redis.io/commands/mget",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], *args: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "migrate",
              "doc": "Migrate 1 or more keys from the current Redis server to a different\nserver specified by the ``host``, ``port`` and ``destination_db``.\n\nThe ``timeout``, specified in milliseconds, indicates the maximum\ntime the connection between the two servers can be idle before the\ncommand is interrupted.\n\nIf ``copy`` is True, the specified ``keys`` are NOT deleted from\nthe source server.\n\nIf ``replace`` is True, this operation will overwrite the keys\non the destination server if they exist.\n\nIf ``auth`` is specified, authenticate to the destination server with\nthe password provided.\n\nFor more information see https://redis.io/commands/migrate",
              "signature": "(self, host: str, port: int, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], destination_db: int, timeout: int, copy: bool = False, replace: bool = False, auth: Optional[str] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "module_list",
              "doc": "Returns a list of dictionaries containing the name and version of\nall loaded modules.\n\nFor more information see https://redis.io/commands/module-list",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "module_load",
              "doc": "Loads the module from ``path``.\nPasses all ``*args`` to the module, during loading.\nRaises ``ModuleError`` if a module is not found at ``path``.\n\nFor more information see https://redis.io/commands/module-load",
              "signature": "(self, path, *args) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "module_loadex",
              "doc": "Loads a module from a dynamic library at runtime with configuration directives.\n\nFor more information see https://redis.io/commands/module-loadex",
              "signature": "(self, path: str, options: Optional[List[str]] = None, args: Optional[List[str]] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "module_unload",
              "doc": "Unloads the module ``name``.\nRaises ``ModuleError`` if ``name`` is not in loaded modules.\n\nFor more information see https://redis.io/commands/module-unload",
              "signature": "(self, name) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "monitor",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "move",
              "doc": "Moves the key ``name`` to a different Redis database ``db``\n\nFor more information see https://redis.io/commands/move",
              "signature": "(self, name: Union[bytes, str, memoryview], db: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "mset",
              "doc": "Sets key/values based on a mapping. Mapping is a dictionary of\nkey/value pairs. Both keys and values should be strings or types that\ncan be cast to a string via str().\n\nFor more information see https://redis.io/commands/mset",
              "signature": "(self, mapping: Mapping[~AnyKeyT, Union[bytes, bytearray, memoryview, str, int, float]]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "msetnx",
              "doc": "Sets key/values based on a mapping if none of the keys are already set.\nMapping is a dictionary of key/value pairs. Both keys and values\nshould be strings or types that can be cast to a string via str().\nReturns a boolean indicating if the operation was successful.\n\nFor more information see https://redis.io/commands/msetnx",
              "signature": "(self, mapping: Mapping[~AnyKeyT, Union[bytes, bytearray, memoryview, str, int, float]]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "object",
              "doc": "Return the encoding, idletime, or refcount about the key",
              "signature": "(self, infotype: str, key: Union[bytes, str, memoryview], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "parse_response",
              "doc": "Parses a response from the Redis server",
              "signature": "(self, connection, command_name, **options)"
            },
            {
              "name": "persist",
              "doc": "Removes an expiration on ``name``\n\nFor more information see https://redis.io/commands/persist",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pexpire",
              "doc": "Set an expire flag on key ``name`` for ``time`` milliseconds\nwith given ``option``. ``time`` can be represented by an\ninteger or a Python timedelta object.\n\nValid options are:\n    NX -> Set expiry only when the key has no expiry\n    XX -> Set expiry only when the key has an existing expiry\n    GT -> Set expiry only when the new expiry is greater than current one\n    LT -> Set expiry only when the new expiry is less than current one\n\nFor more information see https://redis.io/commands/pexpire",
              "signature": "(self, name: Union[bytes, str, memoryview], time: Union[int, datetime.timedelta], nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pexpireat",
              "doc": "Set an expire flag on key ``name`` with given ``option``. ``when``\ncan be represented as an integer representing unix time in\nmilliseconds (unix time * 1000) or a Python datetime object.\n\nValid options are:\n    NX -> Set expiry only when the key has no expiry\n    XX -> Set expiry only when the key has an existing expiry\n    GT -> Set expiry only when the new expiry is greater than current one\n    LT -> Set expiry only when the new expiry is less than current one\n\nFor more information see https://redis.io/commands/pexpireat",
              "signature": "(self, name: Union[bytes, str, memoryview], when: Union[int, datetime.datetime], nx: bool = False, xx: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pexpiretime",
              "doc": "Returns the absolute Unix timestamp (since January 1, 1970) in milliseconds\nat which the given key will expire.\n\nFor more information see https://redis.io/commands/pexpiretime",
              "signature": "(self, key: str) -> int"
            },
            {
              "name": "pfadd",
              "doc": "Adds the specified elements to the specified HyperLogLog.\n\nFor more information see https://redis.io/commands/pfadd",
              "signature": "(self, name: Union[bytes, str, memoryview], *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pfcount",
              "doc": "Return the approximated cardinality of\nthe set observed by the HyperLogLog at key(s).\n\nFor more information see https://redis.io/commands/pfcount",
              "signature": "(self, *sources: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pfmerge",
              "doc": "Merge N different HyperLogLogs into a single one.\n\nFor more information see https://redis.io/commands/pfmerge",
              "signature": "(self, dest: Union[bytes, str, memoryview], *sources: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "ping",
              "doc": "Ping the Redis server\n\nFor more information see https://redis.io/commands/ping",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pipeline",
              "doc": "Return a new pipeline object that can queue multiple commands for\nlater execution. ``transaction`` indicates whether all commands\nshould be executed atomically. Apart from making a group of operations\natomic, pipelines are useful for reducing the back-and-forth overhead\nbetween the client and server.",
              "signature": "(self, transaction=True, shard_hint=None) -> 'Pipeline'"
            },
            {
              "name": "psetex",
              "doc": "Set the value of key ``name`` to ``value`` that expires in ``time_ms``\nmilliseconds. ``time_ms`` can be represented by an integer or a Python\ntimedelta object\n\nFor more information see https://redis.io/commands/psetex",
              "signature": "(self, name: Union[bytes, str, memoryview], time_ms: Union[int, datetime.timedelta], value: Union[bytes, bytearray, memoryview, str, int, float])"
            },
            {
              "name": "psync",
              "doc": "Initiates a replication stream from the master.\nNewer version for `sync`.\n\nFor more information see https://redis.io/commands/sync",
              "signature": "(self, replicationid: str, offset: int)"
            },
            {
              "name": "pttl",
              "doc": "Returns the number of milliseconds until the key ``name`` will expire\n\nFor more information see https://redis.io/commands/pttl",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "publish",
              "doc": "Publish ``message`` on ``channel``.\nReturns the number of subscribers the message was delivered to.\n\nFor more information see https://redis.io/commands/publish",
              "signature": "(self, channel: Union[bytes, str, memoryview], message: Union[bytes, bytearray, memoryview, str, int, float], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub",
              "doc": "Return a Publish/Subscribe object. With this object, you can\nsubscribe to channels and listen for messages that get published to\nthem.",
              "signature": "(self, **kwargs)"
            },
            {
              "name": "pubsub_channels",
              "doc": "Return a list of channels that have at least one subscriber\n\nFor more information see https://redis.io/commands/pubsub-channels",
              "signature": "(self, pattern: Union[bytes, str, memoryview] = '*', **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub_numpat",
              "doc": "Returns the number of subscriptions to patterns\n\nFor more information see https://redis.io/commands/pubsub-numpat",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub_numsub",
              "doc": "Return a list of (channel, number of subscribers) tuples\nfor each channel given in ``*args``\n\nFor more information see https://redis.io/commands/pubsub-numsub",
              "signature": "(self, *args: Union[bytes, str, memoryview], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub_shardchannels",
              "doc": "Return a list of shard_channels that have at least one subscriber\n\nFor more information see https://redis.io/commands/pubsub-shardchannels",
              "signature": "(self, pattern: Union[bytes, str, memoryview] = '*', **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "pubsub_shardnumsub",
              "doc": "Return a list of (shard_channel, number of subscribers) tuples\nfor each channel given in ``*args``\n\nFor more information see https://redis.io/commands/pubsub-shardnumsub",
              "signature": "(self, *args: Union[bytes, str, memoryview], **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "quit",
              "doc": "Ask the server to close the connection.\n\nFor more information see https://redis.io/commands/quit",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "randomkey",
              "doc": "Returns the name of a random key\n\nFor more information see https://redis.io/commands/randomkey",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "readonly",
              "doc": "Enables read queries for a connection to a Redis Cluster replica node.\n\nFor more information see https://redis.io/commands/readonly",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "readwrite",
              "doc": "Disables read queries for a connection to a Redis Cluster slave node.\n\nFor more information see https://redis.io/commands/readwrite",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "register_script",
              "doc": "Register a Lua ``script`` specifying the ``keys`` it will touch.\nReturns a Script object that is callable and hides the complexity of\ndeal with scripts, keys, and shas. This is the preferred way to work\nwith Lua scripts.",
              "signature": "(self: 'redis.client.Redis', script: Union[bytes, str, memoryview]) -> redis.commands.core.Script"
            },
            {
              "name": "rename",
              "doc": "Rename key ``src`` to ``dst``\n\nFor more information see https://redis.io/commands/rename",
              "signature": "(self, src: Union[bytes, str, memoryview], dst: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "renamenx",
              "doc": "Rename key ``src`` to ``dst`` if ``dst`` doesn't already exist\n\nFor more information see https://redis.io/commands/renamenx",
              "signature": "(self, src: Union[bytes, str, memoryview], dst: Union[bytes, str, memoryview])"
            },
            {
              "name": "replicaof",
              "doc": "Update the replication settings of a redis replica, on the fly.\n\nExamples of valid arguments include:\n\nNO ONE (set no replication)\nhost port (set to the host and port of a redis server)\n\nFor more information see  https://redis.io/commands/replicaof",
              "signature": "(self, *args, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "reset",
              "doc": "Perform a full reset on the connection's server side contenxt.\n\nSee: https://redis.io/commands/reset",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "restore",
              "doc": "Create a key using the provided serialized value, previously obtained\nusing DUMP.\n\n``replace`` allows an existing key on ``name`` to be overridden. If\nit's not specified an error is raised on collision.\n\n``absttl`` if True, specified ``ttl`` should represent an absolute Unix\ntimestamp in milliseconds in which the key will expire. (Redis 5.0 or\ngreater).\n\n``idletime`` Used for eviction, this is the number of seconds the\nkey must be idle, prior to execution.\n\n``frequency`` Used for eviction, this is the frequency counter of\nthe object stored at the key, prior to execution.\n\nFor more information see https://redis.io/commands/restore",
              "signature": "(self, name: Union[bytes, str, memoryview], ttl: float, value: Union[bytes, bytearray, memoryview, str, int, float], replace: bool = False, absttl: bool = False, idletime: Optional[int] = None, frequency: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "role",
              "doc": "Provide information on the role of a Redis instance in\nthe context of replication, by returning if the instance\nis currently a master, slave, or sentinel.\n\nFor more information see https://redis.io/commands/role",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "rpop",
              "doc": "Removes and returns the last elements of the list ``name``.\n\nBy default, the command pops a single element from the end of the list.\nWhen provided with the optional ``count`` argument, the reply will\nconsist of up to count elements, depending on the list's length.\n\nFor more information see https://redis.io/commands/rpop",
              "signature": "(self, name: str, count: Optional[int] = None) -> Union[Awaitable[Union[str, List, NoneType]], str, List, NoneType]"
            },
            {
              "name": "rpoplpush",
              "doc": "RPOP a value off of the ``src`` list and atomically LPUSH it\non to the ``dst`` list.  Returns the value.\n\nFor more information see https://redis.io/commands/rpoplpush",
              "signature": "(self, src: str, dst: str) -> Union[Awaitable[str], str]"
            },
            {
              "name": "rpush",
              "doc": "Push ``values`` onto the tail of the list ``name``\n\nFor more information see https://redis.io/commands/rpush",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "rpushx",
              "doc": "Push ``value`` onto the tail of the list ``name`` if ``name`` exists\n\nFor more information see https://redis.io/commands/rpushx",
              "signature": "(self, name: str, *values: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "sadd",
              "doc": "Add ``value(s)`` to set ``name``\n\nFor more information see https://redis.io/commands/sadd",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "save",
              "doc": "Tell the Redis server to save its data to disk,\nblocking until the save is complete\n\nFor more information see https://redis.io/commands/save",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "scan",
              "doc": "Incrementally return lists of key names. Also return a cursor\nindicating the scan position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` provides a hint to Redis about the number of keys to\n    return per batch.\n\n``_type`` filters the returned values by a particular Redis type.\n    Stock Redis instances allow for the following types:\n    HASH, LIST, SET, STREAM, STRING, ZSET\n    Additionally, Redis modules can expose other types as well.\n\nFor more information see https://redis.io/commands/scan",
              "signature": "(self, cursor: int = 0, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, _type: Optional[str] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "scan_iter",
              "doc": "Make an iterator using the SCAN command so that the client doesn't\nneed to remember the cursor position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` provides a hint to Redis about the number of keys to\n    return per batch.\n\n``_type`` filters the returned values by a particular Redis type.\n    Stock Redis instances allow for the following types:\n    HASH, LIST, SET, STREAM, STRING, ZSET\n    Additionally, Redis modules can expose other types as well.",
              "signature": "(self, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, _type: Optional[str] = None, **kwargs) -> Iterator"
            },
            {
              "name": "scard",
              "doc": "Return the number of elements in set ``name``\n\nFor more information see https://redis.io/commands/scard",
              "signature": "(self, name: str) -> Union[Awaitable[int], int]"
            },
            {
              "name": "script_debug",
              "doc": null,
              "signature": "(self, *args) -> None"
            },
            {
              "name": "script_exists",
              "doc": "Check if a script exists in the script cache by specifying the SHAs of\neach script as ``args``. Returns a list of boolean values indicating if\nif each already script exists in the cache_data.\n\nFor more information see  https://redis.io/commands/script-exists",
              "signature": "(self, *args: str) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "script_flush",
              "doc": "Flush all scripts from the script cache_data.\n\n``sync_type`` is by default SYNC (synchronous) but it can also be\n              ASYNC.\n\nFor more information see  https://redis.io/commands/script-flush",
              "signature": "(self, sync_type: Union[Literal['SYNC'], Literal['ASYNC']] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "script_kill",
              "doc": "Kill the currently executing Lua script\n\nFor more information see https://redis.io/commands/script-kill",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "script_load",
              "doc": "Load a Lua ``script`` into the script cache_data. Returns the SHA.\n\nFor more information see https://redis.io/commands/script-load",
              "signature": "(self, script: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sdiff",
              "doc": "Return the difference of sets specified by ``keys``\n\nFor more information see https://redis.io/commands/sdiff",
              "signature": "(self, keys: List, *args: List) -> Union[Awaitable[list], list]"
            },
            {
              "name": "sdiffstore",
              "doc": "Store the difference of sets specified by ``keys`` into a new\nset named ``dest``.  Returns the number of keys in the new set.\n\nFor more information see https://redis.io/commands/sdiffstore",
              "signature": "(self, dest: str, keys: List, *args: List) -> Union[Awaitable[int], int]"
            },
            {
              "name": "select",
              "doc": "Select the Redis logical database at index.\n\nSee: https://redis.io/commands/select",
              "signature": "(self, index: int, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sentinel",
              "doc": "Redis Sentinel's SENTINEL command.",
              "signature": "(self, *args)"
            },
            {
              "name": "sentinel_ckquorum",
              "doc": "Check if the current Sentinel configuration is able to reach the\nquorum needed to failover a master, and the majority needed to\nauthorize the failover.\n\nThis command should be used in monitoring systems to check if a\nSentinel deployment is ok.",
              "signature": "(self, new_master_name)"
            },
            {
              "name": "sentinel_failover",
              "doc": "Force a failover as if the master was not reachable, and without\nasking for agreement to other Sentinels (however a new version of the\nconfiguration will be published so that the other Sentinels will\nupdate their configurations).",
              "signature": "(self, new_master_name)"
            },
            {
              "name": "sentinel_flushconfig",
              "doc": "Force Sentinel to rewrite its configuration on disk, including the\ncurrent Sentinel state.\n\nNormally Sentinel rewrites the configuration every time something\nchanges in its state (in the context of the subset of the state which\nis persisted on disk across restart).\nHowever sometimes it is possible that the configuration file is lost\nbecause of operation errors, disk failures, package upgrade scripts or\nconfiguration managers. In those cases a way to to force Sentinel to\nrewrite the configuration file is handy.\n\nThis command works even if the previous configuration file is\ncompletely missing.",
              "signature": "(self)"
            },
            {
              "name": "sentinel_get_master_addr_by_name",
              "doc": "Returns a (host, port) pair for the given ``service_name``",
              "signature": "(self, service_name)"
            },
            {
              "name": "sentinel_master",
              "doc": "Returns a dictionary containing the specified masters state.",
              "signature": "(self, service_name)"
            },
            {
              "name": "sentinel_masters",
              "doc": "Returns a list of dictionaries containing each master's state.",
              "signature": "(self)"
            },
            {
              "name": "sentinel_monitor",
              "doc": "Add a new master to Sentinel to be monitored",
              "signature": "(self, name, ip, port, quorum)"
            },
            {
              "name": "sentinel_remove",
              "doc": "Remove a master from Sentinel's monitoring",
              "signature": "(self, name)"
            },
            {
              "name": "sentinel_reset",
              "doc": "This command will reset all the masters with matching name.\nThe pattern argument is a glob-style pattern.\n\nThe reset process clears any previous state in a master (including a\nfailover in progress), and removes every slave and sentinel already\ndiscovered and associated with the master.",
              "signature": "(self, pattern)"
            },
            {
              "name": "sentinel_sentinels",
              "doc": "Returns a list of sentinels for ``service_name``",
              "signature": "(self, service_name)"
            },
            {
              "name": "sentinel_set",
              "doc": "Set Sentinel monitoring parameters for a given master",
              "signature": "(self, name, option, value)"
            },
            {
              "name": "sentinel_slaves",
              "doc": "Returns a list of slaves for ``service_name``",
              "signature": "(self, service_name)"
            },
            {
              "name": "set",
              "doc": "Set the value at key ``name`` to ``value``\n\n``ex`` sets an expire flag on key ``name`` for ``ex`` seconds.\n\n``px`` sets an expire flag on key ``name`` for ``px`` milliseconds.\n\n``nx`` if set to True, set the value at key ``name`` to ``value`` only\n    if it does not exist.\n\n``xx`` if set to True, set the value at key ``name`` to ``value`` only\n    if it already exists.\n\n``keepttl`` if True, retain the time to live associated with the key.\n    (Available since Redis 6.0)\n\n``get`` if True, set the value at key ``name`` to ``value`` and return\n    the old value stored at key, or None if the key did not exist.\n    (Available since Redis 6.2)\n\n``exat`` sets an expire flag on key ``name`` for ``ex`` seconds,\n    specified in unix time.\n\n``pxat`` sets an expire flag on key ``name`` for ``ex`` milliseconds,\n    specified in unix time.\n\nFor more information see https://redis.io/commands/set",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float], ex: Union[int, datetime.timedelta, NoneType] = None, px: Union[int, datetime.timedelta, NoneType] = None, nx: bool = False, xx: bool = False, keepttl: bool = False, get: bool = False, exat: Union[int, datetime.datetime, NoneType] = None, pxat: Union[int, datetime.datetime, NoneType] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "set_response_callback",
              "doc": "Set a custom Response Callback",
              "signature": "(self, command: str, callback: Callable) -> None"
            },
            {
              "name": "set_retry",
              "doc": null,
              "signature": "(self, retry: redis.retry.Retry) -> None"
            },
            {
              "name": "setbit",
              "doc": "Flag the ``offset`` in ``name`` as ``value``. Returns an integer\nindicating the previous value of ``offset``.\n\nFor more information see https://redis.io/commands/setbit",
              "signature": "(self, name: Union[bytes, str, memoryview], offset: int, value: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "setex",
              "doc": "Set the value of key ``name`` to ``value`` that expires in ``time``\nseconds. ``time`` can be represented by an integer or a Python\ntimedelta object.\n\nFor more information see https://redis.io/commands/setex",
              "signature": "(self, name: Union[bytes, str, memoryview], time: Union[int, datetime.timedelta], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "setnx",
              "doc": "Set the value of key ``name`` to ``value`` if key doesn't exist\n\nFor more information see https://redis.io/commands/setnx",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "setrange",
              "doc": "Overwrite bytes in the value of ``name`` starting at ``offset`` with\n``value``. If ``offset`` plus the length of ``value`` exceeds the\nlength of the original value, the new value will be larger than before.\nIf ``offset`` exceeds the length of the original value, null bytes\nwill be used to pad between the end of the previous value and the start\nof what's being injected.\n\nReturns the length of the new string.\n\nFor more information see https://redis.io/commands/setrange",
              "signature": "(self, name: Union[bytes, str, memoryview], offset: int, value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "shutdown",
              "doc": "Shutdown the Redis server.  If Redis has persistence configured,\ndata will be flushed before shutdown.\nIt is possible to specify modifiers to alter the behavior of the command:\n``save`` will force a DB saving operation even if no save points are configured.\n``nosave`` will prevent a DB saving operation even if one or more save points\nare configured.\n``now`` skips waiting for lagging replicas, i.e. it bypasses the first step in\nthe shutdown sequence.\n``force`` ignores any errors that would normally prevent the server from exiting\n``abort`` cancels an ongoing shutdown and cannot be combined with other flags.\n\nFor more information see https://redis.io/commands/shutdown",
              "signature": "(self, save: bool = False, nosave: bool = False, now: bool = False, force: bool = False, abort: bool = False, **kwargs) -> None"
            },
            {
              "name": "sinter",
              "doc": "Return the intersection of sets specified by ``keys``\n\nFor more information see https://redis.io/commands/sinter",
              "signature": "(self, keys: List, *args: List) -> Union[Awaitable[list], list]"
            },
            {
              "name": "sintercard",
              "doc": "Return the cardinality of the intersect of multiple sets specified by ``keys``.\n\nWhen LIMIT provided (defaults to 0 and means unlimited), if the intersection\ncardinality reaches limit partway through the computation, the algorithm will\nexit and yield limit as the cardinality\n\nFor more information see https://redis.io/commands/sintercard",
              "signature": "(self, numkeys: int, keys: List[str], limit: int = 0) -> Union[Awaitable[int], int]"
            },
            {
              "name": "sinterstore",
              "doc": "Store the intersection of sets specified by ``keys`` into a new\nset named ``dest``.  Returns the number of keys in the new set.\n\nFor more information see https://redis.io/commands/sinterstore",
              "signature": "(self, dest: str, keys: List, *args: List) -> Union[Awaitable[int], int]"
            },
            {
              "name": "sismember",
              "doc": "Return whether ``value`` is a member of set ``name``:\n- 1 if the value is a member of the set.\n- 0 if the value is not a member of the set or if key does not exist.\n\nFor more information see https://redis.io/commands/sismember",
              "signature": "(self, name: str, value: str) -> Union[Awaitable[Union[Literal[0], Literal[1]]], Literal[0], Literal[1]]"
            },
            {
              "name": "slaveof",
              "doc": "Set the server to be a replicated slave of the instance identified\nby the ``host`` and ``port``. If called without arguments, the\ninstance is promoted to a master instead.\n\nFor more information see https://redis.io/commands/slaveof",
              "signature": "(self, host: Optional[str] = None, port: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "slowlog_get",
              "doc": "Get the entries from the slowlog. If ``num`` is specified, get the\nmost recent ``num`` items.\n\nFor more information see https://redis.io/commands/slowlog-get",
              "signature": "(self, num: Optional[int] = None, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "slowlog_len",
              "doc": "Get the number of items in the slowlog\n\nFor more information see https://redis.io/commands/slowlog-len",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "slowlog_reset",
              "doc": "Remove all items in the slowlog\n\nFor more information see https://redis.io/commands/slowlog-reset",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "smembers",
              "doc": "Return all members of the set ``name``\n\nFor more information see https://redis.io/commands/smembers",
              "signature": "(self, name: str) -> Union[Awaitable[Set], Set]"
            },
            {
              "name": "smismember",
              "doc": "Return whether each value in ``values`` is a member of the set ``name``\nas a list of ``int`` in the order of ``values``:\n- 1 if the value is a member of the set.\n- 0 if the value is not a member of the set or if key does not exist.\n\nFor more information see https://redis.io/commands/smismember",
              "signature": "(self, name: str, values: List, *args: List) -> Union[Awaitable[List[Union[Literal[0], Literal[1]]]], List[Union[Literal[0], Literal[1]]]]"
            },
            {
              "name": "smove",
              "doc": "Move ``value`` from set ``src`` to set ``dst`` atomically\n\nFor more information see https://redis.io/commands/smove",
              "signature": "(self, src: str, dst: str, value: str) -> Union[Awaitable[bool], bool]"
            },
            {
              "name": "sort",
              "doc": "Sort and return the list, set or sorted set at ``name``.\n\n``start`` and ``num`` allow for paging through the sorted data\n\n``by`` allows using an external key to weight and sort the items.\n    Use an \"*\" to indicate where in the key the item value is located\n\n``get`` allows for returning items from external keys rather than the\n    sorted data itself.  Use an \"*\" to indicate where in the key\n    the item value is located\n\n``desc`` allows for reversing the sort\n\n``alpha`` allows for sorting lexicographically rather than numerically\n\n``store`` allows for storing the result of the sort into\n    the key ``store``\n\n``groups`` if set to True and if ``get`` contains at least two\n    elements, sort will return a list of tuples, each containing the\n    values fetched from the arguments to ``get``.\n\nFor more information see https://redis.io/commands/sort",
              "signature": "(self, name: str, start: Optional[int] = None, num: Optional[int] = None, by: Optional[str] = None, get: Optional[List[str]] = None, desc: bool = False, alpha: bool = False, store: Optional[str] = None, groups: Optional[bool] = False) -> Union[List, int]"
            },
            {
              "name": "sort_ro",
              "doc": "Returns the elements contained in the list, set or sorted set at key.\n(read-only variant of the SORT command)\n\n``start`` and ``num`` allow for paging through the sorted data\n\n``by`` allows using an external key to weight and sort the items.\n    Use an \"*\" to indicate where in the key the item value is located\n\n``get`` allows for returning items from external keys rather than the\n    sorted data itself.  Use an \"*\" to indicate where in the key\n    the item value is located\n\n``desc`` allows for reversing the sort\n\n``alpha`` allows for sorting lexicographically rather than numerically\n\nFor more information see https://redis.io/commands/sort_ro",
              "signature": "(self, key: str, start: Optional[int] = None, num: Optional[int] = None, by: Optional[str] = None, get: Optional[List[str]] = None, desc: bool = False, alpha: bool = False) -> list"
            },
            {
              "name": "spop",
              "doc": "Remove and return a random member of set ``name``\n\nFor more information see https://redis.io/commands/spop",
              "signature": "(self, name: str, count: Optional[int] = None) -> Union[str, List, NoneType]"
            },
            {
              "name": "spublish",
              "doc": "Posts a message to the given shard channel.\nReturns the number of clients that received the message\n\nFor more information see https://redis.io/commands/spublish",
              "signature": "(self, shard_channel: Union[bytes, str, memoryview], message: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "srandmember",
              "doc": "If ``number`` is None, returns a random member of set ``name``.\n\nIf ``number`` is supplied, returns a list of ``number`` random\nmembers of set ``name``. Note this is only available when running\nRedis 2.6+.\n\nFor more information see https://redis.io/commands/srandmember",
              "signature": "(self, name: str, number: Optional[int] = None) -> Union[str, List, NoneType]"
            },
            {
              "name": "srem",
              "doc": "Remove ``values`` from set ``name``\n\nFor more information see https://redis.io/commands/srem",
              "signature": "(self, name: str, *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[int], int]"
            },
            {
              "name": "sscan",
              "doc": "Incrementally return lists of elements in a set. Also return a cursor\nindicating the scan position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\nFor more information see https://redis.io/commands/sscan",
              "signature": "(self, name: Union[bytes, str, memoryview], cursor: int = 0, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sscan_iter",
              "doc": "Make an iterator using the SSCAN command so that the client doesn't\nneed to remember the cursor position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns",
              "signature": "(self, name: Union[bytes, str, memoryview], match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None) -> Iterator"
            },
            {
              "name": "stralgo",
              "doc": "Implements complex algorithms that operate on strings.\nRight now the only algorithm implemented is the LCS algorithm\n(longest common substring). However new algorithms could be\nimplemented in the future.\n\n``algo`` Right now must be LCS\n``value1`` and ``value2`` Can be two strings or two keys\n``specific_argument`` Specifying if the arguments to the algorithm\nwill be keys or strings. strings is the default.\n``len`` Returns just the len of the match.\n``idx`` Returns the match positions in each string.\n``minmatchlen`` Restrict the list of matches to the ones of a given\nminimal length. Can be provided only when ``idx`` set to True.\n``withmatchlen`` Returns the matches with the len of the match.\nCan be provided only when ``idx`` set to True.\n\nFor more information see https://redis.io/commands/stralgo",
              "signature": "(self, algo: Literal['LCS'], value1: Union[bytes, str, memoryview], value2: Union[bytes, str, memoryview], specific_argument: Union[Literal['strings'], Literal['keys']] = 'strings', len: bool = False, idx: bool = False, minmatchlen: Optional[int] = None, withmatchlen: bool = False, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "strlen",
              "doc": "Return the number of bytes stored in the value of ``name``\n\nFor more information see https://redis.io/commands/strlen",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "substr",
              "doc": "Return a substring of the string at key ``name``. ``start`` and ``end``\nare 0-based integers specifying the portion of the string to return.",
              "signature": "(self, name: Union[bytes, str, memoryview], start: int, end: int = -1) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sunion",
              "doc": "Return the union of sets specified by ``keys``\n\nFor more information see https://redis.io/commands/sunion",
              "signature": "(self, keys: List, *args: List) -> Union[Awaitable[List], List]"
            },
            {
              "name": "sunionstore",
              "doc": "Store the union of sets specified by ``keys`` into a new\nset named ``dest``.  Returns the number of keys in the new set.\n\nFor more information see https://redis.io/commands/sunionstore",
              "signature": "(self, dest: str, keys: List, *args: List) -> Union[Awaitable[int], int]"
            },
            {
              "name": "swapdb",
              "doc": "Swap two databases\n\nFor more information see https://redis.io/commands/swapdb",
              "signature": "(self, first: int, second: int, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "sync",
              "doc": "Initiates a replication stream from the master.\n\nFor more information see https://redis.io/commands/sync",
              "signature": "(self) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "tdigest",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'TDigestBloom'"
            },
            {
              "name": "time",
              "doc": "Returns the server time as a 2-item tuple of ints:\n(seconds since epoch, microseconds into this second).\n\nFor more information see https://redis.io/commands/time",
              "signature": "(self, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "topk",
              "doc": "Access the bloom namespace.",
              "signature": "(self) -> 'TOPKBloom'"
            },
            {
              "name": "touch",
              "doc": "Alters the last access time of a key(s) ``*args``. A key is ignored\nif it does not exist.\n\nFor more information see https://redis.io/commands/touch",
              "signature": "(self, *args: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "transaction",
              "doc": "Convenience method for executing the callable `func` as a transaction\nwhile watching all keys specified in `watches`. The 'func' callable\nshould expect a single argument which is a Pipeline object.",
              "signature": "(self, func: Callable[[ForwardRef('Pipeline')], NoneType], *watches, **kwargs) -> None"
            },
            {
              "name": "ts",
              "doc": "Access the timeseries namespace, providing support for\nredis timeseries data.",
              "signature": "(self) -> 'TimeSeries'"
            },
            {
              "name": "ttl",
              "doc": "Returns the number of seconds until the key ``name`` will expire\n\nFor more information see https://redis.io/commands/ttl",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "type",
              "doc": "Returns the type of key ``name``\n\nFor more information see https://redis.io/commands/type",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "unlink",
              "doc": "Unlink one or more keys specified by ``names``\n\nFor more information see https://redis.io/commands/unlink",
              "signature": "(self, *names: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "unwatch",
              "doc": "Unwatches all previously watched keys for a transaction\n\nFor more information see https://redis.io/commands/unwatch",
              "signature": "(self) -> None"
            },
            {
              "name": "vset",
              "doc": "Access the VectorSet commands namespace.",
              "signature": "(self) -> 'VectorSet'"
            },
            {
              "name": "wait",
              "doc": "Redis synchronous replication\nThat returns the number of replicas that processed the query when\nwe finally have at least ``num_replicas``, or when the ``timeout`` was\nreached.\n\nFor more information see https://redis.io/commands/wait",
              "signature": "(self, num_replicas: int, timeout: int, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "waitaof",
              "doc": "This command blocks the current client until all previous write\ncommands by that client are acknowledged as having been fsynced\nto the AOF of the local Redis and/or at least the specified number\nof replicas.\n\nFor more information see https://redis.io/commands/waitaof",
              "signature": "(self, num_local: int, num_replicas: int, timeout: int, **kwargs) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "watch",
              "doc": "Watches the values at keys ``names``, or None if the key doesn't exist\n\nFor more information see https://redis.io/commands/watch",
              "signature": "(self, *names: Union[bytes, str, memoryview]) -> None"
            },
            {
              "name": "xack",
              "doc": "Acknowledges the successful processing of one or more messages.\n\nArgs:\n    name: name of the stream.\n    groupname: name of the consumer group.\n    *ids: message ids to acknowledge.\n\nFor more information see https://redis.io/commands/xack",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], *ids: Union[int, bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xadd",
              "doc": "Add to a stream.\nname: name of the stream\nfields: dict of field/value pairs to insert into the stream\nid: Location to insert this record. By default it is appended.\nmaxlen: truncate old stream members beyond this size.\nCan't be specified with minid.\napproximate: actual stream length may be slightly more than maxlen\nnomkstream: When set to true, do not make a stream\nminid: the minimum id in the stream to query.\nCan't be specified with maxlen.\nlimit: specifies the maximum number of entries to retrieve\n\nFor more information see https://redis.io/commands/xadd",
              "signature": "(self, name: Union[bytes, str, memoryview], fields: Dict[Union[bytes, bytearray, memoryview, str, int, float], Union[bytes, bytearray, memoryview, str, int, float]], id: Union[int, bytes, str, memoryview] = '*', maxlen: Optional[int] = None, approximate: bool = True, nomkstream: bool = False, minid: Union[int, bytes, str, memoryview, NoneType] = None, limit: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xautoclaim",
              "doc": "Transfers ownership of pending stream entries that match the specified\ncriteria. Conceptually, equivalent to calling XPENDING and then XCLAIM,\nbut provides a more straightforward way to deal with message delivery\nfailures via SCAN-like semantics.\nname: name of the stream.\ngroupname: name of the consumer group.\nconsumername: name of a consumer that claims the message.\nmin_idle_time: filter messages that were idle less than this amount of\nmilliseconds.\nstart_id: filter messages with equal or greater ID.\ncount: optional integer, upper limit of the number of entries that the\ncommand attempts to claim. Set to 100 by default.\njustid: optional boolean, false by default. Return just an array of IDs\nof messages successfully claimed, without returning the actual message\n\nFor more information see https://redis.io/commands/xautoclaim",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], consumername: Union[bytes, str, memoryview], min_idle_time: int, start_id: Union[int, bytes, str, memoryview] = '0-0', count: Optional[int] = None, justid: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xclaim",
              "doc": "Changes the ownership of a pending message.\n\nname: name of the stream.\n\ngroupname: name of the consumer group.\n\nconsumername: name of a consumer that claims the message.\n\nmin_idle_time: filter messages that were idle less than this amount of\nmilliseconds\n\nmessage_ids: non-empty list or tuple of message IDs to claim\n\nidle: optional. Set the idle time (last time it was delivered) of the\nmessage in ms\n\ntime: optional integer. This is the same as idle but instead of a\nrelative amount of milliseconds, it sets the idle time to a specific\nUnix time (in milliseconds).\n\nretrycount: optional integer. set the retry counter to the specified\nvalue. This counter is incremented every time a message is delivered\nagain.\n\nforce: optional boolean, false by default. Creates the pending message\nentry in the PEL even if certain specified IDs are not already in the\nPEL assigned to a different client.\n\njustid: optional boolean, false by default. Return just an array of IDs\nof messages successfully claimed, without returning the actual message\n\nFor more information see https://redis.io/commands/xclaim",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], consumername: Union[bytes, str, memoryview], min_idle_time: int, message_ids: Union[List[Union[int, bytes, str, memoryview]], Tuple[Union[int, bytes, str, memoryview]]], idle: Optional[int] = None, time: Optional[int] = None, retrycount: Optional[int] = None, force: bool = False, justid: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xdel",
              "doc": "Deletes one or more messages from a stream.\n\nArgs:\n    name: name of the stream.\n    *ids: message ids to delete.\n\nFor more information see https://redis.io/commands/xdel",
              "signature": "(self, name: Union[bytes, str, memoryview], *ids: Union[int, bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_create",
              "doc": "Create a new consumer group associated with a stream.\nname: name of the stream.\ngroupname: name of the consumer group.\nid: ID of the last item in the stream to consider already delivered.\n\nFor more information see https://redis.io/commands/xgroup-create",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], id: Union[int, bytes, str, memoryview] = '$', mkstream: bool = False, entries_read: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_createconsumer",
              "doc": "Consumers in a consumer group are auto-created every time a new\nconsumer name is mentioned by some command.\nThey can be explicitly created by using this command.\nname: name of the stream.\ngroupname: name of the consumer group.\nconsumername: name of consumer to create.\n\nSee: https://redis.io/commands/xgroup-createconsumer",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], consumername: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_delconsumer",
              "doc": "Remove a specific consumer from a consumer group.\nReturns the number of pending messages that the consumer had before it\nwas deleted.\nname: name of the stream.\ngroupname: name of the consumer group.\nconsumername: name of consumer to delete\n\nFor more information see https://redis.io/commands/xgroup-delconsumer",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], consumername: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_destroy",
              "doc": "Destroy a consumer group.\nname: name of the stream.\ngroupname: name of the consumer group.\n\nFor more information see https://redis.io/commands/xgroup-destroy",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xgroup_setid",
              "doc": "Set the consumer group last delivered ID to something else.\nname: name of the stream.\ngroupname: name of the consumer group.\nid: ID of the last item in the stream to consider already delivered.\n\nFor more information see https://redis.io/commands/xgroup-setid",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], id: Union[int, bytes, str, memoryview], entries_read: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xinfo_consumers",
              "doc": "Returns general information about the consumers in the group.\nname: name of the stream.\ngroupname: name of the consumer group.\n\nFor more information see https://redis.io/commands/xinfo-consumers",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xinfo_groups",
              "doc": "Returns general information about the consumer groups of the stream.\nname: name of the stream.\n\nFor more information see https://redis.io/commands/xinfo-groups",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xinfo_stream",
              "doc": "Returns general information about the stream.\nname: name of the stream.\nfull: optional boolean, false by default. Return full summary\n\nFor more information see https://redis.io/commands/xinfo-stream",
              "signature": "(self, name: Union[bytes, str, memoryview], full: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xlen",
              "doc": "Returns the number of elements in a given stream.\n\nFor more information see https://redis.io/commands/xlen",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xpending",
              "doc": "Returns information about pending messages of a group.\nname: name of the stream.\ngroupname: name of the consumer group.\n\nFor more information see https://redis.io/commands/xpending",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xpending_range",
              "doc": "Returns information about pending messages, in a range.\n\nname: name of the stream.\ngroupname: name of the consumer group.\nidle: available from  version 6.2. filter entries by their\nidle-time, given in milliseconds (optional).\nmin: minimum stream ID.\nmax: maximum stream ID.\ncount: number of messages to return\nconsumername: name of a consumer to filter by (optional).",
              "signature": "(self, name: Union[bytes, str, memoryview], groupname: Union[bytes, str, memoryview], min: Union[int, bytes, str, memoryview], max: Union[int, bytes, str, memoryview], count: int, consumername: Union[bytes, str, memoryview, NoneType] = None, idle: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xrange",
              "doc": "Read stream values within an interval.\n\nname: name of the stream.\n\nstart: first stream ID. defaults to '-',\n       meaning the earliest available.\n\nfinish: last stream ID. defaults to '+',\n        meaning the latest available.\n\ncount: if set, only return this many items, beginning with the\n       earliest available.\n\nFor more information see https://redis.io/commands/xrange",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[int, bytes, str, memoryview] = '-', max: Union[int, bytes, str, memoryview] = '+', count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xread",
              "doc": "Block and monitor multiple streams for new data.\n\nstreams: a dict of stream names to stream IDs, where\n           IDs indicate the last ID already seen.\n\ncount: if set, only return this many items, beginning with the\n       earliest available.\n\nblock: number of milliseconds to wait, if nothing already present.\n\nFor more information see https://redis.io/commands/xread",
              "signature": "(self, streams: Dict[Union[bytes, str, memoryview], Union[int, bytes, str, memoryview]], count: Optional[int] = None, block: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xreadgroup",
              "doc": "Read from a stream via a consumer group.\n\ngroupname: name of the consumer group.\n\nconsumername: name of the requesting consumer.\n\nstreams: a dict of stream names to stream IDs, where\n       IDs indicate the last ID already seen.\n\ncount: if set, only return this many items, beginning with the\n       earliest available.\n\nblock: number of milliseconds to wait, if nothing already present.\nnoack: do not add messages to the PEL\n\nFor more information see https://redis.io/commands/xreadgroup",
              "signature": "(self, groupname: str, consumername: str, streams: Dict[Union[bytes, str, memoryview], Union[int, bytes, str, memoryview]], count: Optional[int] = None, block: Optional[int] = None, noack: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xrevrange",
              "doc": "Read stream values within an interval, in reverse order.\n\nname: name of the stream\n\nstart: first stream ID. defaults to '+',\n       meaning the latest available.\n\nfinish: last stream ID. defaults to '-',\n        meaning the earliest available.\n\ncount: if set, only return this many items, beginning with the\n       latest available.\n\nFor more information see https://redis.io/commands/xrevrange",
              "signature": "(self, name: Union[bytes, str, memoryview], max: Union[int, bytes, str, memoryview] = '+', min: Union[int, bytes, str, memoryview] = '-', count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "xtrim",
              "doc": "Trims old messages from a stream.\nname: name of the stream.\nmaxlen: truncate old stream messages beyond this size\nCan't be specified with minid.\napproximate: actual stream length may be slightly more than maxlen\nminid: the minimum id in the stream to query\nCan't be specified with maxlen.\nlimit: specifies the maximum number of entries to retrieve\n\nFor more information see https://redis.io/commands/xtrim",
              "signature": "(self, name: Union[bytes, str, memoryview], maxlen: Optional[int] = None, approximate: bool = True, minid: Union[int, bytes, str, memoryview, NoneType] = None, limit: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zadd",
              "doc": "Set any number of element-name, score pairs to the key ``name``. Pairs\nare specified as a dict of element-names keys to score values.\n\n``nx`` forces ZADD to only create new elements and not to update\nscores for elements that already exist.\n\n``xx`` forces ZADD to only update scores of elements that already\nexist. New elements will not be added.\n\n``ch`` modifies the return value to be the numbers of elements changed.\nChanged elements include new elements that were added and elements\nwhose scores changed.\n\n``incr`` modifies ZADD to behave like ZINCRBY. In this mode only a\nsingle element/score pair can be specified and the score is the amount\nthe existing score will be incremented by. When using this mode the\nreturn value of ZADD will be the new score of the element.\n\n``LT`` Only update existing elements if the new score is less than\nthe current score. This flag doesn't prevent adding new elements.\n\n``GT`` Only update existing elements if the new score is greater than\nthe current score. This flag doesn't prevent adding new elements.\n\nThe return value of ZADD varies based on the mode specified. With no\noptions, ZADD returns the number of new elements added to the sorted\nset.\n\n``NX``, ``LT``, and ``GT`` are mutually exclusive options.\n\nSee: https://redis.io/commands/ZADD",
              "signature": "(self, name: Union[bytes, str, memoryview], mapping: Mapping[~AnyKeyT, Union[bytes, bytearray, memoryview, str, int, float]], nx: bool = False, xx: bool = False, ch: bool = False, incr: bool = False, gt: bool = False, lt: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zcard",
              "doc": "Return the number of elements in the sorted set ``name``\n\nFor more information see https://redis.io/commands/zcard",
              "signature": "(self, name: Union[bytes, str, memoryview]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zcount",
              "doc": "Returns the number of elements in the sorted set at key ``name`` with\na score between ``min`` and ``max``.\n\nFor more information see https://redis.io/commands/zcount",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[float, str], max: Union[float, str]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zdiff",
              "doc": "Returns the difference between the first and all successive input\nsorted sets provided in ``keys``.\n\nFor more information see https://redis.io/commands/zdiff",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], withscores: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zdiffstore",
              "doc": "Computes the difference between the first and all successive input\nsorted sets provided in ``keys`` and stores the result in ``dest``.\n\nFor more information see https://redis.io/commands/zdiffstore",
              "signature": "(self, dest: Union[bytes, str, memoryview], keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zincrby",
              "doc": "Increment the score of ``value`` in sorted set ``name`` by ``amount``\n\nFor more information see https://redis.io/commands/zincrby",
              "signature": "(self, name: Union[bytes, str, memoryview], amount: float, value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zinter",
              "doc": "Return the intersect of multiple sorted sets specified by ``keys``.\nWith the ``aggregate`` option, it is possible to specify how the\nresults of the union are aggregated. This option defaults to SUM,\nwhere the score of an element is summed across the inputs where it\nexists. When this option is set to either MIN or MAX, the resulting\nset will contain the minimum or maximum score of an element across\nthe inputs where it exists.\n\nFor more information see https://redis.io/commands/zinter",
              "signature": "(self, keys: Union[bytes, str, memoryview, Iterable[Union[bytes, str, memoryview]]], aggregate: Optional[str] = None, withscores: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zintercard",
              "doc": "Return the cardinality of the intersect of multiple sorted sets\nspecified by ``keys``.\nWhen LIMIT provided (defaults to 0 and means unlimited), if the intersection\ncardinality reaches limit partway through the computation, the algorithm will\nexit and yield limit as the cardinality\n\nFor more information see https://redis.io/commands/zintercard",
              "signature": "(self, numkeys: int, keys: List[str], limit: int = 0) -> Union[Awaitable[int], int]"
            },
            {
              "name": "zinterstore",
              "doc": "Intersect multiple sorted sets specified by ``keys`` into a new\nsorted set, ``dest``. Scores in the destination will be aggregated\nbased on the ``aggregate``. This option defaults to SUM, where the\nscore of an element is summed across the inputs where it exists.\nWhen this option is set to either MIN or MAX, the resulting set will\ncontain the minimum or maximum score of an element across the inputs\nwhere it exists.\n\nFor more information see https://redis.io/commands/zinterstore",
              "signature": "(self, dest: Union[bytes, str, memoryview], keys: Union[Sequence[Union[bytes, str, memoryview]], Mapping[~AnyKeyT, float]], aggregate: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zlexcount",
              "doc": "Return the number of items in the sorted set ``name`` between the\nlexicographical range ``min`` and ``max``.\n\nFor more information see https://redis.io/commands/zlexcount",
              "signature": "(self, name, min, max)"
            },
            {
              "name": "zmpop",
              "doc": "Pop ``count`` values (default 1) off of the first non-empty sorted set\nnamed in the ``keys`` list.\nFor more information see https://redis.io/commands/zmpop",
              "signature": "(self, num_keys: int, keys: List[str], min: Optional[bool] = False, max: Optional[bool] = False, count: Optional[int] = 1) -> Union[Awaitable[list], list]"
            },
            {
              "name": "zmscore",
              "doc": "Returns the scores associated with the specified members\nin the sorted set stored at key.\n``members`` should be a list of the member name.\nReturn type is a list of score.\nIf the member does not exist, a None will be returned\nin corresponding position.\n\nFor more information see https://redis.io/commands/zmscore",
              "signature": "(self, key: Union[bytes, str, memoryview], members: List[str]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zpopmax",
              "doc": "Remove and return up to ``count`` members with the highest scores\nfrom the sorted set ``name``.\n\nFor more information see https://redis.io/commands/zpopmax",
              "signature": "(self, name: Union[bytes, str, memoryview], count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zpopmin",
              "doc": "Remove and return up to ``count`` members with the lowest scores\nfrom the sorted set ``name``.\n\nFor more information see https://redis.io/commands/zpopmin",
              "signature": "(self, name: Union[bytes, str, memoryview], count: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrandmember",
              "doc": "Return a random element from the sorted set value stored at key.\n\n``count`` if the argument is positive, return an array of distinct\nfields. If called with a negative count, the behavior changes and\nthe command is allowed to return the same field multiple times.\nIn this case, the number of returned fields is the absolute value\nof the specified count.\n\n``withscores`` The optional WITHSCORES modifier changes the reply so it\nincludes the respective scores of the randomly selected elements from\nthe sorted set.\n\nFor more information see https://redis.io/commands/zrandmember",
              "signature": "(self, key: Union[bytes, str, memoryview], count: Optional[int] = None, withscores: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrange",
              "doc": "Return a range of values from sorted set ``name`` between\n``start`` and ``end`` sorted in ascending order.\n\n``start`` and ``end`` can be negative, indicating the end of the range.\n\n``desc`` a boolean indicating whether to sort the results in reversed\norder.\n\n``withscores`` indicates to return the scores along with the values.\nThe return type is a list of (value, score) pairs.\n\n``score_cast_func`` a callable used to cast the score return value.\n\n``byscore`` when set to True, returns the range of elements from the\nsorted set having scores equal or between ``start`` and ``end``.\n\n``bylex`` when set to True, returns the range of elements from the\nsorted set between the ``start`` and ``end`` lexicographical closed\nrange intervals.\nValid ``start`` and ``end`` must start with ( or [, in order to specify\nwhether the range interval is exclusive or inclusive, respectively.\n\n``offset`` and ``num`` are specified, then return a slice of the range.\nCan't be provided when using ``bylex``.\n\nFor more information see https://redis.io/commands/zrange",
              "signature": "(self, name: Union[bytes, str, memoryview], start: int, end: int, desc: bool = False, withscores: bool = False, score_cast_func: Union[type, Callable] = <class 'float'>, byscore: bool = False, bylex: bool = False, offset: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrangebylex",
              "doc": "Return the lexicographical range of values from sorted set ``name``\nbetween ``min`` and ``max``.\n\nIf ``start`` and ``num`` are specified, then return a slice of the\nrange.\n\nFor more information see https://redis.io/commands/zrangebylex",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[bytes, bytearray, memoryview, str, int, float], max: Union[bytes, bytearray, memoryview, str, int, float], start: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrangebyscore",
              "doc": "Return a range of values from the sorted set ``name`` with scores\nbetween ``min`` and ``max``.\n\nIf ``start`` and ``num`` are specified, then return a slice\nof the range.\n\n``withscores`` indicates to return the scores along with the values.\nThe return type is a list of (value, score) pairs\n\n`score_cast_func`` a callable used to cast the score return value\n\nFor more information see https://redis.io/commands/zrangebyscore",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[float, str], max: Union[float, str], start: Optional[int] = None, num: Optional[int] = None, withscores: bool = False, score_cast_func: Union[type, Callable] = <class 'float'>) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrangestore",
              "doc": "Stores in ``dest`` the result of a range of values from sorted set\n``name`` between ``start`` and ``end`` sorted in ascending order.\n\n``start`` and ``end`` can be negative, indicating the end of the range.\n\n``byscore`` when set to True, returns the range of elements from the\nsorted set having scores equal or between ``start`` and ``end``.\n\n``bylex`` when set to True, returns the range of elements from the\nsorted set between the ``start`` and ``end`` lexicographical closed\nrange intervals.\nValid ``start`` and ``end`` must start with ( or [, in order to specify\nwhether the range interval is exclusive or inclusive, respectively.\n\n``desc`` a boolean indicating whether to sort the results in reversed\norder.\n\n``offset`` and ``num`` are specified, then return a slice of the range.\nCan't be provided when using ``bylex``.\n\nFor more information see https://redis.io/commands/zrangestore",
              "signature": "(self, dest: Union[bytes, str, memoryview], name: Union[bytes, str, memoryview], start: int, end: int, byscore: bool = False, bylex: bool = False, desc: bool = False, offset: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrank",
              "doc": "Returns a 0-based value indicating the rank of ``value`` in sorted set\n``name``.\nThe optional WITHSCORE argument supplements the command's\nreply with the score of the element returned.\n\nFor more information see https://redis.io/commands/zrank",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float], withscore: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrem",
              "doc": "Remove member ``values`` from sorted set ``name``\n\nFor more information see https://redis.io/commands/zrem",
              "signature": "(self, name: Union[bytes, str, memoryview], *values: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zremrangebylex",
              "doc": "Remove all elements in the sorted set ``name`` between the\nlexicographical range specified by ``min`` and ``max``.\n\nReturns the number of elements removed.\n\nFor more information see https://redis.io/commands/zremrangebylex",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[bytes, bytearray, memoryview, str, int, float], max: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zremrangebyrank",
              "doc": "Remove all elements in the sorted set ``name`` with ranks between\n``min`` and ``max``. Values are 0-based, ordered from smallest score\nto largest. Values can be negative indicating the highest scores.\nReturns the number of elements removed\n\nFor more information see https://redis.io/commands/zremrangebyrank",
              "signature": "(self, name: Union[bytes, str, memoryview], min: int, max: int) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zremrangebyscore",
              "doc": "Remove all elements in the sorted set ``name`` with scores\nbetween ``min`` and ``max``. Returns the number of elements removed.\n\nFor more information see https://redis.io/commands/zremrangebyscore",
              "signature": "(self, name: Union[bytes, str, memoryview], min: Union[float, str], max: Union[float, str]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrevrange",
              "doc": "Return a range of values from sorted set ``name`` between\n``start`` and ``end`` sorted in descending order.\n\n``start`` and ``end`` can be negative, indicating the end of the range.\n\n``withscores`` indicates to return the scores along with the values\nThe return type is a list of (value, score) pairs\n\n``score_cast_func`` a callable used to cast the score return value\n\nFor more information see https://redis.io/commands/zrevrange",
              "signature": "(self, name: Union[bytes, str, memoryview], start: int, end: int, withscores: bool = False, score_cast_func: Union[type, Callable] = <class 'float'>) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrevrangebylex",
              "doc": "Return the reversed lexicographical range of values from sorted set\n``name`` between ``max`` and ``min``.\n\nIf ``start`` and ``num`` are specified, then return a slice of the\nrange.\n\nFor more information see https://redis.io/commands/zrevrangebylex",
              "signature": "(self, name: Union[bytes, str, memoryview], max: Union[bytes, bytearray, memoryview, str, int, float], min: Union[bytes, bytearray, memoryview, str, int, float], start: Optional[int] = None, num: Optional[int] = None) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zrevrangebyscore",
              "doc": "Return a range of values from the sorted set ``name`` with scores\nbetween ``min`` and ``max`` in descending order.\n\nIf ``start`` and ``num`` are specified, then return a slice\nof the range.\n\n``withscores`` indicates to return the scores along with the values.\nThe return type is a list of (value, score) pairs\n\n``score_cast_func`` a callable used to cast the score return value\n\nFor more information see https://redis.io/commands/zrevrangebyscore",
              "signature": "(self, name: Union[bytes, str, memoryview], max: Union[float, str], min: Union[float, str], start: Optional[int] = None, num: Optional[int] = None, withscores: bool = False, score_cast_func: Union[type, Callable] = <class 'float'>)"
            },
            {
              "name": "zrevrank",
              "doc": "Returns a 0-based value indicating the descending rank of\n``value`` in sorted set ``name``.\nThe optional ``withscore`` argument supplements the command's\nreply with the score of the element returned.\n\nFor more information see https://redis.io/commands/zrevrank",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float], withscore: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zscan",
              "doc": "Incrementally return lists of elements in a sorted set. Also return a\ncursor indicating the scan position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\n``score_cast_func`` a callable used to cast the score return value\n\nFor more information see https://redis.io/commands/zscan",
              "signature": "(self, name: Union[bytes, str, memoryview], cursor: int = 0, match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, score_cast_func: Union[type, Callable] = <class 'float'>) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zscan_iter",
              "doc": "Make an iterator using the ZSCAN command so that the client doesn't\nneed to remember the cursor position.\n\n``match`` allows for filtering the keys by pattern\n\n``count`` allows for hint the minimum number of returns\n\n``score_cast_func`` a callable used to cast the score return value",
              "signature": "(self, name: Union[bytes, str, memoryview], match: Union[bytes, str, memoryview, NoneType] = None, count: Optional[int] = None, score_cast_func: Union[type, Callable] = <class 'float'>) -> Iterator"
            },
            {
              "name": "zscore",
              "doc": "Return the score of element ``value`` in sorted set ``name``\n\nFor more information see https://redis.io/commands/zscore",
              "signature": "(self, name: Union[bytes, str, memoryview], value: Union[bytes, bytearray, memoryview, str, int, float]) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zunion",
              "doc": "Return the union of multiple sorted sets specified by ``keys``.\n``keys`` can be provided as dictionary of keys and their weights.\nScores will be aggregated based on the ``aggregate``, or SUM if\nnone is provided.\n\nFor more information see https://redis.io/commands/zunion",
              "signature": "(self, keys: Union[Sequence[Union[bytes, str, memoryview]], Mapping[~AnyKeyT, float]], aggregate: Optional[str] = None, withscores: bool = False) -> Union[Awaitable[Any], Any]"
            },
            {
              "name": "zunionstore",
              "doc": "Union multiple sorted sets specified by ``keys`` into\na new sorted set, ``dest``. Scores in the destination will be\naggregated based on the ``aggregate``, or SUM if none is provided.\n\nFor more information see https://redis.io/commands/zunionstore",
              "signature": "(self, dest: Union[bytes, str, memoryview], keys: Union[Sequence[Union[bytes, str, memoryview]], Mapping[~AnyKeyT, float]], aggregate: Optional[str] = None) -> Union[Awaitable[Any], Any]"
            }
          ]
        },
        {
          "name": "TimeoutError",
          "doc": "Common base class for all non-exit exceptions.",
          "functions": []
        },
        {
          "name": "UnixDomainSocketConnection",
          "doc": "Manages UDS communication to and from a Redis server",
          "functions": [
            {
              "name": "__del__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize a new Connection.\nTo specify a retry policy for specific errors, first set\n`retry_on_error` to a list of the error/s to retry on, then set\n`retry` to a valid `Retry` object.\nTo retry on TimeoutError, `retry_on_timeout` can also be set to `True`.",
              "signature": "(self, path='', socket_timeout=None, **kwargs)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "_connect",
              "doc": "Create a Unix domain socket connection",
              "signature": "(self)"
            },
            {
              "name": "_construct_command_packer",
              "doc": null,
              "signature": "(self, packer)"
            },
            {
              "name": "_error_message",
              "doc": null,
              "signature": "(self, exception)"
            },
            {
              "name": "_host_error",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_ping_failed",
              "doc": "Function to call when PING fails",
              "signature": "(self, error)"
            },
            {
              "name": "_send_ping",
              "doc": "Send PING, expect PONG in return",
              "signature": "(self)"
            },
            {
              "name": "can_read",
              "doc": "Poll the socket to see if there's data that can be read.",
              "signature": "(self, timeout=0)"
            },
            {
              "name": "check_health",
              "doc": "Check the health of the connection with a PING/PONG",
              "signature": "(self)"
            },
            {
              "name": "connect",
              "doc": "Connects to the Redis server if not already connected",
              "signature": "(self)"
            },
            {
              "name": "connect_check_health",
              "doc": null,
              "signature": "(self, check_health: bool = True)"
            },
            {
              "name": "deregister_connect_callback",
              "doc": "De-register a previously registered callback.  It will no-longer receive\nnotifications on connection events.  Calling this is not required when the\nlistener goes away, since the callbacks are kept as weak methods.",
              "signature": "(self, callback)"
            },
            {
              "name": "disconnect",
              "doc": "Disconnects from the Redis server",
              "signature": "(self, *args)"
            },
            {
              "name": "get_protocol",
              "doc": null,
              "signature": "(self) -> Union[int, str]"
            },
            {
              "name": "on_connect",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "on_connect_check_health",
              "doc": "Initialize the connection, authenticate and select a database",
              "signature": "(self, check_health: bool = True)"
            },
            {
              "name": "pack_command",
              "doc": "Pack a series of arguments into the Redis protocol",
              "signature": "(self, *args)"
            },
            {
              "name": "pack_commands",
              "doc": "Pack multiple commands into the Redis protocol",
              "signature": "(self, commands)"
            },
            {
              "name": "re_auth",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "read_response",
              "doc": "Read the response from a previously sent command",
              "signature": "(self, disable_decoding=False, *, disconnect_on_error=True, push_request=False)"
            },
            {
              "name": "register_connect_callback",
              "doc": "Register a callback to be called when the connection is established either\ninitially or reconnected.  This allows listeners to issue commands that\nare ephemeral to the connection, for example pub/sub subscription or\nkey tracking.  The callback must be a _method_ and will be kept as\na weak reference.",
              "signature": "(self, callback)"
            },
            {
              "name": "repr_pieces",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "send_command",
              "doc": "Pack and send a command to the Redis server",
              "signature": "(self, *args, **kwargs)"
            },
            {
              "name": "send_packed_command",
              "doc": "Send an already packed command to the Redis server",
              "signature": "(self, command, check_health=True)"
            },
            {
              "name": "set_parser",
              "doc": "Creates a new instance of parser_class with socket size:\n_socket_read_size and assigns it to the parser for the connection\n:param parser_class: The required parser class",
              "signature": "(self, parser_class)"
            },
            {
              "name": "set_re_auth_token",
              "doc": null,
              "signature": "(self, token: redis.auth.token.TokenInterface)"
            }
          ]
        },
        {
          "name": "UsernamePasswordCredentialProvider",
          "doc": "Simple implementation of CredentialProvider that just wraps static\nusername and password.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, username: Optional[str] = None, password: Optional[str] = None)"
            },
            {
              "name": "get_credentials",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "get_credentials_async",
              "doc": null,
              "signature": "(self) -> Union[Tuple[str], Tuple[str, str]]"
            }
          ]
        },
        {
          "name": "WatchError",
          "doc": "Common base class for all non-exit exceptions.",
          "functions": []
        }
      ]
    }
  },
  {
    "package": "typing_extensions",
    "base": {
      "functions": [
        {
          "name": "IntVar",
          "doc": null,
          "signature": "(name)"
        },
        {
          "name": "NamedTuple",
          "doc": "Typed version of namedtuple.\n\nUsage::\n\n    class Employee(NamedTuple):\n        name: str\n        id: int\n\nThis is equivalent to::\n\n    Employee = collections.namedtuple('Employee', ['name', 'id'])\n\nThe resulting class has an extra __annotations__ attribute, giving a\ndict that maps field names to types.  (The field names are also in\nthe _fields attribute, which is part of the namedtuple API.)\nAn alternative equivalent functional syntax is also accepted::\n\n    Employee = NamedTuple('Employee', [('name', str), ('id', int)])",
          "signature": "(typename, fields=<sentinel>, /, **kwargs)"
        },
        {
          "name": "_allow_reckless_class_checks",
          "doc": "Allow instance and class checks for special stdlib modules.\nThe abc and functools modules indiscriminately call isinstance() and\nissubclass() on the whole MRO of a user class, which may contain protocols.",
          "signature": "(depth=2)"
        },
        {
          "name": "_caller",
          "doc": null,
          "signature": "(depth=1, default='__main__')"
        },
        {
          "name": "_check_generic",
          "doc": "Check correct count for parameters of a generic cls (internal helper).\n\nThis gives a nice error message in case of count mismatch.",
          "signature": "(cls, parameters, elen)"
        },
        {
          "name": "_clean_optional",
          "doc": null,
          "signature": "(obj, hints, globalns=None, localns=None)"
        },
        {
          "name": "_collect_parameters",
          "doc": "Collect all type variables and parameter specifications in args\nin order of first appearance (lexicographic order).\n\nFor example::\n\n    assert _collect_parameters((T, Callable[P, T])) == (T, P)",
          "signature": "(args)"
        },
        {
          "name": "_concatenate_getitem",
          "doc": null,
          "signature": "(self, parameters)"
        },
        {
          "name": "_could_be_inserted_optional",
          "doc": "detects Union[..., None] pattern",
          "signature": "(t)"
        },
        {
          "name": "_create_concatenate_alias",
          "doc": null,
          "signature": "(origin, parameters)"
        },
        {
          "name": "_create_typeddict",
          "doc": null,
          "signature": "(typename, fields, /, *, typing_is_inline, total, closed, extra_items, **kwargs)"
        },
        {
          "name": "_eval_with_owner",
          "doc": null,
          "signature": "(forward_ref, *, owner=None, globals=None, locals=None, type_params=None)"
        },
        {
          "name": "_get_protocol_attrs",
          "doc": null,
          "signature": "(cls)"
        },
        {
          "name": "_get_typeddict_qualifiers",
          "doc": null,
          "signature": "(annotation_type)"
        },
        {
          "name": "_has_generic_or_protocol_as_origin",
          "doc": null,
          "signature": "() -> bool"
        },
        {
          "name": "_is_dunder",
          "doc": null,
          "signature": "(attr)"
        },
        {
          "name": "_is_param_expr",
          "doc": null,
          "signature": "(arg)"
        },
        {
          "name": "_is_unionable",
          "doc": "Corresponds to is_unionable() in unionobject.c in CPython.",
          "signature": "(obj)"
        },
        {
          "name": "_is_unpack",
          "doc": null,
          "signature": "(obj)"
        },
        {
          "name": "_is_unpacked_typevartuple",
          "doc": null,
          "signature": "(x) -> bool"
        },
        {
          "name": "_make_nmtuple",
          "doc": null,
          "signature": "(name, types, module, defaults=())"
        },
        {
          "name": "_namedtuple_mro_entries",
          "doc": null,
          "signature": "(bases)"
        },
        {
          "name": "_no_init",
          "doc": null,
          "signature": "(self, *args, **kwargs)"
        },
        {
          "name": "_overload_dummy",
          "doc": "Helper for @overload to raise when called.",
          "signature": "(*args, **kwds)"
        },
        {
          "name": "_set_default",
          "doc": null,
          "signature": "(type_param, default)"
        },
        {
          "name": "_set_module",
          "doc": null,
          "signature": "(typevarlike)"
        },
        {
          "name": "_should_collect_from_parameters",
          "doc": null,
          "signature": "(t)"
        },
        {
          "name": "_strip_extras",
          "doc": "Strips Annotated, Required and NotRequired from a given type.",
          "signature": "(t)"
        },
        {
          "name": "_type_check_issubclass_arg_1",
          "doc": "Raise TypeError if `arg` is not an instance of `type`\nin `issubclass(arg, <protocol>)`.\n\nIn most cases, this is verified by type.__subclasscheck__.\nChecking it again unnecessarily would slow down issubclass() checks,\nso, we don't perform this check unless we absolutely have to.\n\nFor various error paths, however,\nwe want to ensure that *this* error message is shown to the user\nwhere relevant, rather than a typing.py-specific error message.",
          "signature": "(arg)"
        },
        {
          "name": "_unpack_args",
          "doc": null,
          "signature": "(*args)"
        },
        {
          "name": "assert_never",
          "doc": "Statically assert that a line of code is unreachable.\n\nExample::\n\n    def int_or_str(arg: int | str) -> None:\n        match arg:\n            case int():\n                print(\"It's an int\")\n            case str():\n                print(\"It's a str\")\n            case _:\n                assert_never(arg)\n\nIf a type checker finds that a call to assert_never() is\nreachable, it will emit an error.\n\nAt runtime, this throws an exception when called.",
          "signature": "(arg: Never, /) -> Never"
        },
        {
          "name": "assert_type",
          "doc": "Ask a static type checker to confirm that the value is of the given type.\n\nAt runtime this does nothing: it returns the first argument unchanged with no\nchecks or side effects, no matter the actual type of the argument.\n\nWhen a static type checker encounters a call to assert_type(), it\nemits an error if the value is not of the specified type::\n\n    def greet(name: str) -> None:\n        assert_type(name, str)  # OK\n        assert_type(name, int)  # type checker error",
          "signature": "(val, typ, /)"
        },
        {
          "name": "cast",
          "doc": "Cast a value to a type.\n\nThis returns the value unchanged.  To the type checker this\nsignals that the return value has the designated type, but at\nruntime we intentionally don't check anything (we want this\nto be as fast as possible).",
          "signature": "(typ, val)"
        },
        {
          "name": "clear_overloads",
          "doc": "Clear all overloads in the registry.",
          "signature": "()"
        },
        {
          "name": "dataclass_transform",
          "doc": "Decorator that marks a function, class, or metaclass as providing\ndataclass-like behavior.\n\nExample:\n\n    from typing_extensions import dataclass_transform\n\n    _T = TypeVar(\"_T\")\n\n    # Used on a decorator function\n    @dataclass_transform()\n    def create_model(cls: type[_T]) -> type[_T]:\n        ...\n        return cls\n\n    @create_model\n    class CustomerModel:\n        id: int\n        name: str\n\n    # Used on a base class\n    @dataclass_transform()\n    class ModelBase: ...\n\n    class CustomerModel(ModelBase):\n        id: int\n        name: str\n\n    # Used on a metaclass\n    @dataclass_transform()\n    class ModelMeta(type): ...\n\n    class ModelBase(metaclass=ModelMeta): ...\n\n    class CustomerModel(ModelBase):\n        id: int\n        name: str\n\nEach of the ``CustomerModel`` classes defined in this example will now\nbehave similarly to a dataclass created with the ``@dataclasses.dataclass``\ndecorator. For example, the type checker will synthesize an ``__init__``\nmethod.\n\nThe arguments to this decorator can be used to customize this behavior:\n- ``eq_default`` indicates whether the ``eq`` parameter is assumed to be\n  True or False if it is omitted by the caller.\n- ``order_default`` indicates whether the ``order`` parameter is\n  assumed to be True or False if it is omitted by the caller.\n- ``kw_only_default`` indicates whether the ``kw_only`` parameter is\n  assumed to be True or False if it is omitted by the caller.\n- ``frozen_default`` indicates whether the ``frozen`` parameter is\n  assumed to be True or False if it is omitted by the caller.\n- ``field_specifiers`` specifies a static list of supported classes\n  or functions that describe fields, similar to ``dataclasses.field()``.\n\nAt runtime, this decorator records its arguments in the\n``__dataclass_transform__`` attribute on the decorated object.\n\nSee PEP 681 for details.",
          "signature": "(*, eq_default: bool = True, order_default: bool = False, kw_only_default: bool = False, frozen_default: bool = False, field_specifiers: Tuple[Union[Type[Any], Callable[..., Any]], ...] = (), **kwargs: Any) -> Callable[[~T], ~T]"
        },
        {
          "name": "disjoint_base",
          "doc": "This decorator marks a class as a disjoint base.\n\nChild classes of a disjoint base cannot inherit from other disjoint bases that are\nnot parent classes of the disjoint base.\n\nFor example:\n\n    @disjoint_base\n    class Disjoint1: pass\n\n    @disjoint_base\n    class Disjoint2: pass\n\n    class Disjoint3(Disjoint1, Disjoint2): pass  # Type checker error\n\nType checkers can use knowledge of disjoint bases to detect unreachable code\nand determine when two types can overlap.\n\nSee PEP 800.",
          "signature": "(cls)"
        },
        {
          "name": "evaluate_forward_ref",
          "doc": "Evaluate a forward reference as a type hint.\n\nThis is similar to calling the ForwardRef.evaluate() method,\nbut unlike that method, evaluate_forward_ref() also:\n\n* Recursively evaluates forward references nested within the type hint.\n* Rejects certain objects that are not valid type hints.\n* Replaces type hints that evaluate to None with types.NoneType.\n* Supports the *FORWARDREF* and *STRING* formats.\n\n*forward_ref* must be an instance of ForwardRef. *owner*, if given,\nshould be the object that holds the annotations that the forward reference\nderived from, such as a module, class object, or function. It is used to\ninfer the namespaces to use for looking up names. *globals* and *locals*\ncan also be explicitly given to provide the global and local namespaces.\n*type_params* is a tuple of type parameters that are in scope when\nevaluating the forward reference. This parameter must be provided (though\nit may be an empty tuple) if *owner* is not given and the forward reference\ndoes not already have an owner set. *format* specifies the format of the\nannotation and is a member of the annotationlib.Format enum.",
          "signature": "(forward_ref, *, owner=None, globals=None, locals=None, type_params=None, format=None, _recursive_guard=frozenset())"
        },
        {
          "name": "final",
          "doc": "Decorator to indicate final methods and final classes.\n\nUse this decorator to indicate to type checkers that the decorated\nmethod cannot be overridden, and decorated class cannot be subclassed.\n\nFor example::\n\n    class Base:\n        @final\n        def done(self) -> None:\n            ...\n    class Sub(Base):\n        def done(self) -> None:  # Error reported by type checker\n            ...\n\n    @final\n    class Leaf:\n        ...\n    class Other(Leaf):  # Error reported by type checker\n        ...\n\nThere is no runtime checking of these properties. The decorator\nattempts to set the ``__final__`` attribute to ``True`` on the decorated\nobject to allow runtime introspection.",
          "signature": "(f)"
        },
        {
          "name": "get_annotations",
          "doc": "Compute the annotations dict for an object.\n\nobj may be a callable, class, or module.\nPassing in an object of any other type raises TypeError.\n\nReturns a dict.  get_annotations() returns a new dict every time\nit's called; calling it twice on the same object will return two\ndifferent but equivalent dicts.\n\nThis is a backport of `inspect.get_annotations`, which has been\nin the standard library since Python 3.10. See the standard library\ndocumentation for more:\n\n    https://docs.python.org/3/library/inspect.html#inspect.get_annotations\n\nThis backport adds the *format* argument introduced by PEP 649. The\nthree formats supported are:\n* VALUE: the annotations are returned as-is. This is the default and\n  it is compatible with the behavior on previous Python versions.\n* FORWARDREF: return annotations as-is if possible, but replace any\n  undefined names with ForwardRef objects. The implementation proposed by\n  PEP 649 relies on language changes that cannot be backported; the\n  typing-extensions implementation simply returns the same result as VALUE.\n* STRING: return annotations as strings, in a format close to the original\n  source. Again, this behavior cannot be replicated directly in a backport.\n  As an approximation, typing-extensions retrieves the annotations under\n  VALUE semantics and then stringifies them.\n\nThe purpose of this backport is to allow users who would like to use\nFORWARDREF or STRING semantics once PEP 649 is implemented, but who also\nwant to support earlier Python versions, to simply write:\n\n    typing_extensions.get_annotations(obj, format=Format.FORWARDREF)",
          "signature": "(obj, *, globals=None, locals=None, eval_str=False, format=<Format.VALUE: 1>)"
        },
        {
          "name": "get_args",
          "doc": "Get type arguments with all substitutions performed.\n\nFor unions, basic simplifications used by Union constructor are performed.\n\nExamples::\n\n    >>> T = TypeVar('T')\n    >>> assert get_args(Dict[str, int]) == (str, int)\n    >>> assert get_args(int) == ()\n    >>> assert get_args(Union[int, Union[T, int], str][int]) == (int, str)\n    >>> assert get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])\n    >>> assert get_args(Callable[[], T][int]) == ([], int)",
          "signature": "(tp)"
        },
        {
          "name": "get_origin",
          "doc": "Get the unsubscripted version of a type.\n\nThis supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar,\nAnnotated, and others. Return None for unsupported types.\n\nExamples::\n\n    >>> P = ParamSpec('P')\n    >>> assert get_origin(Literal[42]) is Literal\n    >>> assert get_origin(int) is None\n    >>> assert get_origin(ClassVar[int]) is ClassVar\n    >>> assert get_origin(Generic) is Generic\n    >>> assert get_origin(Generic[T]) is Generic\n    >>> assert get_origin(Union[T, int]) is Union\n    >>> assert get_origin(List[Tuple[T, T]][int]) is list\n    >>> assert get_origin(P.args) is P",
          "signature": "(tp)"
        },
        {
          "name": "get_original_bases",
          "doc": "Return the class's \"original\" bases prior to modification by `__mro_entries__`.\n\nExamples::\n\n    from typing import TypeVar, Generic\n    from typing_extensions import NamedTuple, TypedDict\n\n    T = TypeVar(\"T\")\n    class Foo(Generic[T]): ...\n    class Bar(Foo[int], float): ...\n    class Baz(list[str]): ...\n    Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n    Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})\n\n    assert get_original_bases(Bar) == (Foo[int], float)\n    assert get_original_bases(Baz) == (list[str],)\n    assert get_original_bases(Eggs) == (NamedTuple,)\n    assert get_original_bases(Spam) == (TypedDict,)\n    assert get_original_bases(int) == (object,)",
          "signature": "(cls, /)"
        },
        {
          "name": "get_overloads",
          "doc": "Return all defined overloads for *func* as a sequence.",
          "signature": "(func)"
        },
        {
          "name": "get_protocol_members",
          "doc": "Return the set of members defined in a Protocol.\n\nExample::\n\n    >>> from typing_extensions import Protocol, get_protocol_members\n    >>> class P(Protocol):\n    ...     def a(self) -> str: ...\n    ...     b: int\n    >>> get_protocol_members(P)\n    frozenset({'a', 'b'})\n\nRaise a TypeError for arguments that are not Protocols.",
          "signature": "(tp: type, /) -> FrozenSet[str]"
        },
        {
          "name": "get_type_hints",
          "doc": "Return type hints for an object.\n\nThis is often the same as obj.__annotations__, but it handles\nforward references encoded as string literals, adds Optional[t] if a\ndefault value equal to None is set and recursively replaces all\n'Annotated[T, ...]', 'Required[T]' or 'NotRequired[T]' with 'T'\n(unless 'include_extras=True').\n\nThe argument may be a module, class, method, or function. The annotations\nare returned as a dictionary. For classes, annotations include also\ninherited members.\n\nTypeError is raised if the argument is not of a type that can contain\nannotations, and an empty dictionary is returned if no annotations are\npresent.\n\nBEWARE -- the behavior of globalns and localns is counterintuitive\n(unless you are familiar with how eval() and exec() work).  The\nsearch order is locals first, then globals.\n\n- If no dict arguments are passed, an attempt is made to use the\n  globals from obj (or the respective module's globals for classes),\n  and these are also used as the locals.  If the object does not appear\n  to have globals, an empty dictionary is used.\n\n- If one dict argument is passed, it is used for both globals and\n  locals.\n\n- If two dict arguments are passed, they specify globals and\n  locals, respectively.",
          "signature": "(obj, globalns=None, localns=None, include_extras=False)"
        },
        {
          "name": "is_protocol",
          "doc": "Return True if the given type is a Protocol.\n\nExample::\n\n    >>> from typing_extensions import Protocol, is_protocol\n    >>> class P(Protocol):\n    ...     def a(self) -> str: ...\n    ...     b: int\n    >>> is_protocol(P)\n    True\n    >>> is_protocol(int)\n    False",
          "signature": "(tp: type, /) -> bool"
        },
        {
          "name": "is_typeddict",
          "doc": "Check if an annotation is a TypedDict class\n\nFor example::\n    class Film(TypedDict):\n        title: str\n        year: int\n\n    is_typeddict(Film)  # => True\n    is_typeddict(Union[list, str])  # => False",
          "signature": "(tp)"
        },
        {
          "name": "no_type_check",
          "doc": "Decorator to indicate that annotations are not type hints.\n\nThe argument must be a class or function; if it is a class, it\napplies recursively to all methods and classes defined in that class\n(but not to methods defined in its superclasses or subclasses).\n\nThis mutates the function(s) or class(es) in place.",
          "signature": "(arg)"
        },
        {
          "name": "no_type_check_decorator",
          "doc": "Decorator to give another decorator the @no_type_check effect.\n\nThis wraps the decorator with something that wraps the decorated\nfunction in @no_type_check.",
          "signature": "(decorator)"
        },
        {
          "name": "overload",
          "doc": "Decorator for overloaded functions/methods.\n\nIn a stub file, place two or more stub definitions for the same\nfunction in a row, each decorated with @overload.\n\nFor example::\n\n    @overload\n    def utf8(value: None) -> None: ...\n    @overload\n    def utf8(value: bytes) -> bytes: ...\n    @overload\n    def utf8(value: str) -> bytes: ...\n\nIn a non-stub file (i.e. a regular .py file), do the same but\nfollow it with an implementation.  The implementation should *not*\nbe decorated with @overload::\n\n    @overload\n    def utf8(value: None) -> None: ...\n    @overload\n    def utf8(value: bytes) -> bytes: ...\n    @overload\n    def utf8(value: str) -> bytes: ...\n    def utf8(value):\n        ...  # implementation goes here\n\nThe overloads for a function can be retrieved at runtime using the\nget_overloads() function.",
          "signature": "(func)"
        },
        {
          "name": "override",
          "doc": "Indicate that a method is intended to override a method in a base class.\n\nUsage:\n\n    class Base:\n        def method(self) -> None:\n            pass\n\n    class Child(Base):\n        @override\n        def method(self) -> None:\n            super().method()\n\nWhen this decorator is applied to a method, the type checker will\nvalidate that it overrides a method with the same name on a base class.\nThis helps prevent bugs that may occur when a base class is changed\nwithout an equivalent change to a child class.\n\nThere is no runtime checking of these properties. The decorator\nsets the ``__override__`` attribute to ``True`` on the decorated object\nto allow runtime introspection.\n\nSee PEP 698 for details.",
          "signature": "(arg: ~_F, /) -> ~_F"
        },
        {
          "name": "reveal_type",
          "doc": "Ask a static type checker to reveal the inferred type of an expression.\n\nWhen a static type checker encounters a call to ``reveal_type()``,\nit will emit the inferred type of the argument::\n\n    x: int = 1\n    reveal_type(x)\n\nRunning a static type checker (e.g., mypy) on this example\nwill produce output similar to 'Revealed type is \"builtins.int\"'.\n\nAt runtime, the function prints the runtime type of the\nargument and returns the argument unchanged.",
          "signature": "(obj: ~T, /) -> ~T"
        },
        {
          "name": "runtime_checkable",
          "doc": "Mark a protocol class as a runtime protocol.\n\nSuch protocol can be used with isinstance() and issubclass().\nRaise TypeError if applied to a non-protocol class.\nThis allows a simple-minded structural check very similar to\none trick ponies in collections.abc such as Iterable.\n\nFor example::\n\n    @runtime_checkable\n    class Closable(Protocol):\n        def close(self): ...\n\n    assert isinstance(open('/some/file'), Closable)\n\nWarning: this will check only the presence of the required methods,\nnot their type signatures!",
          "signature": "(cls)"
        },
        {
          "name": "runtime_checkable",
          "doc": "Mark a protocol class as a runtime protocol.\n\nSuch protocol can be used with isinstance() and issubclass().\nRaise TypeError if applied to a non-protocol class.\nThis allows a simple-minded structural check very similar to\none trick ponies in collections.abc such as Iterable.\n\nFor example::\n\n    @runtime_checkable\n    class Closable(Protocol):\n        def close(self): ...\n\n    assert isinstance(open('/some/file'), Closable)\n\nWarning: this will check only the presence of the required methods,\nnot their type signatures!",
          "signature": "(cls)"
        },
        {
          "name": "type_repr",
          "doc": "Convert a Python value to a format suitable for use with the STRING format.\n\nThis is intended as a helper for tools that support the STRING format but do\nnot have access to the code that originally produced the annotations. It uses\nrepr() for most objects.",
          "signature": "(value)"
        }
      ],
      "classes": [
        {
          "name": "Annotated",
          "doc": "Add context-specific metadata to a type.\n\nExample: Annotated[int, runtime_check.Unsigned] indicates to the\nhypothetical runtime_check module that this type is an unsigned int.\nEvery other consumer of this type can ignore this metadata and treat\nthis type as int.\n\nThe first argument to Annotated must be a valid type.\n\nDetails:\n\n- It's an error to call `Annotated` with less than two arguments.\n- Access the metadata via the ``__metadata__`` attribute::\n\n    assert Annotated[int, '$'].__metadata__ == ('$',)\n\n- Nested Annotated types are flattened::\n\n    assert Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n- Instantiating an annotated type is equivalent to instantiating the\nunderlying type::\n\n    assert Annotated[C, Ann1](5) == C(5)\n\n- Annotated can be used as a generic type alias::\n\n    Optimized: TypeAlias = Annotated[T, runtime.Optimize()]\n    assert Optimized[int] == Annotated[int, runtime.Optimize()]\n\n    OptimizedList: TypeAlias = Annotated[list[T], runtime.Optimize()]\n    assert OptimizedList[int] == Annotated[list[int], runtime.Optimize()]\n\n- Annotated cannot be used with an unpacked TypeVarTuple::\n\n    Variadic: TypeAlias = Annotated[*Ts, Ann1]  # NOT valid\n\n  This would be equivalent to::\n\n    Annotated[T1, T2, T3, ..., Ann1]\n\n  where T1, T2 etc. are TypeVars, which would be invalid, because\n  only one type should be passed to Annotated.",
          "functions": []
        },
        {
          "name": "Any",
          "doc": "Special type indicating an unconstrained type.\n\n- Any is compatible with every type.\n- Any assumed to have all methods.\n- All values assumed to be instances of Any.\n\nNote that all the above statements are true from the point of view of\nstatic type checkers. At runtime, Any should not be used with instance\nchecks.",
          "functions": []
        },
        {
          "name": "BinaryIO",
          "doc": "Typed version of the return of open() in binary mode.",
          "functions": []
        },
        {
          "name": "Buffer",
          "doc": "Base class for classes that implement the buffer protocol.\n\nThe buffer protocol allows Python objects to expose a low-level\nmemory buffer interface. Before Python 3.12, it is not possible\nto implement the buffer protocol in pure Python code, or even\nto check whether a class implements the buffer protocol. In\nPython 3.12 and higher, the ``__buffer__`` method allows access\nto the buffer protocol from Python code, and the\n``collections.abc.Buffer`` ABC allows checking whether a class\nimplements the buffer protocol.\n\nTo indicate support for the buffer protocol in earlier versions,\ninherit from this ABC, either in a stub file or at runtime,\nor use ABC registration. This ABC provides no methods, because\nthere is no Python-accessible methods shared by pre-3.12 buffer\nclasses. It is useful primarily for static checks.",
          "functions": []
        },
        {
          "name": "PyCapsule",
          "doc": "Capsule objects let you wrap a C \"void *\" pointer in a Python\nobject.  They're a way of passing data through the Python interpreter\nwithout creating your own custom type.\n\nCapsules are used for communication between extension modules.\nThey provide a way for an extension module to export a C interface\nto other extension modules, so that extension modules can use the\nPython import mechanism to link to one another.",
          "functions": []
        },
        {
          "name": "Doc",
          "doc": "Define the documentation of a type annotation using ``Annotated``, to be\n used in class attributes, function and method parameters, return values,\n and variables.\n\nThe value should be a positional-only string literal to allow static tools\nlike editors and documentation generators to use it.\n\nThis complements docstrings.\n\nThe string value passed is available in the attribute ``documentation``.\n\nExample::\n\n    >>> from typing_extensions import Annotated, Doc\n    >>> def hi(to: Annotated[str, Doc(\"Who to say hi to\")]) -> None: ...",
          "functions": []
        },
        {
          "name": "Format",
          "doc": "Enum where members are also (and must be) ints",
          "functions": [
            {
              "name": "__dir__",
              "doc": "Returns public methods and other interesting attributes.",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, *args, **kwds)"
            },
            {
              "name": "__new__",
              "doc": "Create and return a new object.  See help(type) for accurate signature.",
              "signature": "(cls, value)"
            },
            {
              "name": "__reduce_ex__",
              "doc": "Helper for pickle.",
              "signature": "(self, proto)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "ForwardRef",
          "doc": "Internal wrapper to hold a forward reference.",
          "functions": []
        },
        {
          "name": "Generic",
          "doc": "Abstract base class for generic types.\n\nA generic type is typically declared by inheriting from\nthis class parameterized with one or more type variables.\nFor example, a generic mapping type might be defined as::\n\n  class Mapping(Generic[KT, VT]):\n      def __getitem__(self, key: KT) -> VT:\n          ...\n      # Etc.\n\nThis class can then be used as follows::\n\n  def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n      try:\n          return mapping[key]\n      except KeyError:\n          return default",
          "functions": []
        },
        {
          "name": "type",
          "doc": "type(object) -> the object's type\ntype(name, bases, dict, **kwds) -> a new type",
          "functions": []
        },
        {
          "name": "IO",
          "doc": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
          "functions": []
        },
        {
          "name": "NewType",
          "doc": "NewType creates simple unique types with almost zero runtime overhead.\n\nNewType(name, tp) is considered a subtype of tp\nby static type checkers. At runtime, NewType(name, tp) returns\na dummy callable that simply returns its argument.\n\nUsage::\n\n    UserId = NewType('UserId', int)\n\n    def name_by_id(user_id: UserId) -> str:\n        ...\n\n    UserId('user')          # Fails type check\n\n    name_by_id(42)          # Fails type check\n    name_by_id(UserId(42))  # OK\n\n    num = UserId(5) + 1     # type: int",
          "functions": []
        },
        {
          "name": "ParamSpec",
          "doc": "Parameter specification.",
          "functions": []
        },
        {
          "name": "ParamSpecArgs",
          "doc": "The args for a ParamSpec object.\n\nGiven a ParamSpec object P, P.args is an instance of ParamSpecArgs.\n\nParamSpecArgs objects have a reference back to their ParamSpec:\n\n   P.args.__origin__ is P\n\nThis type is meant for runtime introspection and has no special meaning to\nstatic type checkers.",
          "functions": []
        },
        {
          "name": "ParamSpecKwargs",
          "doc": "The kwargs for a ParamSpec object.\n\nGiven a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs.\n\nParamSpecKwargs objects have a reference back to their ParamSpec:\n\n   P.kwargs.__origin__ is P\n\nThis type is meant for runtime introspection and has no special meaning to\nstatic type checkers.",
          "functions": []
        },
        {
          "name": "Protocol",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": []
        },
        {
          "name": "Reader",
          "doc": "Protocol for simple I/O reader instances.\n\nThis protocol only supports blocking I/O.",
          "functions": []
        },
        {
          "name": "Sentinel",
          "doc": "Create a unique sentinel object.\n\n*name* should be the name of the variable to which the return value shall be assigned.\n\n*repr*, if supplied, will be used for the repr of the sentinel object.\nIf not provided, \"<name>\" will be used.",
          "functions": []
        },
        {
          "name": "SupportsAbs",
          "doc": "An ABC with one abstract method __abs__ that is covariant in its return type.",
          "functions": []
        },
        {
          "name": "SupportsBytes",
          "doc": "An ABC with one abstract method __bytes__.",
          "functions": []
        },
        {
          "name": "SupportsComplex",
          "doc": "An ABC with one abstract method __complex__.",
          "functions": []
        },
        {
          "name": "SupportsFloat",
          "doc": "An ABC with one abstract method __float__.",
          "functions": []
        },
        {
          "name": "SupportsIndex",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": []
        },
        {
          "name": "SupportsInt",
          "doc": "An ABC with one abstract method __int__.",
          "functions": []
        },
        {
          "name": "SupportsRound",
          "doc": "An ABC with one abstract method __round__ that is covariant in its return type.",
          "functions": []
        },
        {
          "name": "str",
          "doc": "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
          "functions": []
        },
        {
          "name": "TextIO",
          "doc": "Typed version of the return of open() in text mode.",
          "functions": []
        },
        {
          "name": "TypeAliasType",
          "doc": "Create named, parameterized type aliases.\n\nThis provides a backport of the new `type` statement in Python 3.12:\n\n    type ListOrSet[T] = list[T] | set[T]\n\nis equivalent to:\n\n    T = TypeVar(\"T\")\n    ListOrSet = TypeAliasType(\"ListOrSet\", list[T] | set[T], type_params=(T,))\n\nThe name ListOrSet can then be used as an alias for the type it refers to.\n\nThe type_params argument should contain all the type parameters used\nin the value of the type alias. If the alias is not generic, this\nargument is omitted.\n\nStatic type checkers should only support type aliases declared using\nTypeAliasType that follow these rules:\n\n- The first argument (the name) must be a string literal.\n- The TypeAliasType instance must be immediately assigned to a variable\n  of the same name. (For example, 'X = TypeAliasType(\"Y\", int)' is invalid,\n  as is 'X, Y = TypeAliasType(\"X\", int), TypeAliasType(\"Y\", int)').",
          "functions": []
        },
        {
          "name": "TypeVar",
          "doc": "Type variable.",
          "functions": []
        },
        {
          "name": "TypeVarTuple",
          "doc": "Type variable tuple.",
          "functions": []
        },
        {
          "name": "Writer",
          "doc": "Protocol for simple I/O writer instances.\n\nThis protocol only supports blocking I/O.",
          "functions": []
        },
        {
          "name": "_AnnotatedAlias",
          "doc": "Runtime representation of an annotated type.\n\nAt its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'\nwith extra annotations. The alias behaves like a normal typing alias.\nInstantiating is the same as instantiating the underlying type; binding\nit to types is also the same.\n\nThe metadata itself is stored in a '__metadata__' attribute as a tuple.",
          "functions": []
        },
        {
          "name": "PyCapsule",
          "doc": "Capsule objects let you wrap a C \"void *\" pointer in a Python\nobject.  They're a way of passing data through the Python interpreter\nwithout creating your own custom type.\n\nCapsules are used for communication between extension modules.\nThey provide a way for an extension module to export a C interface\nto other extension modules, so that extension modules can use the\nPython import mechanism to link to one another.",
          "functions": []
        },
        {
          "name": "_ConcatenateGenericAlias",
          "doc": "The central part of the internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated;\nthis is used by e.g. typing.List and typing.Dict.",
          "functions": []
        },
        {
          "name": "_DefaultMixin",
          "doc": "Mixin for TypeVarLike defaults.",
          "functions": []
        },
        {
          "name": "_EllipsisDummy",
          "doc": null,
          "functions": []
        },
        {
          "name": "_ExtensionsSpecialForm",
          "doc": null,
          "functions": []
        },
        {
          "name": "NamedTuple",
          "doc": null,
          "functions": []
        },
        {
          "name": "_NamedTupleMeta",
          "doc": "type(object) -> the object's type\ntype(name, bases, dict, **kwds) -> a new type",
          "functions": []
        },
        {
          "name": "NoneType",
          "doc": null,
          "functions": []
        },
        {
          "name": "_ProtocolMeta",
          "doc": "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super()).",
          "functions": [
            {
              "name": "_abc_caches_clear",
              "doc": "Clear the caches (for debugging or testing).",
              "signature": "(cls)"
            },
            {
              "name": "_abc_registry_clear",
              "doc": "Clear the registry (for debugging or testing).",
              "signature": "(cls)"
            },
            {
              "name": "_dump_registry",
              "doc": "Debug helper to print the ABC registry.",
              "signature": "(cls, file=None)"
            },
            {
              "name": "register",
              "doc": "Register a virtual subclass of an ABC.\n\nReturns the subclass, to allow usage as a class decorator.",
              "signature": "(cls, subclass)"
            }
          ]
        },
        {
          "name": "_Sentinel",
          "doc": null,
          "functions": []
        },
        {
          "name": "_SpecialForm",
          "doc": null,
          "functions": []
        },
        {
          "name": "_SpecialGenericAlias",
          "doc": "Mixin to prevent iteration, without being compatible with Iterable.\n\nThat is, we could do::\n\n    def __iter__(self): raise TypeError()\n\nBut this would make users of this mixin duck type-compatible with\ncollections.abc.Iterable - isinstance(foo, Iterable) would be True.\n\nLuckily, we can instead prevent iteration by setting __iter__ to None, which\nis treated specially.",
          "functions": []
        },
        {
          "name": "_TypeFormForm",
          "doc": null,
          "functions": []
        },
        {
          "name": "_TypeVarLikeMeta",
          "doc": "type(object) -> the object's type\ntype(name, bases, dict, **kwds) -> a new type",
          "functions": []
        },
        {
          "name": "TypedDict",
          "doc": null,
          "functions": []
        },
        {
          "name": "_TypedDictMeta",
          "doc": "type(object) -> the object's type\ntype(name, bases, dict, **kwds) -> a new type",
          "functions": []
        },
        {
          "name": "_TypedDictSpecialForm",
          "doc": null,
          "functions": []
        },
        {
          "name": "_UnpackAlias",
          "doc": "The central part of the internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated;\nthis is used by e.g. typing.List and typing.Dict.",
          "functions": []
        },
        {
          "name": "_UnpackSpecialForm",
          "doc": null,
          "functions": []
        },
        {
          "name": "deprecated",
          "doc": "Indicate that a class, function or overload is deprecated.\n\nWhen this decorator is applied to an object, the type checker\nwill generate a diagnostic on usage of the deprecated object.\n\nUsage:\n\n    @deprecated(\"Use B instead\")\n    class A:\n        pass\n\n    @deprecated(\"Use g instead\")\n    def f():\n        pass\n\n    @overload\n    @deprecated(\"int support is deprecated\")\n    def g(x: int) -> int: ...\n    @overload\n    def g(x: str) -> int: ...\n\nThe warning specified by *category* will be emitted at runtime\non use of deprecated objects. For functions, that happens on calls;\nfor classes, on instantiation and on creation of subclasses.\nIf the *category* is ``None``, no warning is emitted at runtime.\nThe *stacklevel* determines where the\nwarning is emitted. If it is ``1`` (the default), the warning\nis emitted at the direct caller of the deprecated object; if it\nis higher, it is emitted further up the stack.\nStatic type checker behavior is not affected by the *category*\nand *stacklevel* arguments.\n\nThe deprecation message passed to the decorator is saved in the\n``__deprecated__`` attribute on the decorated object.\nIf applied to an overload, the decorator\nmust be after the ``@overload`` decorator for the attribute to\nexist on the overload as returned by ``get_overloads()``.\n\nSee PEP 702 for details.",
          "functions": []
        }
      ]
    }
  },
  {
    "package": "anyio",
    "base": {
      "functions": [
        {
          "name": "__getattr__",
          "doc": "Support deprecated aliases.",
          "signature": "(attr: 'str') -> 'type[BrokenWorkerInterpreter]'"
        },
        {
          "name": "aclose_forcefully",
          "doc": "Close an asynchronous resource in a cancelled scope.\n\nDoing this closes the resource without waiting on anything.\n\n:param resource: the resource to close",
          "signature": "(resource: 'AsyncResource') -> 'None'"
        },
        {
          "name": "as_connectable",
          "doc": "Return a byte stream connectable from the given object.\n\nIf a bytestream connectable is given, it is returned unchanged.\nIf a tuple of (host, port) is given, a TCP connectable is returned.\nIf a string or bytes path is given, a UNIX connectable is returned.\n\nIf ``tls=True``, the connectable will be wrapped in a\n:class:`~.streams.tls.TLSConnectable`.\n\n:param remote: a connectable, a tuple of (host, port) or a path to a UNIX socket\n:param tls: if ``True``, wrap the plaintext connectable in a\n    :class:`~.streams.tls.TLSConnectable`, using the provided TLS settings)\n:param ssl_context: if ``tls=True``, the SSLContext object to use  (if not provided,\n    a secure default will be created)\n:param tls_hostname: if ``tls=True``, host name of the server to use for checking\n    the server certificate (defaults to the host portion of the address for TCP\n    connectables)\n:param tls_standard_compatible: if ``False`` and ``tls=True``, makes the TLS stream\n    skip the closing handshake when closing the connection, so it won't raise an\n    exception if the server does the same",
          "signature": "(remote: 'ByteStreamConnectable | tuple[str | IPv4Address | IPv6Address, int] | str | bytes | PathLike[str]', /, *, tls: 'bool' = False, ssl_context: 'ssl.SSLContext | None' = None, tls_hostname: 'str | None' = None, tls_standard_compatible: 'bool' = True) -> 'ByteStreamConnectable'"
        },
        {
          "name": "connect_tcp",
          "doc": "Connect to a host using the TCP protocol.\n\nThis function implements the stateless version of the Happy Eyeballs algorithm (RFC\n6555). If ``remote_host`` is a host name that resolves to multiple IP addresses,\neach one is tried until one connection attempt succeeds. If the first attempt does\nnot connected within 250 milliseconds, a second attempt is started using the next\naddress in the list, and so on. On IPv6 enabled systems, an IPv6 address (if\navailable) is tried first.\n\nWhen the connection has been established, a TLS handshake will be done if either\n``ssl_context`` or ``tls_hostname`` is not ``None``, or if ``tls`` is ``True``.\n\n:param remote_host: the IP address or host name to connect to\n:param remote_port: port on the target host to connect to\n:param local_host: the interface address or name to bind the socket to before\n    connecting\n:param tls: ``True`` to do a TLS handshake with the connected stream and return a\n    :class:`~anyio.streams.tls.TLSStream` instead\n:param ssl_context: the SSL context object to use (if omitted, a default context is\n    created)\n:param tls_standard_compatible: If ``True``, performs the TLS shutdown handshake\n    before closing the stream and requires that the server does this as well.\n    Otherwise, :exc:`~ssl.SSLEOFError` may be raised during reads from the stream.\n    Some protocols, such as HTTP, require this option to be ``False``.\n    See :meth:`~ssl.SSLContext.wrap_socket` for details.\n:param tls_hostname: host name to check the server certificate against (defaults to\n    the value of ``remote_host``)\n:param happy_eyeballs_delay: delay (in seconds) before starting the next connection\n    attempt\n:return: a socket stream object if no TLS handshake was done, otherwise a TLS stream\n:raises ConnectionFailed: if the connection fails",
          "signature": "(remote_host: 'IPAddressType', remote_port: 'int', *, local_host: 'IPAddressType | None' = None, tls: 'bool' = False, ssl_context: 'ssl.SSLContext | None' = None, tls_standard_compatible: 'bool' = True, tls_hostname: 'str | None' = None, happy_eyeballs_delay: 'float' = 0.25) -> 'SocketStream | TLSStream'"
        },
        {
          "name": "connect_unix",
          "doc": "Connect to the given UNIX socket.\n\nNot available on Windows.\n\n:param path: path to the socket\n:return: a socket stream object\n:raises ConnectionFailed: if the connection fails",
          "signature": "(path: 'str | bytes | PathLike[Any]') -> 'UNIXSocketStream'"
        },
        {
          "name": "create_connected_udp_socket",
          "doc": "Create a connected UDP socket.\n\nConnected UDP sockets can only communicate with the specified remote host/port, an\nany packets sent from other sources are dropped.\n\n:param remote_host: remote host to set as the default target\n:param remote_port: port on the remote host to set as the default target\n:param family: address family (``AF_INET`` or ``AF_INET6``) \u2013 automatically\n    determined from ``local_host`` or ``remote_host`` if omitted\n:param local_host: IP address or host name of the local interface to bind to\n:param local_port: local port to bind to\n:param reuse_port: ``True`` to allow multiple sockets to bind to the same\n    address/port (not supported on Windows)\n:return: a connected UDP socket",
          "signature": "(remote_host: 'IPAddressType', remote_port: 'int', *, family: 'AnyIPAddressFamily' = <AddressFamily.AF_UNSPEC: 0>, local_host: 'IPAddressType | None' = None, local_port: 'int' = 0, reuse_port: 'bool' = False) -> 'ConnectedUDPSocket'"
        },
        {
          "name": "create_connected_unix_datagram_socket",
          "doc": "Create a connected UNIX datagram socket.\n\nConnected datagram sockets can only communicate with the specified remote path.\n\nIf ``local_path`` has been given, the socket will be bound to this path, making\nthis socket suitable for receiving datagrams from other processes. Other processes\ncan send datagrams to this socket only if ``local_path`` is set.\n\nIf a socket already exists on the file system in the ``local_path``, it will be\nremoved first.\n\n:param remote_path: the path to set as the default target\n:param local_path: the path on which to bind to\n:param local_mode: permissions to set on the local socket\n:return: a connected UNIX datagram socket",
          "signature": "(remote_path: 'str | bytes | PathLike[Any]', *, local_path: 'None | str | bytes | PathLike[Any]' = None, local_mode: 'int | None' = None) -> 'ConnectedUNIXDatagramSocket'"
        },
        {
          "name": "create_task_group",
          "doc": "Create a task group.\n\n:return: a task group",
          "signature": "() -> 'TaskGroup'"
        },
        {
          "name": "create_tcp_listener",
          "doc": "Create a TCP socket listener.\n\n:param local_port: port number to listen on\n:param local_host: IP address of the interface to listen on. If omitted, listen on\n    all IPv4 and IPv6 interfaces. To listen on all interfaces on a specific address\n    family, use ``0.0.0.0`` for IPv4 or ``::`` for IPv6.\n:param family: address family (used if ``local_host`` was omitted)\n:param backlog: maximum number of queued incoming connections (up to a maximum of\n    2**16, or 65536)\n:param reuse_port: ``True`` to allow multiple sockets to bind to the same\n    address/port (not supported on Windows)\n:return: a multi-listener object containing one or more socket listeners",
          "signature": "(*, local_host: 'IPAddressType | None' = None, local_port: 'int' = 0, family: 'AnyIPAddressFamily' = <AddressFamily.AF_UNSPEC: 0>, backlog: 'int' = 65536, reuse_port: 'bool' = False) -> 'MultiListener[SocketStream]'"
        },
        {
          "name": "create_udp_socket",
          "doc": "Create a UDP socket.\n\nIf ``port`` has been given, the socket will be bound to this port on the local\nmachine, making this socket suitable for providing UDP based services.\n\n:param family: address family (``AF_INET`` or ``AF_INET6``) \u2013 automatically\n    determined from ``local_host`` if omitted\n:param local_host: IP address or host name of the local interface to bind to\n:param local_port: local port to bind to\n:param reuse_port: ``True`` to allow multiple sockets to bind to the same\n    address/port (not supported on Windows)\n:return: a UDP socket",
          "signature": "(family: 'AnyIPAddressFamily' = <AddressFamily.AF_UNSPEC: 0>, *, local_host: 'IPAddressType | None' = None, local_port: 'int' = 0, reuse_port: 'bool' = False) -> 'UDPSocket'"
        },
        {
          "name": "create_unix_datagram_socket",
          "doc": "Create a UNIX datagram socket.\n\nNot available on Windows.\n\nIf ``local_path`` has been given, the socket will be bound to this path, making this\nsocket suitable for receiving datagrams from other processes. Other processes can\nsend datagrams to this socket only if ``local_path`` is set.\n\nIf a socket already exists on the file system in the ``local_path``, it will be\nremoved first.\n\n:param local_path: the path on which to bind to\n:param local_mode: permissions to set on the local socket\n:return: a UNIX datagram socket",
          "signature": "(*, local_path: 'None | str | bytes | PathLike[Any]' = None, local_mode: 'int | None' = None) -> 'UNIXDatagramSocket'"
        },
        {
          "name": "create_unix_listener",
          "doc": "Create a UNIX socket listener.\n\nNot available on Windows.\n\n:param path: path of the socket\n:param mode: permissions to set on the socket\n:param backlog: maximum number of queued incoming connections (up to a maximum of\n    2**16, or 65536)\n:return: a listener object\n\n.. versionchanged:: 3.0\n    If a socket already exists on the file system in the given path, it will be\n    removed first.",
          "signature": "(path: 'str | bytes | PathLike[Any]', *, mode: 'int | None' = None, backlog: 'int' = 65536) -> 'SocketListener'"
        },
        {
          "name": "current_effective_deadline",
          "doc": "Return the nearest deadline among all the cancel scopes effective for the current\ntask.\n\n:return: a clock value from the event loop's internal clock (or ``float('inf')`` if\n    there is no deadline in effect, or ``float('-inf')`` if the current scope has\n    been cancelled)\n:rtype: float",
          "signature": "() -> 'float'"
        },
        {
          "name": "current_time",
          "doc": "Return the current value of the event loop's internal clock.\n\n:return: the clock value (seconds)",
          "signature": "() -> 'float'"
        },
        {
          "name": "fail_after",
          "doc": "Create a context manager which raises a :class:`TimeoutError` if does not finish in\ntime.\n\n:param delay: maximum allowed time (in seconds) before raising the exception, or\n    ``None`` to disable the timeout\n:param shield: ``True`` to shield the cancel scope from external cancellation\n:return: a context manager that yields a cancel scope\n:rtype: :class:`~typing.ContextManager`\\[:class:`~anyio.CancelScope`\\]",
          "signature": "(delay: 'float | None', shield: 'bool' = False) -> 'Generator[CancelScope, None, None]'"
        },
        {
          "name": "get_all_backends",
          "doc": "Return a tuple of the names of all built-in backends.",
          "signature": "() -> 'tuple[str, ...]'"
        },
        {
          "name": "get_cancelled_exc_class",
          "doc": "Return the current async library's cancellation exception class.",
          "signature": "() -> 'type[BaseException]'"
        },
        {
          "name": "get_current_task",
          "doc": "Return the current task.\n\n:return: a representation of the current task",
          "signature": "() -> 'TaskInfo'"
        },
        {
          "name": "get_running_tasks",
          "doc": "Return a list of running tasks in the current event loop.\n\n:return: a list of task info objects",
          "signature": "() -> 'list[TaskInfo]'"
        },
        {
          "name": "getaddrinfo",
          "doc": "Look up a numeric IP address given a host name.\n\nInternationalized domain names are translated according to the (non-transitional)\nIDNA 2008 standard.\n\n.. note:: 4-tuple IPv6 socket addresses are automatically converted to 2-tuples of\n    (host, port), unlike what :func:`socket.getaddrinfo` does.\n\n:param host: host name\n:param port: port number\n:param family: socket family (`'AF_INET``, ...)\n:param type: socket type (``SOCK_STREAM``, ...)\n:param proto: protocol number\n:param flags: flags to pass to upstream ``getaddrinfo()``\n:return: list of tuples containing (family, type, proto, canonname, sockaddr)\n\n.. seealso:: :func:`socket.getaddrinfo`",
          "signature": "(host: 'bytes | str | None', port: 'str | int | None', *, family: 'int | AddressFamily' = 0, type: 'int | SocketKind' = 0, proto: 'int' = 0, flags: 'int' = 0) -> 'list[tuple[AddressFamily, SocketKind, int, str, tuple[str, int]]]'"
        },
        {
          "name": "getnameinfo",
          "doc": "Look up the host name of an IP address.\n\n:param sockaddr: socket address (e.g. (ipaddress, port) for IPv4)\n:param flags: flags to pass to upstream ``getnameinfo()``\n:return: a tuple of (host name, service name)\n\n.. seealso:: :func:`socket.getnameinfo`",
          "signature": "(sockaddr: 'IPSockAddrType', flags: 'int' = 0) -> 'Awaitable[tuple[str, str]]'"
        },
        {
          "name": "gettempdir",
          "doc": "Asynchronously return the name of the directory used for temporary files.\n\nThis function wraps `tempfile.gettempdir` and executes it in a background thread.\n\n:return: The path of the temporary directory as a string.",
          "signature": "() -> 'str'"
        },
        {
          "name": "gettempdirb",
          "doc": "Asynchronously return the name of the directory used for temporary files in bytes.\n\nThis function wraps `tempfile.gettempdirb` and executes it in a background thread.\n\n:return: The path of the temporary directory as bytes.",
          "signature": "() -> 'bytes'"
        },
        {
          "name": "mkdtemp",
          "doc": "Asynchronously create a temporary directory and return its path.\n\nThis function wraps `tempfile.mkdtemp` and executes it in a background thread.\n\n:param suffix: Suffix to be added to the directory name.\n:param prefix: Prefix to be added to the directory name.\n:param dir: Parent directory where the temporary directory is created.\n:return: The path of the created temporary directory.",
          "signature": "(suffix: 'AnyStr | None' = None, prefix: 'AnyStr | None' = None, dir: 'AnyStr | None' = None) -> 'str | bytes'"
        },
        {
          "name": "mkstemp",
          "doc": "Asynchronously create a temporary file and return an OS-level handle and the file\nname.\n\nThis function wraps `tempfile.mkstemp` and executes it in a background thread.\n\n:param suffix: Suffix to be added to the file name.\n:param prefix: Prefix to be added to the file name.\n:param dir: Directory in which the temporary file is created.\n:param text: Whether the file is opened in text mode.\n:return: A tuple containing the file descriptor and the file name.",
          "signature": "(suffix: 'AnyStr | None' = None, prefix: 'AnyStr | None' = None, dir: 'AnyStr | None' = None, text: 'bool' = False) -> 'tuple[int, str | bytes]'"
        },
        {
          "name": "move_on_after",
          "doc": "Create a cancel scope with a deadline that expires after the given delay.\n\n:param delay: maximum allowed time (in seconds) before exiting the context block, or\n    ``None`` to disable the timeout\n:param shield: ``True`` to shield the cancel scope from external cancellation\n:return: a cancel scope",
          "signature": "(delay: 'float | None', shield: 'bool' = False) -> 'CancelScope'"
        },
        {
          "name": "notify_closing",
          "doc": "Call this before closing a file descriptor (on Unix) or socket (on\nWindows). This will cause any `wait_readable` or `wait_writable`\ncalls on the given object to immediately wake up and raise\n`~anyio.ClosedResourceError`.\n\nThis doesn't actually close the object \u2013 you still have to do that\nyourself afterwards. Also, you want to be careful to make sure no\nnew tasks start waiting on the object in between when you call this\nand when it's actually closed. So to close something properly, you\nusually want to do these steps in order:\n\n1. Explicitly mark the object as closed, so that any new attempts\n   to use it will abort before they start.\n2. Call `notify_closing` to wake up any already-existing users.\n3. Actually close the object.\n\nIt's also possible to do them in a different order if that's more\nconvenient, *but only if* you make sure not to have any checkpoints in\nbetween the steps. This way they all happen in a single atomic\nstep, so other tasks won't be able to tell what order they happened\nin anyway.\n\n:param obj: an object with a ``.fileno()`` method or an integer handle",
          "signature": "(obj: 'FileDescriptorLike') -> 'None'"
        },
        {
          "name": "open_file",
          "doc": "Open a file asynchronously.\n\nThe arguments are exactly the same as for the builtin :func:`open`.\n\n:return: an asynchronous file object",
          "signature": "(file: 'str | PathLike[str] | int', mode: 'str' = 'r', buffering: 'int' = -1, encoding: 'str | None' = None, errors: 'str | None' = None, newline: 'str | None' = None, closefd: 'bool' = True, opener: 'Callable[[str, int], int] | None' = None) -> 'AsyncFile[Any]'"
        },
        {
          "name": "open_process",
          "doc": "Start an external command in a subprocess.\n\n.. seealso:: :class:`subprocess.Popen`\n\n:param command: either a string to pass to the shell, or an iterable of strings\n    containing the executable name or path and its arguments\n:param stdin: one of :data:`subprocess.PIPE`, :data:`subprocess.DEVNULL`, a\n    file-like object, or ``None``\n:param stdout: one of :data:`subprocess.PIPE`, :data:`subprocess.DEVNULL`,\n    a file-like object, or ``None``\n:param stderr: one of :data:`subprocess.PIPE`, :data:`subprocess.DEVNULL`,\n    :data:`subprocess.STDOUT`, a file-like object, or ``None``\n:param cwd: If not ``None``, the working directory is changed before executing\n:param env: If env is not ``None``, it must be a mapping that defines the\n    environment variables for the new process\n:param creationflags: flags that can be used to control the creation of the\n    subprocess (see :class:`subprocess.Popen` for the specifics)\n:param startupinfo: an instance of :class:`subprocess.STARTUPINFO` that can be used\n    to specify process startup parameters (Windows only)\n:param start_new_session: if ``true`` the setsid() system call will be made in the\n    child process prior to the execution of the subprocess. (POSIX only)\n:param pass_fds: sequence of file descriptors to keep open between the parent and\n    child processes. (POSIX only)\n:param user: effective user to run the process as (POSIX only)\n:param group: effective group to run the process as (POSIX only)\n:param extra_groups: supplementary groups to set in the subprocess (POSIX only)\n:param umask: if not negative, this umask is applied in the child process before\n    running the given command (POSIX only)\n:return: an asynchronous process object",
          "signature": "(command: 'StrOrBytesPath | Sequence[StrOrBytesPath]', *, stdin: 'int | IO[Any] | None' = -1, stdout: 'int | IO[Any] | None' = -1, stderr: 'int | IO[Any] | None' = -1, cwd: 'StrOrBytesPath | None' = None, env: 'Mapping[str, str] | None' = None, startupinfo: 'Any' = None, creationflags: 'int' = 0, start_new_session: 'bool' = False, pass_fds: 'Sequence[int]' = (), user: 'str | int | None' = None, group: 'str | int | None' = None, extra_groups: 'Iterable[str | int] | None' = None, umask: 'int' = -1) -> 'Process'"
        },
        {
          "name": "open_signal_receiver",
          "doc": "Start receiving operating system signals.\n\n:param signals: signals to receive (e.g. ``signal.SIGINT``)\n:return: an asynchronous context manager for an asynchronous iterator which yields\n    signal numbers\n\n.. warning:: Windows does not support signals natively so it is best to avoid\n    relying on this in cross-platform applications.\n\n.. warning:: On asyncio, this permanently replaces any previous signal handler for\n    the given signals, as set via :meth:`~asyncio.loop.add_signal_handler`.",
          "signature": "(*signals: 'Signals') -> 'AbstractContextManager[AsyncIterator[Signals]]'"
        },
        {
          "name": "run",
          "doc": "Run the given coroutine function in an asynchronous event loop.\n\nThe current thread must not be already running an event loop.\n\n:param func: a coroutine function\n:param args: positional arguments to ``func``\n:param backend: name of the asynchronous event loop implementation \u2013 currently\n    either ``asyncio`` or ``trio``\n:param backend_options: keyword arguments to call the backend ``run()``\n    implementation with (documented :ref:`here <backend options>`)\n:return: the return value of the coroutine function\n:raises RuntimeError: if an asynchronous event loop is already running in this\n    thread\n:raises LookupError: if the named backend is not found",
          "signature": "(func: 'Callable[[Unpack[PosArgsT]], Awaitable[T_Retval]]', *args: 'Unpack[PosArgsT]', backend: 'str' = 'asyncio', backend_options: 'dict[str, Any] | None' = None) -> 'T_Retval'"
        },
        {
          "name": "run_process",
          "doc": "Run an external command in a subprocess and wait until it completes.\n\n.. seealso:: :func:`subprocess.run`\n\n:param command: either a string to pass to the shell, or an iterable of strings\n    containing the executable name or path and its arguments\n:param input: bytes passed to the standard input of the subprocess\n:param stdin: one of :data:`subprocess.PIPE`, :data:`subprocess.DEVNULL`,\n    a file-like object, or `None`; ``input`` overrides this\n:param stdout: one of :data:`subprocess.PIPE`, :data:`subprocess.DEVNULL`,\n    a file-like object, or `None`\n:param stderr: one of :data:`subprocess.PIPE`, :data:`subprocess.DEVNULL`,\n    :data:`subprocess.STDOUT`, a file-like object, or `None`\n:param check: if ``True``, raise :exc:`~subprocess.CalledProcessError` if the\n    process terminates with a return code other than 0\n:param cwd: If not ``None``, change the working directory to this before running the\n    command\n:param env: if not ``None``, this mapping replaces the inherited environment\n    variables from the parent process\n:param startupinfo: an instance of :class:`subprocess.STARTUPINFO` that can be used\n    to specify process startup parameters (Windows only)\n:param creationflags: flags that can be used to control the creation of the\n    subprocess (see :class:`subprocess.Popen` for the specifics)\n:param start_new_session: if ``true`` the setsid() system call will be made in the\n    child process prior to the execution of the subprocess. (POSIX only)\n:param pass_fds: sequence of file descriptors to keep open between the parent and\n    child processes. (POSIX only)\n:param user: effective user to run the process as (Python >= 3.9, POSIX only)\n:param group: effective group to run the process as (Python >= 3.9, POSIX only)\n:param extra_groups: supplementary groups to set in the subprocess (Python >= 3.9,\n    POSIX only)\n:param umask: if not negative, this umask is applied in the child process before\n    running the given command (Python >= 3.9, POSIX only)\n:return: an object representing the completed process\n:raises ~subprocess.CalledProcessError: if ``check`` is ``True`` and the process\n    exits with a nonzero return code",
          "signature": "(command: 'StrOrBytesPath | Sequence[StrOrBytesPath]', *, input: 'bytes | None' = None, stdin: 'int | IO[Any] | None' = None, stdout: 'int | IO[Any] | None' = -1, stderr: 'int | IO[Any] | None' = -1, check: 'bool' = True, cwd: 'StrOrBytesPath | None' = None, env: 'Mapping[str, str] | None' = None, startupinfo: 'Any' = None, creationflags: 'int' = 0, start_new_session: 'bool' = False, pass_fds: 'Sequence[int]' = (), user: 'str | int | None' = None, group: 'str | int | None' = None, extra_groups: 'Iterable[str | int] | None' = None, umask: 'int' = -1) -> 'CompletedProcess[bytes]'"
        },
        {
          "name": "sleep",
          "doc": "Pause the current task for the specified duration.\n\n:param delay: the duration, in seconds",
          "signature": "(delay: 'float') -> 'None'"
        },
        {
          "name": "sleep_forever",
          "doc": "Pause the current task until it's cancelled.\n\nThis is a shortcut for ``sleep(math.inf)``.\n\n.. versionadded:: 3.1",
          "signature": "() -> 'None'"
        },
        {
          "name": "sleep_until",
          "doc": "Pause the current task until the given time.\n\n:param deadline: the absolute time to wake up at (according to the internal\n    monotonic clock of the event loop)\n\n.. versionadded:: 3.1",
          "signature": "(deadline: 'float') -> 'None'"
        },
        {
          "name": "typed_attribute",
          "doc": "Return a unique object, used to mark typed attributes.",
          "signature": "() -> 'Any'"
        },
        {
          "name": "wait_all_tasks_blocked",
          "doc": "Wait until all other tasks are waiting for something.",
          "signature": "() -> 'None'"
        },
        {
          "name": "wait_readable",
          "doc": "Wait until the given object has data to be read.\n\nOn Unix systems, ``obj`` must either be an integer file descriptor, or else an\nobject with a ``.fileno()`` method which returns an integer file descriptor. Any\nkind of file descriptor can be passed, though the exact semantics will depend on\nyour kernel. For example, this probably won't do anything useful for on-disk files.\n\nOn Windows systems, ``obj`` must either be an integer ``SOCKET`` handle, or else an\nobject with a ``.fileno()`` method which returns an integer ``SOCKET`` handle. File\ndescriptors aren't supported, and neither are handles that refer to anything besides\na ``SOCKET``.\n\nOn backends where this functionality is not natively provided (asyncio\n``ProactorEventLoop`` on Windows), it is provided using a separate selector thread\nwhich is set to shut down when the interpreter shuts down.\n\n.. warning:: Don't use this on raw sockets that have been wrapped by any higher\n    level constructs like socket streams!\n\n:param obj: an object with a ``.fileno()`` method or an integer handle\n:raises ~anyio.ClosedResourceError: if the object was closed while waiting for the\n    object to become readable\n:raises ~anyio.BusyResourceError: if another task is already waiting for the object\n    to become readable",
          "signature": "(obj: 'FileDescriptorLike') -> 'Awaitable[None]'"
        },
        {
          "name": "wait_socket_readable",
          "doc": ".. deprecated:: 4.7.0\n   Use :func:`wait_readable` instead.\n\nWait until the given socket has data to be read.\n\n.. warning:: Only use this on raw sockets that have not been wrapped by any higher\n    level constructs like socket streams!\n\n:param sock: a socket object\n:raises ~anyio.ClosedResourceError: if the socket was closed while waiting for the\n    socket to become readable\n:raises ~anyio.BusyResourceError: if another task is already waiting for the socket\n    to become readable",
          "signature": "(sock: 'socket.socket') -> 'Awaitable[None]'"
        },
        {
          "name": "wait_socket_writable",
          "doc": ".. deprecated:: 4.7.0\n   Use :func:`wait_writable` instead.\n\nWait until the given socket can be written to.\n\nThis does **NOT** work on Windows when using the asyncio backend with a proactor\nevent loop (default on py3.8+).\n\n.. warning:: Only use this on raw sockets that have not been wrapped by any higher\n    level constructs like socket streams!\n\n:param sock: a socket object\n:raises ~anyio.ClosedResourceError: if the socket was closed while waiting for the\n    socket to become writable\n:raises ~anyio.BusyResourceError: if another task is already waiting for the socket\n    to become writable",
          "signature": "(sock: 'socket.socket') -> 'Awaitable[None]'"
        },
        {
          "name": "wait_writable",
          "doc": "Wait until the given object can be written to.\n\n:param obj: an object with a ``.fileno()`` method or an integer handle\n:raises ~anyio.ClosedResourceError: if the object was closed while waiting for the\n    object to become writable\n:raises ~anyio.BusyResourceError: if another task is already waiting for the object\n    to become writable\n\n.. seealso:: See the documentation of :func:`wait_readable` for the definition of\n   ``obj`` and notes on backend compatibility.\n\n.. warning:: Don't use this on raw sockets that have been wrapped by any higher\n    level constructs like socket streams!",
          "signature": "(obj: 'FileDescriptorLike') -> 'Awaitable[None]'"
        },
        {
          "name": "wrap_file",
          "doc": "Wrap an existing file as an asynchronous file.\n\n:param file: an existing file-like object\n:return: an asynchronous file object",
          "signature": "(file: 'IO[AnyStr]') -> 'AsyncFile[AnyStr]'"
        }
      ],
      "classes": [
        {
          "name": "AsyncContextManagerMixin",
          "doc": "Mixin class providing async context manager functionality via a generator-based\nimplementation.\n\nThis class allows you to implement a context manager via\n:meth:`__asynccontextmanager__`. The mechanics are meant to mirror those of\n:func:`@asynccontextmanager <contextlib.asynccontextmanager>`.\n\n.. note:: Classes using this mix-in are not reentrant as context managers, meaning\n    that once you enter it, you can't re-enter before first exiting it.\n\n.. seealso:: :doc:`contextmanagers`",
          "functions": [
            {
              "name": "__aenter__",
              "doc": null,
              "signature": "(self: '_SupportsAsyncCtxMgr[_T_co, bool | None]') -> '_T_co'"
            },
            {
              "name": "__aexit__",
              "doc": null,
              "signature": "(self: '_SupportsAsyncCtxMgr[object, _ExitT_co]', exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> '_ExitT_co'"
            },
            {
              "name": "__asynccontextmanager__",
              "doc": "Implement your async context manager logic here.\n\nThis method **must** be decorated with\n:func:`@asynccontextmanager <contextlib.asynccontextmanager>`.\n\n.. note:: Remember that the ``yield`` will raise any exception raised in the\n    enclosed context block, so use a ``finally:`` block to clean up resources!\n\n:return: an async context manager object",
              "signature": "(self) -> 'AbstractAsyncContextManager[object, bool | None]'"
            }
          ]
        },
        {
          "name": "AsyncFile",
          "doc": "An asynchronous file object.\n\nThis class wraps a standard file object and provides async friendly versions of the\nfollowing blocking methods (where available on the original file object):\n\n* read\n* read1\n* readline\n* readlines\n* readinto\n* readinto1\n* write\n* writelines\n* truncate\n* seek\n* tell\n* flush\n\nAll other methods are directly passed through.\n\nThis class supports the asynchronous context manager protocol which closes the\nunderlying file at the end of the context block.\n\nThis class also supports asynchronous iteration::\n\n    async with await open_file(...) as f:\n        async for line in f:\n            print(line)",
          "functions": [
            {
              "name": "__aenter__",
              "doc": null,
              "signature": "(self: 'T') -> 'T'"
            },
            {
              "name": "__aexit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'None'"
            },
            {
              "name": "__aiter__",
              "doc": null,
              "signature": "(self) -> 'AsyncIterator[AnyStr]'"
            },
            {
              "name": "__getattr__",
              "doc": null,
              "signature": "(self, name: 'str') -> 'object'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, fp: 'IO[AnyStr]') -> 'None'"
            },
            {
              "name": "aclose",
              "doc": "Close the resource.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "flush",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "read",
              "doc": null,
              "signature": "(self, size: 'int' = -1) -> 'AnyStr'"
            },
            {
              "name": "read1",
              "doc": null,
              "signature": "(self: 'AsyncFile[bytes]', size: 'int' = -1) -> 'bytes'"
            },
            {
              "name": "readinto",
              "doc": null,
              "signature": "(self: 'AsyncFile[bytes]', b: 'WriteableBuffer') -> 'int'"
            },
            {
              "name": "readinto1",
              "doc": null,
              "signature": "(self: 'AsyncFile[bytes]', b: 'WriteableBuffer') -> 'int'"
            },
            {
              "name": "readline",
              "doc": null,
              "signature": "(self) -> 'AnyStr'"
            },
            {
              "name": "readlines",
              "doc": null,
              "signature": "(self) -> 'list[AnyStr]'"
            },
            {
              "name": "seek",
              "doc": null,
              "signature": "(self, offset: 'int', whence: 'int | None' = 0) -> 'int'"
            },
            {
              "name": "tell",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "truncate",
              "doc": null,
              "signature": "(self, size: 'int | None' = None) -> 'int'"
            },
            {
              "name": "write",
              "doc": null,
              "signature": "(self, b: 'ReadableBuffer | str') -> 'int'"
            },
            {
              "name": "writelines",
              "doc": null,
              "signature": "(self, lines: 'Iterable[ReadableBuffer] | Iterable[str]') -> 'None'"
            }
          ]
        },
        {
          "name": "BrokenResourceError",
          "doc": "Raised when trying to use a resource that has been rendered unusable due to external\ncauses (e.g. a send stream whose peer has disconnected).",
          "functions": []
        },
        {
          "name": "BrokenWorkerInterpreter",
          "doc": "Raised by :meth:`~anyio.to_interpreter.run_sync` if an unexpected exception is\nraised in the subinterpreter.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, excinfo: 'Any')"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "BrokenWorkerProcess",
          "doc": "Raised by :meth:`~anyio.to_process.run_sync` if the worker process terminates abruptly or\notherwise misbehaves.",
          "functions": []
        },
        {
          "name": "BusyResourceError",
          "doc": "Raised when two tasks are trying to read from or write to the same resource\nconcurrently.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, action: 'str')"
            }
          ]
        },
        {
          "name": "CancelScope",
          "doc": "Wraps a unit of work that can be made separately cancellable.\n\n:param deadline: The time (clock value) when this scope is cancelled automatically\n:param shield: ``True`` to shield the cancel scope from external cancellation",
          "functions": [
            {
              "name": "__enter__",
              "doc": null,
              "signature": "(self) -> 'CancelScope'"
            },
            {
              "name": "__exit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'bool'"
            },
            {
              "name": "__new__",
              "doc": "Create and return a new object.  See help(type) for accurate signature.",
              "signature": "(cls, *, deadline: 'float' = inf, shield: 'bool' = False) -> 'CancelScope'"
            },
            {
              "name": "cancel",
              "doc": "Cancel this scope immediately.",
              "signature": "(self) -> 'None'"
            }
          ]
        },
        {
          "name": "CapacityLimiter",
          "doc": null,
          "functions": [
            {
              "name": "__aenter__",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "__aexit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'None'"
            },
            {
              "name": "__new__",
              "doc": "Create and return a new object.  See help(type) for accurate signature.",
              "signature": "(cls, total_tokens: 'float') -> 'CapacityLimiter'"
            },
            {
              "name": "acquire",
              "doc": "Acquire a token for the current task, waiting if necessary for one to become\navailable.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "acquire_nowait",
              "doc": "Acquire a token for the current task without waiting for one to become\navailable.\n\n:raises ~anyio.WouldBlock: if there are no tokens available for borrowing",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "acquire_on_behalf_of",
              "doc": "Acquire a token, waiting if necessary for one to become available.\n\n:param borrower: the entity borrowing a token",
              "signature": "(self, borrower: 'object') -> 'None'"
            },
            {
              "name": "acquire_on_behalf_of_nowait",
              "doc": "Acquire a token without waiting for one to become available.\n\n:param borrower: the entity borrowing a token\n:raises ~anyio.WouldBlock: if there are no tokens available for borrowing",
              "signature": "(self, borrower: 'object') -> 'None'"
            },
            {
              "name": "release",
              "doc": "Release the token held by the current task.\n\n:raises RuntimeError: if the current task has not borrowed a token from this\n    limiter.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "release_on_behalf_of",
              "doc": "Release the token held by the given borrower.\n\n:raises RuntimeError: if the borrower has not borrowed a token from this\n    limiter.",
              "signature": "(self, borrower: 'object') -> 'None'"
            },
            {
              "name": "statistics",
              "doc": "Return statistics about the current state of this limiter.\n\n.. versionadded:: 3.0",
              "signature": "(self) -> 'CapacityLimiterStatistics'"
            }
          ]
        },
        {
          "name": "CapacityLimiterStatistics",
          "doc": ":ivar int borrowed_tokens: number of tokens currently borrowed by tasks\n:ivar float total_tokens: total number of available tokens\n:ivar tuple borrowers: tasks or other objects currently holding tokens borrowed from\n    this limiter\n:ivar int tasks_waiting: number of tasks waiting on\n    :meth:`~.CapacityLimiter.acquire` or\n    :meth:`~.CapacityLimiter.acquire_on_behalf_of`",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, borrowed_tokens: 'int', total_tokens: 'float', borrowers: 'tuple[object, ...]', tasks_waiting: 'int') -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "ClosedResourceError",
          "doc": "Raised when trying to use a resource that has been closed.",
          "functions": []
        },
        {
          "name": "Condition",
          "doc": null,
          "functions": [
            {
              "name": "__aenter__",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "__aexit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'None'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, lock: 'Lock | None' = None)"
            },
            {
              "name": "_check_acquired",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "acquire",
              "doc": "Acquire the underlying lock.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "acquire_nowait",
              "doc": "Acquire the underlying lock, without blocking.\n\n:raises ~anyio.WouldBlock: if the operation would block",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "locked",
              "doc": "Return True if the lock is set.",
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "notify",
              "doc": "Notify exactly n listeners.",
              "signature": "(self, n: 'int' = 1) -> 'None'"
            },
            {
              "name": "notify_all",
              "doc": "Notify all the listeners.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "release",
              "doc": "Release the underlying lock.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "statistics",
              "doc": "Return statistics about the current state of this condition.\n\n.. versionadded:: 3.0",
              "signature": "(self) -> 'ConditionStatistics'"
            },
            {
              "name": "wait",
              "doc": "Wait for a notification.",
              "signature": "(self) -> 'None'"
            }
          ]
        },
        {
          "name": "ConditionStatistics",
          "doc": ":ivar int tasks_waiting: number of tasks blocked on :meth:`~.Condition.wait`\n:ivar ~anyio.LockStatistics lock_statistics: statistics of the underlying\n    :class:`~.Lock`",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, tasks_waiting: 'int', lock_statistics: 'LockStatistics') -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "ConnectionFailed",
          "doc": "Raised when a connection attempt fails.\n\n.. note:: This class inherits from :exc:`OSError` for backwards compatibility.",
          "functions": []
        },
        {
          "name": "ContextManagerMixin",
          "doc": "Mixin class providing context manager functionality via a generator-based\nimplementation.\n\nThis class allows you to implement a context manager via :meth:`__contextmanager__`\nwhich should return a generator. The mechanics are meant to mirror those of\n:func:`@contextmanager <contextlib.contextmanager>`.\n\n.. note:: Classes using this mix-in are not reentrant as context managers, meaning\n    that once you enter it, you can't re-enter before first exiting it.\n\n.. seealso:: :doc:`contextmanagers`",
          "functions": [
            {
              "name": "__contextmanager__",
              "doc": "Implement your context manager logic here.\n\nThis method **must** be decorated with\n:func:`@contextmanager <contextlib.contextmanager>`.\n\n.. note:: Remember that the ``yield`` will raise any exception raised in the\n    enclosed context block, so use a ``finally:`` block to clean up resources!\n\n:return: a context manager object",
              "signature": "(self) -> 'AbstractContextManager[object, bool | None]'"
            },
            {
              "name": "__enter__",
              "doc": null,
              "signature": "(self: '_SupportsCtxMgr[_T_co, bool | None]') -> '_T_co'"
            },
            {
              "name": "__exit__",
              "doc": null,
              "signature": "(self: '_SupportsCtxMgr[object, _ExitT_co]', exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> '_ExitT_co'"
            }
          ]
        },
        {
          "name": "DelimiterNotFound",
          "doc": "Raised during\n:meth:`~anyio.streams.buffered.BufferedByteReceiveStream.receive_until` if the\nmaximum number of bytes has been read without the delimiter being found.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, max_bytes: 'int') -> 'None'"
            }
          ]
        },
        {
          "name": "EndOfStream",
          "doc": "Raised when trying to read from a stream that has been closed from the other end.",
          "functions": []
        },
        {
          "name": "Event",
          "doc": null,
          "functions": [
            {
              "name": "__new__",
              "doc": "Create and return a new object.  See help(type) for accurate signature.",
              "signature": "(cls) -> 'Event'"
            },
            {
              "name": "is_set",
              "doc": "Return ``True`` if the flag is set, ``False`` if not.",
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "set",
              "doc": "Set the flag, notifying all listeners.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "statistics",
              "doc": "Return statistics about the current state of this event.",
              "signature": "(self) -> 'EventStatistics'"
            },
            {
              "name": "wait",
              "doc": "Wait until the flag has been set.\n\nIf the flag has already been set when this method is called, it returns\nimmediately.",
              "signature": "(self) -> 'None'"
            }
          ]
        },
        {
          "name": "EventStatistics",
          "doc": ":ivar int tasks_waiting: number of tasks waiting on :meth:`~.Event.wait`",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, tasks_waiting: 'int') -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "IncompleteRead",
          "doc": "Raised during\n:meth:`~anyio.streams.buffered.BufferedByteReceiveStream.receive_exactly` or\n:meth:`~anyio.streams.buffered.BufferedByteReceiveStream.receive_until` if the\nconnection is closed before the requested amount of bytes has been read.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self) -> 'None'"
            }
          ]
        },
        {
          "name": "Lock",
          "doc": null,
          "functions": [
            {
              "name": "__aenter__",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "__aexit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'None'"
            },
            {
              "name": "__new__",
              "doc": "Create and return a new object.  See help(type) for accurate signature.",
              "signature": "(cls, *, fast_acquire: 'bool' = False) -> 'Lock'"
            },
            {
              "name": "acquire",
              "doc": "Acquire the lock.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "acquire_nowait",
              "doc": "Acquire the lock, without blocking.\n\n:raises ~anyio.WouldBlock: if the operation would block",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "locked",
              "doc": "Return True if the lock is currently held.",
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "release",
              "doc": "Release the lock.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "statistics",
              "doc": "Return statistics about the current state of this lock.\n\n.. versionadded:: 3.0",
              "signature": "(self) -> 'LockStatistics'"
            }
          ]
        },
        {
          "name": "LockStatistics",
          "doc": ":ivar bool locked: flag indicating if this lock is locked or not\n:ivar ~anyio.TaskInfo owner: task currently holding the lock (or ``None`` if the\n    lock is not held by any task)\n:ivar int tasks_waiting: number of tasks waiting on :meth:`~.Lock.acquire`",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, locked: 'bool', owner: 'TaskInfo | None', tasks_waiting: 'int') -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "NamedTemporaryFile",
          "doc": "An asynchronous named temporary file that is automatically created and cleaned up.\n\nThis class provides an asynchronous context manager for a temporary file with a\nvisible name in the file system. It uses Python's standard\n:func:`~tempfile.NamedTemporaryFile` function and wraps the file object with\n:class:`AsyncFile` for asynchronous operations.\n\n:param mode: The mode in which the file is opened. Defaults to \"w+b\".\n:param buffering: The buffering policy (-1 means the default buffering).\n:param encoding: The encoding used to decode or encode the file. Only applicable in\n    text mode.\n:param newline: Controls how universal newlines mode works (only applicable in text\n    mode).\n:param suffix: The suffix for the temporary file name.\n:param prefix: The prefix for the temporary file name.\n:param dir: The directory in which the temporary file is created.\n:param delete: Whether to delete the file when it is closed.\n:param errors: The error handling scheme used for encoding/decoding errors.\n:param delete_on_close: (Python 3.12+) Whether to delete the file on close.",
          "functions": [
            {
              "name": "__aenter__",
              "doc": null,
              "signature": "(self) -> 'AsyncFile[AnyStr]'"
            },
            {
              "name": "__aexit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_value: 'BaseException | None', traceback: 'TracebackType | None') -> 'None'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, mode: 'OpenBinaryMode | OpenTextMode' = 'w+b', buffering: 'int' = -1, encoding: 'str | None' = None, newline: 'str | None' = None, suffix: 'str | None' = None, prefix: 'str | None' = None, dir: 'str | None' = None, delete: 'bool' = True, *, errors: 'str | None' = None, delete_on_close: 'bool' = True) -> 'None'"
            }
          ]
        },
        {
          "name": "Path",
          "doc": "An asynchronous version of :class:`pathlib.Path`.\n\nThis class cannot be substituted for :class:`pathlib.Path` or\n:class:`pathlib.PurePath`, but it is compatible with the :class:`os.PathLike`\ninterface.\n\nIt implements the Python 3.10 version of :class:`pathlib.Path` interface, except for\nthe deprecated :meth:`~pathlib.Path.link_to` method.\n\nSome methods may be unavailable or have limited functionality, based on the Python\nversion:\n\n* :meth:`~pathlib.Path.copy` (available on Python 3.14 or later)\n* :meth:`~pathlib.Path.copy_into` (available on Python 3.14 or later)\n* :meth:`~pathlib.Path.from_uri` (available on Python 3.13 or later)\n* :meth:`~pathlib.PurePath.full_match` (available on Python 3.13 or later)\n* :attr:`~pathlib.Path.info` (available on Python 3.14 or later)\n* :meth:`~pathlib.Path.is_junction` (available on Python 3.12 or later)\n* :meth:`~pathlib.PurePath.match` (the ``case_sensitive`` parameter is only\n  available on Python 3.13 or later)\n* :meth:`~pathlib.Path.move` (available on Python 3.14 or later)\n* :meth:`~pathlib.Path.move_into` (available on Python 3.14 or later)\n* :meth:`~pathlib.PurePath.relative_to` (the ``walk_up`` parameter is only available\n  on Python 3.12 or later)\n* :meth:`~pathlib.Path.walk` (available on Python 3.12 or later)\n\nAny methods that do disk I/O need to be awaited on. These methods are:\n\n* :meth:`~pathlib.Path.absolute`\n* :meth:`~pathlib.Path.chmod`\n* :meth:`~pathlib.Path.cwd`\n* :meth:`~pathlib.Path.exists`\n* :meth:`~pathlib.Path.expanduser`\n* :meth:`~pathlib.Path.group`\n* :meth:`~pathlib.Path.hardlink_to`\n* :meth:`~pathlib.Path.home`\n* :meth:`~pathlib.Path.is_block_device`\n* :meth:`~pathlib.Path.is_char_device`\n* :meth:`~pathlib.Path.is_dir`\n* :meth:`~pathlib.Path.is_fifo`\n* :meth:`~pathlib.Path.is_file`\n* :meth:`~pathlib.Path.is_junction`\n* :meth:`~pathlib.Path.is_mount`\n* :meth:`~pathlib.Path.is_socket`\n* :meth:`~pathlib.Path.is_symlink`\n* :meth:`~pathlib.Path.lchmod`\n* :meth:`~pathlib.Path.lstat`\n* :meth:`~pathlib.Path.mkdir`\n* :meth:`~pathlib.Path.open`\n* :meth:`~pathlib.Path.owner`\n* :meth:`~pathlib.Path.read_bytes`\n* :meth:`~pathlib.Path.read_text`\n* :meth:`~pathlib.Path.readlink`\n* :meth:`~pathlib.Path.rename`\n* :meth:`~pathlib.Path.replace`\n* :meth:`~pathlib.Path.resolve`\n* :meth:`~pathlib.Path.rmdir`\n* :meth:`~pathlib.Path.samefile`\n* :meth:`~pathlib.Path.stat`\n* :meth:`~pathlib.Path.symlink_to`\n* :meth:`~pathlib.Path.touch`\n* :meth:`~pathlib.Path.unlink`\n* :meth:`~pathlib.Path.walk`\n* :meth:`~pathlib.Path.write_bytes`\n* :meth:`~pathlib.Path.write_text`\n\nAdditionally, the following methods return an async iterator yielding\n:class:`~.Path` objects:\n\n* :meth:`~pathlib.Path.glob`\n* :meth:`~pathlib.Path.iterdir`\n* :meth:`~pathlib.Path.rglob`",
          "functions": [
            {
              "name": "__bytes__",
              "doc": null,
              "signature": "(self) -> 'bytes'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'object') -> 'bool'"
            },
            {
              "name": "__fspath__",
              "doc": null,
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'pathlib.PurePath | Path') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'pathlib.PurePath | Path') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, *args: 'str | PathLike[str]') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'pathlib.PurePath | Path') -> 'bool'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'pathlib.PurePath | Path') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__rtruediv__",
              "doc": null,
              "signature": "(self, other: 'str | PathLike[str]') -> 'Path'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__truediv__",
              "doc": null,
              "signature": "(self, other: 'str | PathLike[str]') -> 'Path'"
            },
            {
              "name": "absolute",
              "doc": null,
              "signature": "(self) -> 'Path'"
            },
            {
              "name": "as_posix",
              "doc": null,
              "signature": "(self) -> 'str'"
            },
            {
              "name": "as_uri",
              "doc": null,
              "signature": "(self) -> 'str'"
            },
            {
              "name": "chmod",
              "doc": null,
              "signature": "(self, mode: 'int', *, follow_symlinks: 'bool' = True) -> 'None'"
            },
            {
              "name": "exists",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "expanduser",
              "doc": null,
              "signature": "(self) -> 'Path'"
            },
            {
              "name": "glob",
              "doc": null,
              "signature": "(self, pattern: 'str') -> 'AsyncIterator[Path]'"
            },
            {
              "name": "group",
              "doc": null,
              "signature": "(self) -> 'str'"
            },
            {
              "name": "hardlink_to",
              "doc": null,
              "signature": "(self, target: 'str | bytes | PathLike[str] | PathLike[bytes]') -> 'None'"
            },
            {
              "name": "is_absolute",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "is_block_device",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "is_char_device",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "is_dir",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "is_fifo",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "is_file",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "is_mount",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "is_relative_to",
              "doc": null,
              "signature": "(self, other: 'str | PathLike[str]') -> 'bool'"
            },
            {
              "name": "is_reserved",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "is_socket",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "is_symlink",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "iterdir",
              "doc": null,
              "signature": "(self) -> 'AsyncIterator[Path]'"
            },
            {
              "name": "joinpath",
              "doc": null,
              "signature": "(self, *args: 'str | PathLike[str]') -> 'Path'"
            },
            {
              "name": "lchmod",
              "doc": null,
              "signature": "(self, mode: 'int') -> 'None'"
            },
            {
              "name": "lstat",
              "doc": null,
              "signature": "(self) -> 'os.stat_result'"
            },
            {
              "name": "match",
              "doc": null,
              "signature": "(self, path_pattern: 'str') -> 'bool'"
            },
            {
              "name": "mkdir",
              "doc": null,
              "signature": "(self, mode: 'int' = 511, parents: 'bool' = False, exist_ok: 'bool' = False) -> 'None'"
            },
            {
              "name": "open",
              "doc": null,
              "signature": "(self, mode: 'str' = 'r', buffering: 'int' = -1, encoding: 'str | None' = None, errors: 'str | None' = None, newline: 'str | None' = None) -> 'AsyncFile[Any]'"
            },
            {
              "name": "owner",
              "doc": null,
              "signature": "(self) -> 'str'"
            },
            {
              "name": "read_bytes",
              "doc": null,
              "signature": "(self) -> 'bytes'"
            },
            {
              "name": "read_text",
              "doc": null,
              "signature": "(self, encoding: 'str | None' = None, errors: 'str | None' = None) -> 'str'"
            },
            {
              "name": "readlink",
              "doc": null,
              "signature": "(self) -> 'Path'"
            },
            {
              "name": "relative_to",
              "doc": null,
              "signature": "(self, *other: 'str | PathLike[str]') -> 'Path'"
            },
            {
              "name": "rename",
              "doc": null,
              "signature": "(self, target: 'str | pathlib.PurePath | Path') -> 'Path'"
            },
            {
              "name": "replace",
              "doc": null,
              "signature": "(self, target: 'str | pathlib.PurePath | Path') -> 'Path'"
            },
            {
              "name": "resolve",
              "doc": null,
              "signature": "(self, strict: 'bool' = False) -> 'Path'"
            },
            {
              "name": "rglob",
              "doc": null,
              "signature": "(self, pattern: 'str') -> 'AsyncIterator[Path]'"
            },
            {
              "name": "rmdir",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "samefile",
              "doc": null,
              "signature": "(self, other_path: 'str | PathLike[str]') -> 'bool'"
            },
            {
              "name": "stat",
              "doc": null,
              "signature": "(self, *, follow_symlinks: 'bool' = True) -> 'os.stat_result'"
            },
            {
              "name": "symlink_to",
              "doc": null,
              "signature": "(self, target: 'str | bytes | PathLike[str] | PathLike[bytes]', target_is_directory: 'bool' = False) -> 'None'"
            },
            {
              "name": "touch",
              "doc": null,
              "signature": "(self, mode: 'int' = 438, exist_ok: 'bool' = True) -> 'None'"
            },
            {
              "name": "unlink",
              "doc": null,
              "signature": "(self, missing_ok: 'bool' = False) -> 'None'"
            },
            {
              "name": "with_name",
              "doc": null,
              "signature": "(self, name: 'str') -> 'Path'"
            },
            {
              "name": "with_segments",
              "doc": null,
              "signature": "(self, *pathsegments: 'str | PathLike[str]') -> 'Path'"
            },
            {
              "name": "with_stem",
              "doc": null,
              "signature": "(self, stem: 'str') -> 'Path'"
            },
            {
              "name": "with_suffix",
              "doc": null,
              "signature": "(self, suffix: 'str') -> 'Path'"
            },
            {
              "name": "write_bytes",
              "doc": null,
              "signature": "(self, data: 'bytes') -> 'int'"
            },
            {
              "name": "write_text",
              "doc": null,
              "signature": "(self, data: 'str', encoding: 'str | None' = None, errors: 'str | None' = None, newline: 'str | None' = None) -> 'int'"
            }
          ]
        },
        {
          "name": "ResourceGuard",
          "doc": "A context manager for ensuring that a resource is only used by a single task at a\ntime.\n\nEntering this context manager while the previous has not exited it yet will trigger\n:exc:`BusyResourceError`.\n\n:param action: the action to guard against (visible in the :exc:`BusyResourceError`\n    when triggered, e.g. \"Another task is already {action} this resource\")\n\n.. versionadded:: 4.1",
          "functions": [
            {
              "name": "__enter__",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "__exit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'None'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, action: 'str' = 'using')"
            }
          ]
        },
        {
          "name": "Semaphore",
          "doc": null,
          "functions": [
            {
              "name": "__aenter__",
              "doc": null,
              "signature": "(self) -> 'Semaphore'"
            },
            {
              "name": "__aexit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'None'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, initial_value: 'int', *, max_value: 'int | None' = None, fast_acquire: 'bool' = False)"
            },
            {
              "name": "__new__",
              "doc": "Create and return a new object.  See help(type) for accurate signature.",
              "signature": "(cls, initial_value: 'int', *, max_value: 'int | None' = None, fast_acquire: 'bool' = False) -> 'Semaphore'"
            },
            {
              "name": "acquire",
              "doc": "Decrement the semaphore value, blocking if necessary.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "acquire_nowait",
              "doc": "Acquire the underlying lock, without blocking.\n\n:raises ~anyio.WouldBlock: if the operation would block",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "release",
              "doc": "Increment the semaphore value.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "statistics",
              "doc": "Return statistics about the current state of this semaphore.\n\n.. versionadded:: 3.0",
              "signature": "(self) -> 'SemaphoreStatistics'"
            }
          ]
        },
        {
          "name": "SemaphoreStatistics",
          "doc": ":ivar int tasks_waiting: number of tasks waiting on :meth:`~.Semaphore.acquire`",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, tasks_waiting: 'int') -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "SpooledTemporaryFile",
          "doc": "An asynchronous spooled temporary file that starts in memory and is spooled to disk.\n\nThis class provides an asynchronous interface to a spooled temporary file, much like\nPython's standard :class:`~tempfile.SpooledTemporaryFile`. It supports asynchronous\nwrite operations and provides a method to force a rollover to disk.\n\n:param max_size: Maximum size in bytes before the file is rolled over to disk.\n:param mode: The mode in which the file is opened. Defaults to \"w+b\".\n:param buffering: The buffering policy (-1 means the default buffering).\n:param encoding: The encoding used to decode or encode the file (text mode only).\n:param newline: Controls how universal newlines mode works (text mode only).\n:param suffix: The suffix for the temporary file name.\n:param prefix: The prefix for the temporary file name.\n:param dir: The directory in which the temporary file is created.\n:param errors: The error handling scheme used for encoding/decoding errors.",
          "functions": [
            {
              "name": "__aenter__",
              "doc": null,
              "signature": "(self: 'T') -> 'T'"
            },
            {
              "name": "__aexit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'None'"
            },
            {
              "name": "__aiter__",
              "doc": null,
              "signature": "(self) -> 'AsyncIterator[AnyStr]'"
            },
            {
              "name": "__getattr__",
              "doc": null,
              "signature": "(self, name: 'str') -> 'object'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, max_size: 'int' = 0, mode: 'OpenBinaryMode | OpenTextMode' = 'w+b', buffering: 'int' = -1, encoding: 'str | None' = None, newline: 'str | None' = None, suffix: 'str | None' = None, prefix: 'str | None' = None, dir: 'str | None' = None, *, errors: 'str | None' = None) -> 'None'"
            },
            {
              "name": "_check",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "aclose",
              "doc": "Close the resource.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "flush",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "read",
              "doc": null,
              "signature": "(self, size: 'int' = -1) -> 'AnyStr'"
            },
            {
              "name": "read1",
              "doc": null,
              "signature": "(self: 'SpooledTemporaryFile[bytes]', size: 'int' = -1) -> 'bytes'"
            },
            {
              "name": "readinto",
              "doc": null,
              "signature": "(self: 'SpooledTemporaryFile[bytes]', b: 'WriteableBuffer') -> 'int'"
            },
            {
              "name": "readinto1",
              "doc": null,
              "signature": "(self: 'SpooledTemporaryFile[bytes]', b: 'WriteableBuffer') -> 'int'"
            },
            {
              "name": "readline",
              "doc": null,
              "signature": "(self) -> 'AnyStr'"
            },
            {
              "name": "readlines",
              "doc": null,
              "signature": "(self) -> 'list[AnyStr]'"
            },
            {
              "name": "rollover",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "seek",
              "doc": null,
              "signature": "(self, offset: 'int', whence: 'int | None' = 0) -> 'int'"
            },
            {
              "name": "tell",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "truncate",
              "doc": null,
              "signature": "(self, size: 'int | None' = None) -> 'int'"
            },
            {
              "name": "write",
              "doc": "Asynchronously write data to the spooled temporary file.\n\nIf the file has not yet been rolled over, the data is written synchronously,\nand a rollover is triggered if the size exceeds the maximum size.\n\n:param s: The data to write.\n:return: The number of bytes written.\n:raises RuntimeError: If the underlying file is not initialized.",
              "signature": "(self, b: 'ReadableBuffer | str') -> 'int'"
            },
            {
              "name": "writelines",
              "doc": "Asynchronously write a list of lines to the spooled temporary file.\n\nIf the file has not yet been rolled over, the lines are written synchronously,\nand a rollover is triggered if the size exceeds the maximum size.\n\n:param lines: An iterable of lines to write.\n:raises RuntimeError: If the underlying file is not initialized.",
              "signature": "(self, lines: 'Iterable[str] | Iterable[ReadableBuffer]') -> 'None'"
            }
          ]
        },
        {
          "name": "TCPConnectable",
          "doc": "Connects to a TCP server at the given host and port.\n\n:param host: host name or IP address of the server\n:param port: TCP port number of the server",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, host: 'str | IPv4Address | IPv6Address', port: 'int') -> None"
            },
            {
              "name": "__post_init__",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "connect",
              "doc": "Connect to the remote endpoint.\n\n:return: a bytestream connected to the remote end\n:raises ConnectionFailed: if the connection fails",
              "signature": "(self) -> 'SocketStream'"
            }
          ]
        },
        {
          "name": "TaskInfo",
          "doc": "Represents an asynchronous task.\n\n:ivar int id: the unique identifier of the task\n:ivar parent_id: the identifier of the parent task, if any\n:vartype parent_id: Optional[int]\n:ivar str name: the description of the task (if any)\n:ivar ~collections.abc.Coroutine coro: the coroutine object of the task",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'object') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, id: 'int', parent_id: 'int | None', name: 'str | None', coro: 'Generator[Any, Any, Any] | Awaitable[Any]')"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "has_pending_cancellation",
              "doc": "Return ``True`` if the task has a cancellation pending, ``False`` otherwise.",
              "signature": "(self) -> 'bool'"
            }
          ]
        },
        {
          "name": "TemporaryDirectory",
          "doc": "An asynchronous temporary directory that is created and cleaned up automatically.\n\nThis class provides an asynchronous context manager for creating a temporary\ndirectory. It wraps Python's standard :class:`~tempfile.TemporaryDirectory` to\nperform directory creation and cleanup operations in a background thread.\n\n:param suffix: Suffix to be added to the temporary directory name.\n:param prefix: Prefix to be added to the temporary directory name.\n:param dir: The parent directory where the temporary directory is created.\n:param ignore_cleanup_errors: Whether to ignore errors during cleanup\n    (Python 3.10+).\n:param delete: Whether to delete the directory upon closing (Python 3.12+).",
          "functions": [
            {
              "name": "__aenter__",
              "doc": null,
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__aexit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_value: 'BaseException | None', traceback: 'TracebackType | None') -> 'None'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, suffix: 'AnyStr | None' = None, prefix: 'AnyStr | None' = None, dir: 'AnyStr | None' = None, *, ignore_cleanup_errors: 'bool' = False, delete: 'bool' = True) -> 'None'"
            },
            {
              "name": "cleanup",
              "doc": null,
              "signature": "(self) -> 'None'"
            }
          ]
        },
        {
          "name": "TemporaryFile",
          "doc": "An asynchronous temporary file that is automatically created and cleaned up.\n\nThis class provides an asynchronous context manager interface to a temporary file.\nThe file is created using Python's standard `tempfile.TemporaryFile` function in a\nbackground thread, and is wrapped as an asynchronous file using `AsyncFile`.\n\n:param mode: The mode in which the file is opened. Defaults to \"w+b\".\n:param buffering: The buffering policy (-1 means the default buffering).\n:param encoding: The encoding used to decode or encode the file. Only applicable in\n    text mode.\n:param newline: Controls how universal newlines mode works (only applicable in text\n    mode).\n:param suffix: The suffix for the temporary file name.\n:param prefix: The prefix for the temporary file name.\n:param dir: The directory in which the temporary file is created.\n:param errors: The error handling scheme used for encoding/decoding errors.",
          "functions": [
            {
              "name": "__aenter__",
              "doc": null,
              "signature": "(self) -> 'AsyncFile[AnyStr]'"
            },
            {
              "name": "__aexit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_value: 'BaseException | None', traceback: 'TracebackType | None') -> 'None'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, mode: 'OpenTextMode | OpenBinaryMode' = 'w+b', buffering: 'int' = -1, encoding: 'str | None' = None, newline: 'str | None' = None, suffix: 'str | None' = None, prefix: 'str | None' = None, dir: 'str | None' = None, *, errors: 'str | None' = None) -> 'None'"
            }
          ]
        },
        {
          "name": "TypedAttributeLookupError",
          "doc": "Raised by :meth:`~anyio.TypedAttributeProvider.extra` when the given typed attribute\nis not found and no default value has been given.",
          "functions": []
        },
        {
          "name": "TypedAttributeProvider",
          "doc": "Base class for classes that wish to provide typed extra attributes.",
          "functions": [
            {
              "name": "extra",
              "doc": "extra(attribute, default=undefined)\n\nReturn the value of the given typed extra attribute.\n\n:param attribute: the attribute (member of a :class:`~TypedAttributeSet`) to\n    look for\n:param default: the value that should be returned if no value is found for the\n    attribute\n:raises ~anyio.TypedAttributeLookupError: if the search failed and no default\n    value was given",
              "signature": "(self, attribute: 'Any', default: 'object' = <object object at 0x0000023EF5D158F0>) -> 'object'"
            }
          ]
        },
        {
          "name": "TypedAttributeSet",
          "doc": "Superclass for typed attribute collections.\n\nChecks that every public attribute of every subclass has a type annotation.",
          "functions": []
        },
        {
          "name": "UNIXConnectable",
          "doc": "Connects to a UNIX domain socket at the given path.\n\n:param path: the file system path of the socket",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, path: 'str | bytes | PathLike[str] | PathLike[bytes]') -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "connect",
              "doc": "Connect to the remote endpoint.\n\n:return: a bytestream connected to the remote end\n:raises ConnectionFailed: if the connection fails",
              "signature": "(self) -> 'UNIXSocketStream'"
            }
          ]
        },
        {
          "name": "WouldBlock",
          "doc": "Raised by ``X_nowait`` functions if ``X()`` would block.",
          "functions": []
        },
        {
          "name": "create_memory_object_stream",
          "doc": "Create a memory object stream.\n\nThe stream's item type can be annotated like\n:func:`create_memory_object_stream[T_Item]`.\n\n:param max_buffer_size: number of items held in the buffer until ``send()`` starts\n    blocking\n:param item_type: old way of marking the streams with the right generic type for\n    static typing (does nothing on AnyIO 4)\n\n    .. deprecated:: 4.0\n      Use ``create_memory_object_stream[YourItemType](...)`` instead.\n:return: a tuple of (send stream, receive stream)",
          "functions": [
            {
              "name": "__new__",
              "doc": "Create and return a new object.  See help(type) for accurate signature.",
              "signature": "(cls, max_buffer_size: 'float' = 0, item_type: 'object' = None) -> 'tuple[MemoryObjectSendStream[T_Item], MemoryObjectReceiveStream[T_Item]]'"
            }
          ]
        }
      ]
    }
  },
  {
    "package": "charset_normalizer",
    "base": {
      "functions": [
        {
          "name": "detect",
          "doc": "chardet legacy method\nDetect the encoding of the given byte string. It should be mostly backward-compatible.\nEncoding name will match Chardet own writing whenever possible. (Not on encoding name unsupported by it)\nThis function is deprecated and should be used to migrate your project easily, consult the documentation for\nfurther information. Not planned for removal.\n\n:param byte_str:     The byte sequence to examine.\n:param should_rename_legacy:  Should we rename legacy encodings\n                              to their more modern equivalents?",
          "signature": "(byte_str: 'bytes', should_rename_legacy: 'bool' = False, **kwargs: 'Any') -> 'ResultDict'"
        },
        {
          "name": "from_bytes",
          "doc": "Given a raw bytes sequence, return the best possibles charset usable to render str objects.\nIf there is no results, it is a strong indicator that the source is binary/not text.\nBy default, the process will extract 5 blocks of 512o each to assess the mess and coherence of a given sequence.\nAnd will give up a particular code page after 20% of measured mess. Those criteria are customizable at will.\n\nThe preemptive behavior DOES NOT replace the traditional detection workflow, it prioritize a particular code page\nbut never take it for granted. Can improve the performance.\n\nYou may want to focus your attention to some code page or/and not others, use cp_isolation and cp_exclusion for that\npurpose.\n\nThis function will strip the SIG in the payload/sequence every time except on UTF-16, UTF-32.\nBy default the library does not setup any handler other than the NullHandler, if you choose to set the 'explain'\ntoggle to True it will alter the logger configuration to add a StreamHandler that is suitable for debugging.\nCustom logging format and handler can be set manually.",
          "signature": "(sequences: 'bytes | bytearray', steps: 'int' = 5, chunk_size: 'int' = 512, threshold: 'float' = 0.2, cp_isolation: 'list[str] | None' = None, cp_exclusion: 'list[str] | None' = None, preemptive_behaviour: 'bool' = True, explain: 'bool' = False, language_threshold: 'float' = 0.1, enable_fallback: 'bool' = True) -> 'CharsetMatches'"
        },
        {
          "name": "from_fp",
          "doc": "Same thing than the function from_bytes but using a file pointer that is already ready.\nWill not close the file pointer.",
          "signature": "(fp: 'BinaryIO', steps: 'int' = 5, chunk_size: 'int' = 512, threshold: 'float' = 0.2, cp_isolation: 'list[str] | None' = None, cp_exclusion: 'list[str] | None' = None, preemptive_behaviour: 'bool' = True, explain: 'bool' = False, language_threshold: 'float' = 0.1, enable_fallback: 'bool' = True) -> 'CharsetMatches'"
        },
        {
          "name": "from_path",
          "doc": "Same thing than the function from_bytes but with one extra step. Opening and reading given file path in binary mode.\nCan raise IOError.",
          "signature": "(path: 'str | bytes | PathLike', steps: 'int' = 5, chunk_size: 'int' = 512, threshold: 'float' = 0.2, cp_isolation: 'list[str] | None' = None, cp_exclusion: 'list[str] | None' = None, preemptive_behaviour: 'bool' = True, explain: 'bool' = False, language_threshold: 'float' = 0.1, enable_fallback: 'bool' = True) -> 'CharsetMatches'"
        },
        {
          "name": "is_binary",
          "doc": "Detect if the given input (file, bytes, or path) points to a binary file. aka. not a string.\nBased on the same main heuristic algorithms and default kwargs at the sole exception that fallbacks match\nare disabled to be stricter around ASCII-compatible but unlikely to be a string.",
          "signature": "(fp_or_path_or_payload: 'PathLike | str | BinaryIO | bytes', steps: 'int' = 5, chunk_size: 'int' = 512, threshold: 'float' = 0.2, cp_isolation: 'list[str] | None' = None, cp_exclusion: 'list[str] | None' = None, preemptive_behaviour: 'bool' = True, explain: 'bool' = False, language_threshold: 'float' = 0.1, enable_fallback: 'bool' = False) -> 'bool'"
        },
        {
          "name": "set_logging_handler",
          "doc": null,
          "signature": "(name: 'str' = 'charset_normalizer', level: 'int' = 20, format_string: 'str' = '%(asctime)s | %(levelname)s | %(message)s') -> 'None'"
        }
      ],
      "classes": [
        {
          "name": "CharsetMatch",
          "doc": null,
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'object') -> 'bool'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, payload: 'bytes', guessed_encoding: 'str', mean_mess_ratio: 'float', has_sig_or_bom: 'bool', languages: 'CoherenceMatches', decoded_payload: 'str | None' = None, preemptive_declaration: 'str | None' = None)"
            },
            {
              "name": "__lt__",
              "doc": "Implemented to make sorted available upon CharsetMatches items.",
              "signature": "(self, other: 'object') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "add_submatch",
              "doc": null,
              "signature": "(self, other: 'CharsetMatch') -> 'None'"
            },
            {
              "name": "output",
              "doc": "Method to get re-encoded bytes payload using given target encoding. Default to UTF-8.\nAny errors will be simply ignored by the encoder NOT replaced.",
              "signature": "(self, encoding: 'str' = 'utf_8') -> 'bytes'"
            }
          ]
        },
        {
          "name": "CharsetMatches",
          "doc": "Container with every CharsetMatch items ordered by default from most probable to the less one.\nAct like a list(iterable) but does not implements all related methods.",
          "functions": [
            {
              "name": "__bool__",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "__getitem__",
              "doc": "Retrieve a single item either by its position or encoding name (alias may be used here).\nRaise KeyError upon invalid index or encoding not present in results.",
              "signature": "(self, item: 'int | str') -> 'CharsetMatch'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, results: 'list[CharsetMatch] | None' = None)"
            },
            {
              "name": "__iter__",
              "doc": null,
              "signature": "(self) -> 'Iterator[CharsetMatch]'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "append",
              "doc": "Insert a single match. Will be inserted accordingly to preserve sort.\nCan be inserted as a submatch.",
              "signature": "(self, item: 'CharsetMatch') -> 'None'"
            },
            {
              "name": "best",
              "doc": "Simply return the first match. Strict equivalent to matches[0].",
              "signature": "(self) -> 'CharsetMatch | None'"
            },
            {
              "name": "first",
              "doc": "Redundant method, call the method best(). Kept for BC reasons.",
              "signature": "(self) -> 'CharsetMatch | None'"
            }
          ]
        }
      ]
    }
  },
  {
    "package": "jinja2",
    "base": {
      "functions": [
        {
          "name": "clear_caches",
          "doc": "Jinja keeps internal caches for environments and lexers.  These are\nused so that Jinja doesn't have to recreate environments and lexers all\nthe time.  Normally you don't have to care about that but if you are\nmeasuring memory consumption you may want to clean the caches.",
          "signature": "() -> None"
        },
        {
          "name": "is_undefined",
          "doc": "Check if the object passed is undefined.  This does nothing more than\nperforming an instance check against :class:`Undefined` but looks nicer.\nThis can be used for custom filters or tests that want to react to\nundefined variables.  For example a custom default filter can look like\nthis::\n\n    def default(var, default=''):\n        if is_undefined(var):\n            return default\n        return var",
          "signature": "(obj: Any) -> bool"
        },
        {
          "name": "make_logging_undefined",
          "doc": "Given a logger object this returns a new undefined class that will\nlog certain failures.  It will log iterations and printing.  If no\nlogger is given a default logger is created.\n\nExample::\n\n    logger = logging.getLogger(__name__)\n    LoggingUndefined = make_logging_undefined(\n        logger=logger,\n        base=Undefined\n    )\n\n.. versionadded:: 2.8\n\n:param logger: the logger to use.  If not provided, a default logger\n               is created.\n:param base: the base class to add logging functionality to.  This\n             defaults to :class:`Undefined`.",
          "signature": "(logger: Optional[ForwardRef('logging.Logger')] = None, base: Type[jinja2.runtime.Undefined] = <class 'jinja2.runtime.Undefined'>) -> Type[jinja2.runtime.Undefined]"
        },
        {
          "name": "pass_context",
          "doc": "Pass the :class:`~jinja2.runtime.Context` as the first argument\nto the decorated function when called while rendering a template.\n\nCan be used on functions, filters, and tests.\n\nIf only ``Context.eval_context`` is needed, use\n:func:`pass_eval_context`. If only ``Context.environment`` is\nneeded, use :func:`pass_environment`.\n\n.. versionadded:: 3.0.0\n    Replaces ``contextfunction`` and ``contextfilter``.",
          "signature": "(f: ~F) -> ~F"
        },
        {
          "name": "pass_environment",
          "doc": "Pass the :class:`~jinja2.Environment` as the first argument to\nthe decorated function when called while rendering a template.\n\nCan be used on functions, filters, and tests.\n\n.. versionadded:: 3.0.0\n    Replaces ``environmentfunction`` and ``environmentfilter``.",
          "signature": "(f: ~F) -> ~F"
        },
        {
          "name": "pass_eval_context",
          "doc": "Pass the :class:`~jinja2.nodes.EvalContext` as the first argument\nto the decorated function when called while rendering a template.\nSee :ref:`eval-context`.\n\nCan be used on functions, filters, and tests.\n\nIf only ``EvalContext.environment`` is needed, use\n:func:`pass_environment`.\n\n.. versionadded:: 3.0.0\n    Replaces ``evalcontextfunction`` and ``evalcontextfilter``.",
          "signature": "(f: ~F) -> ~F"
        },
        {
          "name": "select_autoescape",
          "doc": "Intelligently sets the initial value of autoescaping based on the\nfilename of the template.  This is the recommended way to configure\nautoescaping if you do not want to write a custom function yourself.\n\nIf you want to enable it for all templates created from strings or\nfor all templates with `.html` and `.xml` extensions::\n\n    from jinja2 import Environment, select_autoescape\n    env = Environment(autoescape=select_autoescape(\n        enabled_extensions=('html', 'xml'),\n        default_for_string=True,\n    ))\n\nExample configuration to turn it on at all times except if the template\nends with `.txt`::\n\n    from jinja2 import Environment, select_autoescape\n    env = Environment(autoescape=select_autoescape(\n        disabled_extensions=('txt',),\n        default_for_string=True,\n        default=True,\n    ))\n\nThe `enabled_extensions` is an iterable of all the extensions that\nautoescaping should be enabled for.  Likewise `disabled_extensions` is\na list of all templates it should be disabled for.  If a template is\nloaded from a string then the default from `default_for_string` is used.\nIf nothing matches then the initial value of autoescaping is set to the\nvalue of `default`.\n\nFor security reasons this function operates case insensitive.\n\n.. versionadded:: 2.9",
          "signature": "(enabled_extensions: Collection[str] = ('html', 'htm', 'xml'), disabled_extensions: Collection[str] = (), default_for_string: bool = True, default: bool = False) -> Callable[[Optional[str]], bool]"
        }
      ],
      "classes": [
        {
          "name": "BaseLoader",
          "doc": "Baseclass for all loaders.  Subclass this and override `get_source` to\nimplement a custom loading mechanism.  The environment provides a\n`get_template` method that calls the loader's `load` method to get the\n:class:`Template` object.\n\nA very basic example for a loader that looks up templates on the file\nsystem could look like this::\n\n    from jinja2 import BaseLoader, TemplateNotFound\n    from os.path import join, exists, getmtime\n\n    class MyLoader(BaseLoader):\n\n        def __init__(self, path):\n            self.path = path\n\n        def get_source(self, environment, template):\n            path = join(self.path, template)\n            if not exists(path):\n                raise TemplateNotFound(template)\n            mtime = getmtime(path)\n            with open(path) as f:\n                source = f.read()\n            return source, path, lambda: mtime == getmtime(path)",
          "functions": [
            {
              "name": "get_source",
              "doc": "Get the template source, filename and reload helper for a template.\nIt's passed the environment and template name and has to return a\ntuple in the form ``(source, filename, uptodate)`` or raise a\n`TemplateNotFound` error if it can't locate the template.\n\nThe source part of the returned tuple must be the source of the\ntemplate as a string. The filename should be the name of the\nfile on the filesystem if it was loaded from there, otherwise\n``None``. The filename is used by Python for the tracebacks\nif no loader extension is used.\n\nThe last item in the tuple is the `uptodate` function.  If auto\nreloading is enabled it's always called to check if the template\nchanged.  No arguments are passed so the function must store the\nold state somewhere (for example in a closure).  If it returns `False`\nthe template will be reloaded.",
              "signature": "(self, environment: 'Environment', template: str) -> Tuple[str, Optional[str], Optional[Callable[[], bool]]]"
            },
            {
              "name": "list_templates",
              "doc": "Iterates over all templates.  If the loader does not support that\nit should raise a :exc:`TypeError` which is the default behavior.",
              "signature": "(self) -> List[str]"
            },
            {
              "name": "load",
              "doc": "Loads a template.  This method looks up the template in the cache\nor loads one by calling :meth:`get_source`.  Subclasses should not\noverride this method as loaders working on collections of other\nloaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)\nwill not call this method but `get_source` directly.",
              "signature": "(self, environment: 'Environment', name: str, globals: Optional[MutableMapping[str, Any]] = None) -> 'Template'"
            }
          ]
        },
        {
          "name": "BytecodeCache",
          "doc": "To implement your own bytecode cache you have to subclass this class\nand override :meth:`load_bytecode` and :meth:`dump_bytecode`.  Both of\nthese methods are passed a :class:`~jinja2.bccache.Bucket`.\n\nA very basic bytecode cache that saves the bytecode on the file system::\n\n    from os import path\n\n    class MyCache(BytecodeCache):\n\n        def __init__(self, directory):\n            self.directory = directory\n\n        def load_bytecode(self, bucket):\n            filename = path.join(self.directory, bucket.key)\n            if path.exists(filename):\n                with open(filename, 'rb') as f:\n                    bucket.load_bytecode(f)\n\n        def dump_bytecode(self, bucket):\n            filename = path.join(self.directory, bucket.key)\n            with open(filename, 'wb') as f:\n                bucket.write_bytecode(f)\n\nA more advanced version of a filesystem based bytecode cache is part of\nJinja.",
          "functions": [
            {
              "name": "clear",
              "doc": "Clears the cache.  This method is not used by Jinja but should be\nimplemented to allow applications to clear the bytecode cache used\nby a particular environment.",
              "signature": "(self) -> None"
            },
            {
              "name": "dump_bytecode",
              "doc": "Subclasses have to override this method to write the bytecode\nfrom a bucket back to the cache.  If it unable to do so it must not\nfail silently but raise an exception.",
              "signature": "(self, bucket: jinja2.bccache.Bucket) -> None"
            },
            {
              "name": "get_bucket",
              "doc": "Return a cache bucket for the given template.  All arguments are\nmandatory but filename may be `None`.",
              "signature": "(self, environment: 'Environment', name: str, filename: Optional[str], source: str) -> jinja2.bccache.Bucket"
            },
            {
              "name": "get_cache_key",
              "doc": "Returns the unique hash key for this template name.",
              "signature": "(self, name: str, filename: Optional[str] = None) -> str"
            },
            {
              "name": "get_source_checksum",
              "doc": "Returns a checksum for the source.",
              "signature": "(self, source: str) -> str"
            },
            {
              "name": "load_bytecode",
              "doc": "Subclasses have to override this method to load bytecode into a\nbucket.  If they are not able to find code in the cache for the\nbucket, it must not do anything.",
              "signature": "(self, bucket: jinja2.bccache.Bucket) -> None"
            },
            {
              "name": "set_bucket",
              "doc": "Put the bucket into the cache.",
              "signature": "(self, bucket: jinja2.bccache.Bucket) -> None"
            }
          ]
        },
        {
          "name": "ChainableUndefined",
          "doc": "An undefined that is chainable, where both ``__getattr__`` and\n``__getitem__`` return itself rather than raising an\n:exc:`UndefinedError`.\n\n>>> foo = ChainableUndefined(name='foo')\n>>> str(foo.bar['baz'])\n''\n>>> foo.bar['baz'] + 42\nTraceback (most recent call last):\n  ...\njinja2.exceptions.UndefinedError: 'foo' is undefined\n\n.. versionadded:: 2.11.0",
          "functions": [
            {
              "name": "__add__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__aiter__",
              "doc": null,
              "signature": "(self) -> AsyncIterator[Any]"
            },
            {
              "name": "__bool__",
              "doc": null,
              "signature": "(self) -> bool"
            },
            {
              "name": "__call__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__complex__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__div__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: Any) -> bool"
            },
            {
              "name": "__float__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__floordiv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__ge__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__getattr__",
              "doc": null,
              "signature": "(self, name: str) -> 'ChainableUndefined'"
            },
            {
              "name": "__getitem__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, _name: str) -> 'ChainableUndefined'"
            },
            {
              "name": "__gt__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> int"
            },
            {
              "name": "__html__",
              "doc": null,
              "signature": "(self) -> str"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, hint: Optional[str] = None, obj: Any = missing, name: Optional[str] = None, exc: Type[jinja2.exceptions.TemplateRuntimeError] = <class 'jinja2.exceptions.UndefinedError'>) -> None"
            },
            {
              "name": "__int__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__iter__",
              "doc": null,
              "signature": "(self) -> Iterator[Any]"
            },
            {
              "name": "__le__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> int"
            },
            {
              "name": "__lt__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__mod__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__mul__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__ne__",
              "doc": "Return self!=value.",
              "signature": "(self, other: Any) -> bool"
            },
            {
              "name": "__neg__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__pos__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__pow__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__radd__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rdiv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "__rfloordiv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rmod__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rmul__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rpow__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rsub__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rtruediv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "__sub__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__truediv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "_fail_with_undefined_error",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            }
          ]
        },
        {
          "name": "ChoiceLoader",
          "doc": "This loader works like the `PrefixLoader` just that no prefix is\nspecified.  If a template could not be found by one loader the next one\nis tried.\n\n>>> loader = ChoiceLoader([\n...     FileSystemLoader('/path/to/user/templates'),\n...     FileSystemLoader('/path/to/system/templates')\n... ])\n\nThis is useful if you want to allow users to override builtin templates\nfrom a different location.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, loaders: Sequence[jinja2.loaders.BaseLoader]) -> None"
            },
            {
              "name": "get_source",
              "doc": "Get the template source, filename and reload helper for a template.\nIt's passed the environment and template name and has to return a\ntuple in the form ``(source, filename, uptodate)`` or raise a\n`TemplateNotFound` error if it can't locate the template.\n\nThe source part of the returned tuple must be the source of the\ntemplate as a string. The filename should be the name of the\nfile on the filesystem if it was loaded from there, otherwise\n``None``. The filename is used by Python for the tracebacks\nif no loader extension is used.\n\nThe last item in the tuple is the `uptodate` function.  If auto\nreloading is enabled it's always called to check if the template\nchanged.  No arguments are passed so the function must store the\nold state somewhere (for example in a closure).  If it returns `False`\nthe template will be reloaded.",
              "signature": "(self, environment: 'Environment', template: str) -> Tuple[str, Optional[str], Optional[Callable[[], bool]]]"
            },
            {
              "name": "list_templates",
              "doc": "Iterates over all templates.  If the loader does not support that\nit should raise a :exc:`TypeError` which is the default behavior.",
              "signature": "(self) -> List[str]"
            },
            {
              "name": "load",
              "doc": "Loads a template.  This method looks up the template in the cache\nor loads one by calling :meth:`get_source`.  Subclasses should not\noverride this method as loaders working on collections of other\nloaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)\nwill not call this method but `get_source` directly.",
              "signature": "(self, environment: 'Environment', name: str, globals: Optional[MutableMapping[str, Any]] = None) -> 'Template'"
            }
          ]
        },
        {
          "name": "DebugUndefined",
          "doc": "An undefined that returns the debug info when printed.\n\n>>> foo = DebugUndefined(name='foo')\n>>> str(foo)\n'{{ foo }}'\n>>> not foo\nTrue\n>>> foo + 42\nTraceback (most recent call last):\n  ...\njinja2.exceptions.UndefinedError: 'foo' is undefined",
          "functions": [
            {
              "name": "__add__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__aiter__",
              "doc": null,
              "signature": "(self) -> AsyncIterator[Any]"
            },
            {
              "name": "__bool__",
              "doc": null,
              "signature": "(self) -> bool"
            },
            {
              "name": "__call__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__complex__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__div__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: Any) -> bool"
            },
            {
              "name": "__float__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__floordiv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__ge__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__getattr__",
              "doc": null,
              "signature": "(self, name: str) -> Any"
            },
            {
              "name": "__getitem__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__gt__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> int"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, hint: Optional[str] = None, obj: Any = missing, name: Optional[str] = None, exc: Type[jinja2.exceptions.TemplateRuntimeError] = <class 'jinja2.exceptions.UndefinedError'>) -> None"
            },
            {
              "name": "__int__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__iter__",
              "doc": null,
              "signature": "(self) -> Iterator[Any]"
            },
            {
              "name": "__le__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> int"
            },
            {
              "name": "__lt__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__mod__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__mul__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__ne__",
              "doc": "Return self!=value.",
              "signature": "(self, other: Any) -> bool"
            },
            {
              "name": "__neg__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__pos__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__pow__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__radd__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rdiv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "__rfloordiv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rmod__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rmul__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rpow__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rsub__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rtruediv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "__sub__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__truediv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "_fail_with_undefined_error",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            }
          ]
        },
        {
          "name": "DictLoader",
          "doc": "Loads a template from a Python dict mapping template names to\ntemplate source.  This loader is useful for unittesting:\n\n>>> loader = DictLoader({'index.html': 'source here'})\n\nBecause auto reloading is rarely useful this is disabled by default.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, mapping: Mapping[str, str]) -> None"
            },
            {
              "name": "get_source",
              "doc": "Get the template source, filename and reload helper for a template.\nIt's passed the environment and template name and has to return a\ntuple in the form ``(source, filename, uptodate)`` or raise a\n`TemplateNotFound` error if it can't locate the template.\n\nThe source part of the returned tuple must be the source of the\ntemplate as a string. The filename should be the name of the\nfile on the filesystem if it was loaded from there, otherwise\n``None``. The filename is used by Python for the tracebacks\nif no loader extension is used.\n\nThe last item in the tuple is the `uptodate` function.  If auto\nreloading is enabled it's always called to check if the template\nchanged.  No arguments are passed so the function must store the\nold state somewhere (for example in a closure).  If it returns `False`\nthe template will be reloaded.",
              "signature": "(self, environment: 'Environment', template: str) -> Tuple[str, NoneType, Callable[[], bool]]"
            },
            {
              "name": "list_templates",
              "doc": "Iterates over all templates.  If the loader does not support that\nit should raise a :exc:`TypeError` which is the default behavior.",
              "signature": "(self) -> List[str]"
            },
            {
              "name": "load",
              "doc": "Loads a template.  This method looks up the template in the cache\nor loads one by calling :meth:`get_source`.  Subclasses should not\noverride this method as loaders working on collections of other\nloaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)\nwill not call this method but `get_source` directly.",
              "signature": "(self, environment: 'Environment', name: str, globals: Optional[MutableMapping[str, Any]] = None) -> 'Template'"
            }
          ]
        },
        {
          "name": "Environment",
          "doc": "The core component of Jinja is the `Environment`.  It contains\nimportant shared variables like configuration, filters, tests,\nglobals and others.  Instances of this class may be modified if\nthey are not shared and if no template was loaded so far.\nModifications on environments after the first template was loaded\nwill lead to surprising effects and undefined behavior.\n\nHere are the possible initialization parameters:\n\n    `block_start_string`\n        The string marking the beginning of a block.  Defaults to ``'{%'``.\n\n    `block_end_string`\n        The string marking the end of a block.  Defaults to ``'%}'``.\n\n    `variable_start_string`\n        The string marking the beginning of a print statement.\n        Defaults to ``'{{'``.\n\n    `variable_end_string`\n        The string marking the end of a print statement.  Defaults to\n        ``'}}'``.\n\n    `comment_start_string`\n        The string marking the beginning of a comment.  Defaults to ``'{#'``.\n\n    `comment_end_string`\n        The string marking the end of a comment.  Defaults to ``'#}'``.\n\n    `line_statement_prefix`\n        If given and a string, this will be used as prefix for line based\n        statements.  See also :ref:`line-statements`.\n\n    `line_comment_prefix`\n        If given and a string, this will be used as prefix for line based\n        comments.  See also :ref:`line-statements`.\n\n        .. versionadded:: 2.2\n\n    `trim_blocks`\n        If this is set to ``True`` the first newline after a block is\n        removed (block, not variable tag!).  Defaults to `False`.\n\n    `lstrip_blocks`\n        If this is set to ``True`` leading spaces and tabs are stripped\n        from the start of a line to a block.  Defaults to `False`.\n\n    `newline_sequence`\n        The sequence that starts a newline.  Must be one of ``'\\r'``,\n        ``'\\n'`` or ``'\\r\\n'``.  The default is ``'\\n'`` which is a\n        useful default for Linux and OS X systems as well as web\n        applications.\n\n    `keep_trailing_newline`\n        Preserve the trailing newline when rendering templates.\n        The default is ``False``, which causes a single newline,\n        if present, to be stripped from the end of the template.\n\n        .. versionadded:: 2.7\n\n    `extensions`\n        List of Jinja extensions to use.  This can either be import paths\n        as strings or extension classes.  For more information have a\n        look at :ref:`the extensions documentation <jinja-extensions>`.\n\n    `optimized`\n        should the optimizer be enabled?  Default is ``True``.\n\n    `undefined`\n        :class:`Undefined` or a subclass of it that is used to represent\n        undefined values in the template.\n\n    `finalize`\n        A callable that can be used to process the result of a variable\n        expression before it is output.  For example one can convert\n        ``None`` implicitly into an empty string here.\n\n    `autoescape`\n        If set to ``True`` the XML/HTML autoescaping feature is enabled by\n        default.  For more details about autoescaping see\n        :class:`~markupsafe.Markup`.  As of Jinja 2.4 this can also\n        be a callable that is passed the template name and has to\n        return ``True`` or ``False`` depending on autoescape should be\n        enabled by default.\n\n        .. versionchanged:: 2.4\n           `autoescape` can now be a function\n\n    `loader`\n        The template loader for this environment.\n\n    `cache_size`\n        The size of the cache.  Per default this is ``400`` which means\n        that if more than 400 templates are loaded the loader will clean\n        out the least recently used template.  If the cache size is set to\n        ``0`` templates are recompiled all the time, if the cache size is\n        ``-1`` the cache will not be cleaned.\n\n        .. versionchanged:: 2.8\n           The cache size was increased to 400 from a low 50.\n\n    `auto_reload`\n        Some loaders load templates from locations where the template\n        sources may change (ie: file system or database).  If\n        ``auto_reload`` is set to ``True`` (default) every time a template is\n        requested the loader checks if the source changed and if yes, it\n        will reload the template.  For higher performance it's possible to\n        disable that.\n\n    `bytecode_cache`\n        If set to a bytecode cache object, this object will provide a\n        cache for the internal Jinja bytecode so that templates don't\n        have to be parsed if they were not changed.\n\n        See :ref:`bytecode-cache` for more information.\n\n    `enable_async`\n        If set to true this enables async template execution which\n        allows using async functions and generators.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, block_start_string: str = '{%', block_end_string: str = '%}', variable_start_string: str = '{{', variable_end_string: str = '}}', comment_start_string: str = '{#', comment_end_string: str = '#}', line_statement_prefix: Optional[str] = None, line_comment_prefix: Optional[str] = None, trim_blocks: bool = False, lstrip_blocks: bool = False, newline_sequence: \"te.Literal['\\\\n', '\\\\r\\\\n', '\\\\r']\" = '\\n', keep_trailing_newline: bool = False, extensions: Sequence[Union[str, Type[ForwardRef('Extension')]]] = (), optimized: bool = True, undefined: Type[jinja2.runtime.Undefined] = <class 'jinja2.runtime.Undefined'>, finalize: Optional[Callable[..., Any]] = None, autoescape: Union[bool, Callable[[Optional[str]], bool]] = False, loader: Optional[ForwardRef('BaseLoader')] = None, cache_size: int = 400, auto_reload: bool = True, bytecode_cache: Optional[ForwardRef('BytecodeCache')] = None, enable_async: bool = False)"
            },
            {
              "name": "_compile",
              "doc": "Internal hook that can be overridden to hook a different compile\nmethod in.\n\n.. versionadded:: 2.5",
              "signature": "(self, source: str, filename: str) -> code"
            },
            {
              "name": "_filter_test_common",
              "doc": null,
              "signature": "(self, name: Union[str, jinja2.runtime.Undefined], value: Any, args: Optional[Sequence[Any]], kwargs: Optional[Mapping[str, Any]], context: Optional[jinja2.runtime.Context], eval_ctx: Optional[jinja2.nodes.EvalContext], is_filter: bool) -> Any"
            },
            {
              "name": "_generate",
              "doc": "Internal hook that can be overridden to hook a different generate\nmethod in.\n\n.. versionadded:: 2.5",
              "signature": "(self, source: jinja2.nodes.Template, name: Optional[str], filename: Optional[str], defer_init: bool = False) -> str"
            },
            {
              "name": "_load_template",
              "doc": null,
              "signature": "(self, name: str, globals: Optional[MutableMapping[str, Any]]) -> 'Template'"
            },
            {
              "name": "_parse",
              "doc": "Internal parsing function used by `parse` and `compile`.",
              "signature": "(self, source: str, name: Optional[str], filename: Optional[str]) -> jinja2.nodes.Template"
            },
            {
              "name": "_tokenize",
              "doc": "Called by the parser to do the preprocessing and filtering\nfor all the extensions.  Returns a :class:`~jinja2.lexer.TokenStream`.",
              "signature": "(self, source: str, name: Optional[str], filename: Optional[str] = None, state: Optional[str] = None) -> jinja2.lexer.TokenStream"
            },
            {
              "name": "add_extension",
              "doc": "Adds an extension after the environment was created.\n\n.. versionadded:: 2.5",
              "signature": "(self, extension: Union[str, Type[ForwardRef('Extension')]]) -> None"
            },
            {
              "name": "call_filter",
              "doc": "Invoke a filter on a value the same way the compiler does.\n\nThis might return a coroutine if the filter is running from an\nenvironment in async mode and the filter supports async\nexecution. It's your responsibility to await this if needed.\n\n.. versionadded:: 2.7",
              "signature": "(self, name: str, value: Any, args: Optional[Sequence[Any]] = None, kwargs: Optional[Mapping[str, Any]] = None, context: Optional[jinja2.runtime.Context] = None, eval_ctx: Optional[jinja2.nodes.EvalContext] = None) -> Any"
            },
            {
              "name": "call_test",
              "doc": "Invoke a test on a value the same way the compiler does.\n\nThis might return a coroutine if the test is running from an\nenvironment in async mode and the test supports async execution.\nIt's your responsibility to await this if needed.\n\n.. versionchanged:: 3.0\n    Tests support ``@pass_context``, etc. decorators. Added\n    the ``context`` and ``eval_ctx`` parameters.\n\n.. versionadded:: 2.7",
              "signature": "(self, name: str, value: Any, args: Optional[Sequence[Any]] = None, kwargs: Optional[Mapping[str, Any]] = None, context: Optional[jinja2.runtime.Context] = None, eval_ctx: Optional[jinja2.nodes.EvalContext] = None) -> Any"
            },
            {
              "name": "compile",
              "doc": "Compile a node or template source code.  The `name` parameter is\nthe load name of the template after it was joined using\n:meth:`join_path` if necessary, not the filename on the file system.\nthe `filename` parameter is the estimated filename of the template on\nthe file system.  If the template came from a database or memory this\ncan be omitted.\n\nThe return value of this method is a python code object.  If the `raw`\nparameter is `True` the return value will be a string with python\ncode equivalent to the bytecode returned otherwise.  This method is\nmainly used internally.\n\n`defer_init` is use internally to aid the module code generator.  This\ncauses the generated code to be able to import without the global\nenvironment variable to be set.\n\n.. versionadded:: 2.4\n   `defer_init` parameter added.",
              "signature": "(self, source: Union[str, jinja2.nodes.Template], name: Optional[str] = None, filename: Optional[str] = None, raw: bool = False, defer_init: bool = False) -> Union[str, code]"
            },
            {
              "name": "compile_expression",
              "doc": "A handy helper method that returns a callable that accepts keyword\narguments that appear as variables in the expression.  If called it\nreturns the result of the expression.\n\nThis is useful if applications want to use the same rules as Jinja\nin template \"configuration files\" or similar situations.\n\nExample usage:\n\n>>> env = Environment()\n>>> expr = env.compile_expression('foo == 42')\n>>> expr(foo=23)\nFalse\n>>> expr(foo=42)\nTrue\n\nPer default the return value is converted to `None` if the\nexpression returns an undefined value.  This can be changed\nby setting `undefined_to_none` to `False`.\n\n>>> env.compile_expression('var')() is None\nTrue\n>>> env.compile_expression('var', undefined_to_none=False)()\nUndefined\n\n.. versionadded:: 2.1",
              "signature": "(self, source: str, undefined_to_none: bool = True) -> 'TemplateExpression'"
            },
            {
              "name": "compile_templates",
              "doc": "Finds all the templates the loader can find, compiles them\nand stores them in `target`.  If `zip` is `None`, instead of in a\nzipfile, the templates will be stored in a directory.\nBy default a deflate zip algorithm is used. To switch to\nthe stored algorithm, `zip` can be set to ``'stored'``.\n\n`extensions` and `filter_func` are passed to :meth:`list_templates`.\nEach template returned will be compiled to the target folder or\nzipfile.\n\nBy default template compilation errors are ignored.  In case a\nlog function is provided, errors are logged.  If you want template\nsyntax errors to abort the compilation you can set `ignore_errors`\nto `False` and you will get an exception on syntax errors.\n\n.. versionadded:: 2.4",
              "signature": "(self, target: Union[str, ForwardRef('os.PathLike[str]')], extensions: Optional[Collection[str]] = None, filter_func: Optional[Callable[[str], bool]] = None, zip: Optional[str] = 'deflated', log_function: Optional[Callable[[str], NoneType]] = None, ignore_errors: bool = True) -> None"
            },
            {
              "name": "extend",
              "doc": "Add the items to the instance of the environment if they do not exist\nyet.  This is used by :ref:`extensions <writing-extensions>` to register\ncallbacks and configuration values without breaking inheritance.",
              "signature": "(self, **attributes: Any) -> None"
            },
            {
              "name": "from_string",
              "doc": "Load a template from a source string without using\n:attr:`loader`.\n\n:param source: Jinja source to compile into a template.\n:param globals: Extend the environment :attr:`globals` with\n    these extra variables available for all renders of this\n    template. If the template has already been loaded and\n    cached, its globals are updated with any new items.\n:param template_class: Return an instance of this\n    :class:`Template` class.",
              "signature": "(self, source: Union[str, jinja2.nodes.Template], globals: Optional[MutableMapping[str, Any]] = None, template_class: Optional[Type[ForwardRef('Template')]] = None) -> 'Template'"
            },
            {
              "name": "get_or_select_template",
              "doc": "Use :meth:`select_template` if an iterable of template names\nis given, or :meth:`get_template` if one name is given.\n\n.. versionadded:: 2.3",
              "signature": "(self, template_name_or_list: Union[str, ForwardRef('Template'), List[Union[str, ForwardRef('Template')]]], parent: Optional[str] = None, globals: Optional[MutableMapping[str, Any]] = None) -> 'Template'"
            },
            {
              "name": "get_template",
              "doc": "Load a template by name with :attr:`loader` and return a\n:class:`Template`. If the template does not exist a\n:exc:`TemplateNotFound` exception is raised.\n\n:param name: Name of the template to load. When loading\n    templates from the filesystem, \"/\" is used as the path\n    separator, even on Windows.\n:param parent: The name of the parent template importing this\n    template. :meth:`join_path` can be used to implement name\n    transformations with this.\n:param globals: Extend the environment :attr:`globals` with\n    these extra variables available for all renders of this\n    template. If the template has already been loaded and\n    cached, its globals are updated with any new items.\n\n.. versionchanged:: 3.0\n    If a template is loaded from cache, ``globals`` will update\n    the template's globals instead of ignoring the new values.\n\n.. versionchanged:: 2.4\n    If ``name`` is a :class:`Template` object it is returned\n    unchanged.",
              "signature": "(self, name: Union[str, ForwardRef('Template')], parent: Optional[str] = None, globals: Optional[MutableMapping[str, Any]] = None) -> 'Template'"
            },
            {
              "name": "getattr",
              "doc": "Get an item or attribute of an object but prefer the attribute.\nUnlike :meth:`getitem` the attribute *must* be a string.",
              "signature": "(self, obj: Any, attribute: str) -> Any"
            },
            {
              "name": "getitem",
              "doc": "Get an item or attribute of an object but prefer the item.",
              "signature": "(self, obj: Any, argument: Union[str, Any]) -> Union[Any, jinja2.runtime.Undefined]"
            },
            {
              "name": "handle_exception",
              "doc": "Exception handling helper.  This is used internally to either raise\nrewritten exceptions or return a rendered traceback for the template.",
              "signature": "(self, source: Optional[str] = None) -> 'te.NoReturn'"
            },
            {
              "name": "iter_extensions",
              "doc": "Iterates over the extensions by priority.",
              "signature": "(self) -> Iterator[ForwardRef('Extension')]"
            },
            {
              "name": "join_path",
              "doc": "Join a template with the parent.  By default all the lookups are\nrelative to the loader root so this method returns the `template`\nparameter unchanged, but if the paths should be relative to the\nparent template, this function can be used to calculate the real\ntemplate name.\n\nSubclasses may override this method and implement template path\njoining here.",
              "signature": "(self, template: str, parent: str) -> str"
            },
            {
              "name": "lex",
              "doc": "Lex the given sourcecode and return a generator that yields\ntokens as tuples in the form ``(lineno, token_type, value)``.\nThis can be useful for :ref:`extension development <writing-extensions>`\nand debugging templates.\n\nThis does not perform preprocessing.  If you want the preprocessing\nof the extensions to be applied you have to filter source through\nthe :meth:`preprocess` method.",
              "signature": "(self, source: str, name: Optional[str] = None, filename: Optional[str] = None) -> Iterator[Tuple[int, str, str]]"
            },
            {
              "name": "list_templates",
              "doc": "Returns a list of templates for this environment.  This requires\nthat the loader supports the loader's\n:meth:`~BaseLoader.list_templates` method.\n\nIf there are other files in the template folder besides the\nactual templates, the returned list can be filtered.  There are two\nways: either `extensions` is set to a list of file extensions for\ntemplates, or a `filter_func` can be provided which is a callable that\nis passed a template name and should return `True` if it should end up\nin the result list.\n\nIf the loader does not support that, a :exc:`TypeError` is raised.\n\n.. versionadded:: 2.4",
              "signature": "(self, extensions: Optional[Collection[str]] = None, filter_func: Optional[Callable[[str], bool]] = None) -> List[str]"
            },
            {
              "name": "make_globals",
              "doc": "Make the globals map for a template. Any given template\nglobals overlay the environment :attr:`globals`.\n\nReturns a :class:`collections.ChainMap`. This allows any changes\nto a template's globals to only affect that template, while\nchanges to the environment's globals are still reflected.\nHowever, avoid modifying any globals after a template is loaded.\n\n:param d: Dict of template-specific globals.\n\n.. versionchanged:: 3.0\n    Use :class:`collections.ChainMap` to always prevent mutating\n    environment globals.",
              "signature": "(self, d: Optional[MutableMapping[str, Any]]) -> MutableMapping[str, Any]"
            },
            {
              "name": "overlay",
              "doc": "Create a new overlay environment that shares all the data with the\ncurrent environment except for cache and the overridden attributes.\nExtensions cannot be removed for an overlayed environment.  An overlayed\nenvironment automatically gets all the extensions of the environment it\nis linked to plus optional extra extensions.\n\nCreating overlays should happen after the initial environment was set\nup completely.  Not all attributes are truly linked, some are just\ncopied over so modifications on the original environment may not shine\nthrough.\n\n.. versionchanged:: 3.1.5\n    ``enable_async`` is applied correctly.\n\n.. versionchanged:: 3.1.2\n    Added the ``newline_sequence``, ``keep_trailing_newline``,\n    and ``enable_async`` parameters to match ``__init__``.",
              "signature": "(self, block_start_string: str = missing, block_end_string: str = missing, variable_start_string: str = missing, variable_end_string: str = missing, comment_start_string: str = missing, comment_end_string: str = missing, line_statement_prefix: Optional[str] = missing, line_comment_prefix: Optional[str] = missing, trim_blocks: bool = missing, lstrip_blocks: bool = missing, newline_sequence: \"te.Literal['\\\\n', '\\\\r\\\\n', '\\\\r']\" = missing, keep_trailing_newline: bool = missing, extensions: Sequence[Union[str, Type[ForwardRef('Extension')]]] = missing, optimized: bool = missing, undefined: Type[jinja2.runtime.Undefined] = missing, finalize: Optional[Callable[..., Any]] = missing, autoescape: Union[bool, Callable[[Optional[str]], bool]] = missing, loader: Optional[ForwardRef('BaseLoader')] = missing, cache_size: int = missing, auto_reload: bool = missing, bytecode_cache: Optional[ForwardRef('BytecodeCache')] = missing, enable_async: bool = missing) -> 'te.Self'"
            },
            {
              "name": "parse",
              "doc": "Parse the sourcecode and return the abstract syntax tree.  This\ntree of nodes is used by the compiler to convert the template into\nexecutable source- or bytecode.  This is useful for debugging or to\nextract information from templates.\n\nIf you are :ref:`developing Jinja extensions <writing-extensions>`\nthis gives you a good overview of the node tree generated.",
              "signature": "(self, source: str, name: Optional[str] = None, filename: Optional[str] = None) -> jinja2.nodes.Template"
            },
            {
              "name": "preprocess",
              "doc": "Preprocesses the source with all extensions.  This is automatically\ncalled for all parsing and compiling methods but *not* for :meth:`lex`\nbecause there you usually only want the actual source tokenized.",
              "signature": "(self, source: str, name: Optional[str] = None, filename: Optional[str] = None) -> str"
            },
            {
              "name": "select_template",
              "doc": "Like :meth:`get_template`, but tries loading multiple names.\nIf none of the names can be loaded a :exc:`TemplatesNotFound`\nexception is raised.\n\n:param names: List of template names to try loading in order.\n:param parent: The name of the parent template importing this\n    template. :meth:`join_path` can be used to implement name\n    transformations with this.\n:param globals: Extend the environment :attr:`globals` with\n    these extra variables available for all renders of this\n    template. If the template has already been loaded and\n    cached, its globals are updated with any new items.\n\n.. versionchanged:: 3.0\n    If a template is loaded from cache, ``globals`` will update\n    the template's globals instead of ignoring the new values.\n\n.. versionchanged:: 2.11\n    If ``names`` is :class:`Undefined`, an :exc:`UndefinedError`\n    is raised instead. If no templates were found and ``names``\n    contains :class:`Undefined`, the message is more helpful.\n\n.. versionchanged:: 2.4\n    If ``names`` contains a :class:`Template` object it is\n    returned unchanged.\n\n.. versionadded:: 2.3",
              "signature": "(self, names: Iterable[Union[str, ForwardRef('Template')]], parent: Optional[str] = None, globals: Optional[MutableMapping[str, Any]] = None) -> 'Template'"
            }
          ]
        },
        {
          "name": "FileSystemBytecodeCache",
          "doc": "A bytecode cache that stores bytecode on the filesystem.  It accepts\ntwo arguments: The directory where the cache items are stored and a\npattern string that is used to build the filename.\n\nIf no directory is specified a default cache directory is selected.  On\nWindows the user's temp directory is used, on UNIX systems a directory\nis created for the user in the system temp directory.\n\nThe pattern can be used to have multiple separate caches operate on the\nsame directory.  The default pattern is ``'__jinja2_%s.cache'``.  ``%s``\nis replaced with the cache key.\n\n>>> bcc = FileSystemBytecodeCache('/tmp/jinja_cache', '%s.cache')\n\nThis bytecode cache supports clearing of the cache using the clear method.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, directory: Optional[str] = None, pattern: str = '__jinja2_%s.cache') -> None"
            },
            {
              "name": "_get_cache_filename",
              "doc": null,
              "signature": "(self, bucket: jinja2.bccache.Bucket) -> str"
            },
            {
              "name": "_get_default_cache_dir",
              "doc": null,
              "signature": "(self) -> str"
            },
            {
              "name": "clear",
              "doc": "Clears the cache.  This method is not used by Jinja but should be\nimplemented to allow applications to clear the bytecode cache used\nby a particular environment.",
              "signature": "(self) -> None"
            },
            {
              "name": "dump_bytecode",
              "doc": "Subclasses have to override this method to write the bytecode\nfrom a bucket back to the cache.  If it unable to do so it must not\nfail silently but raise an exception.",
              "signature": "(self, bucket: jinja2.bccache.Bucket) -> None"
            },
            {
              "name": "get_bucket",
              "doc": "Return a cache bucket for the given template.  All arguments are\nmandatory but filename may be `None`.",
              "signature": "(self, environment: 'Environment', name: str, filename: Optional[str], source: str) -> jinja2.bccache.Bucket"
            },
            {
              "name": "get_cache_key",
              "doc": "Returns the unique hash key for this template name.",
              "signature": "(self, name: str, filename: Optional[str] = None) -> str"
            },
            {
              "name": "get_source_checksum",
              "doc": "Returns a checksum for the source.",
              "signature": "(self, source: str) -> str"
            },
            {
              "name": "load_bytecode",
              "doc": "Subclasses have to override this method to load bytecode into a\nbucket.  If they are not able to find code in the cache for the\nbucket, it must not do anything.",
              "signature": "(self, bucket: jinja2.bccache.Bucket) -> None"
            },
            {
              "name": "set_bucket",
              "doc": "Put the bucket into the cache.",
              "signature": "(self, bucket: jinja2.bccache.Bucket) -> None"
            }
          ]
        },
        {
          "name": "FileSystemLoader",
          "doc": "Load templates from a directory in the file system.\n\nThe path can be relative or absolute. Relative paths are relative to\nthe current working directory.\n\n.. code-block:: python\n\n    loader = FileSystemLoader(\"templates\")\n\nA list of paths can be given. The directories will be searched in\norder, stopping at the first matching template.\n\n.. code-block:: python\n\n    loader = FileSystemLoader([\"/override/templates\", \"/default/templates\"])\n\n:param searchpath: A path, or list of paths, to the directory that\n    contains the templates.\n:param encoding: Use this encoding to read the text from template\n    files.\n:param followlinks: Follow symbolic links in the path.\n\n.. versionchanged:: 2.8\n    Added the ``followlinks`` parameter.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, searchpath: Union[str, ForwardRef('os.PathLike[str]'), Sequence[Union[str, ForwardRef('os.PathLike[str]')]]], encoding: str = 'utf-8', followlinks: bool = False) -> None"
            },
            {
              "name": "get_source",
              "doc": "Get the template source, filename and reload helper for a template.\nIt's passed the environment and template name and has to return a\ntuple in the form ``(source, filename, uptodate)`` or raise a\n`TemplateNotFound` error if it can't locate the template.\n\nThe source part of the returned tuple must be the source of the\ntemplate as a string. The filename should be the name of the\nfile on the filesystem if it was loaded from there, otherwise\n``None``. The filename is used by Python for the tracebacks\nif no loader extension is used.\n\nThe last item in the tuple is the `uptodate` function.  If auto\nreloading is enabled it's always called to check if the template\nchanged.  No arguments are passed so the function must store the\nold state somewhere (for example in a closure).  If it returns `False`\nthe template will be reloaded.",
              "signature": "(self, environment: 'Environment', template: str) -> Tuple[str, str, Callable[[], bool]]"
            },
            {
              "name": "list_templates",
              "doc": "Iterates over all templates.  If the loader does not support that\nit should raise a :exc:`TypeError` which is the default behavior.",
              "signature": "(self) -> List[str]"
            },
            {
              "name": "load",
              "doc": "Loads a template.  This method looks up the template in the cache\nor loads one by calling :meth:`get_source`.  Subclasses should not\noverride this method as loaders working on collections of other\nloaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)\nwill not call this method but `get_source` directly.",
              "signature": "(self, environment: 'Environment', name: str, globals: Optional[MutableMapping[str, Any]] = None) -> 'Template'"
            }
          ]
        },
        {
          "name": "FunctionLoader",
          "doc": "A loader that is passed a function which does the loading.  The\nfunction receives the name of the template and has to return either\na string with the template source, a tuple in the form ``(source,\nfilename, uptodatefunc)`` or `None` if the template does not exist.\n\n>>> def load_template(name):\n...     if name == 'index.html':\n...         return '...'\n...\n>>> loader = FunctionLoader(load_template)\n\nThe `uptodatefunc` is a function that is called if autoreload is enabled\nand has to return `True` if the template is still up to date.  For more\ndetails have a look at :meth:`BaseLoader.get_source` which has the same\nreturn value.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, load_func: Callable[[str], Union[str, Tuple[str, Optional[str], Optional[Callable[[], bool]]], NoneType]]) -> None"
            },
            {
              "name": "get_source",
              "doc": "Get the template source, filename and reload helper for a template.\nIt's passed the environment and template name and has to return a\ntuple in the form ``(source, filename, uptodate)`` or raise a\n`TemplateNotFound` error if it can't locate the template.\n\nThe source part of the returned tuple must be the source of the\ntemplate as a string. The filename should be the name of the\nfile on the filesystem if it was loaded from there, otherwise\n``None``. The filename is used by Python for the tracebacks\nif no loader extension is used.\n\nThe last item in the tuple is the `uptodate` function.  If auto\nreloading is enabled it's always called to check if the template\nchanged.  No arguments are passed so the function must store the\nold state somewhere (for example in a closure).  If it returns `False`\nthe template will be reloaded.",
              "signature": "(self, environment: 'Environment', template: str) -> Tuple[str, Optional[str], Optional[Callable[[], bool]]]"
            },
            {
              "name": "list_templates",
              "doc": "Iterates over all templates.  If the loader does not support that\nit should raise a :exc:`TypeError` which is the default behavior.",
              "signature": "(self) -> List[str]"
            },
            {
              "name": "load",
              "doc": "Loads a template.  This method looks up the template in the cache\nor loads one by calling :meth:`get_source`.  Subclasses should not\noverride this method as loaders working on collections of other\nloaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)\nwill not call this method but `get_source` directly.",
              "signature": "(self, environment: 'Environment', name: str, globals: Optional[MutableMapping[str, Any]] = None) -> 'Template'"
            }
          ]
        },
        {
          "name": "MemcachedBytecodeCache",
          "doc": "This class implements a bytecode cache that uses a memcache cache for\nstoring the information.  It does not enforce a specific memcache library\n(tummy's memcache or cmemcache) but will accept any class that provides\nthe minimal interface required.\n\nLibraries compatible with this class:\n\n-   `cachelib <https://github.com/pallets/cachelib>`_\n-   `python-memcached <https://pypi.org/project/python-memcached/>`_\n\n(Unfortunately the django cache interface is not compatible because it\ndoes not support storing binary data, only text. You can however pass\nthe underlying cache client to the bytecode cache which is available\nas `django.core.cache.cache._client`.)\n\nThe minimal interface for the client passed to the constructor is this:\n\n.. class:: MinimalClientInterface\n\n    .. method:: set(key, value[, timeout])\n\n        Stores the bytecode in the cache.  `value` is a string and\n        `timeout` the timeout of the key.  If timeout is not provided\n        a default timeout or no timeout should be assumed, if it's\n        provided it's an integer with the number of seconds the cache\n        item should exist.\n\n    .. method:: get(key)\n\n        Returns the value for the cache key.  If the item does not\n        exist in the cache the return value must be `None`.\n\nThe other arguments to the constructor are the prefix for all keys that\nis added before the actual cache key and the timeout for the bytecode in\nthe cache system.  We recommend a high (or no) timeout.\n\nThis bytecode cache does not support clearing of used items in the cache.\nThe clear method is a no-operation function.\n\n.. versionadded:: 2.7\n   Added support for ignoring memcache errors through the\n   `ignore_memcache_errors` parameter.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, client: '_MemcachedClient', prefix: str = 'jinja2/bytecode/', timeout: Optional[int] = None, ignore_memcache_errors: bool = True)"
            },
            {
              "name": "clear",
              "doc": "Clears the cache.  This method is not used by Jinja but should be\nimplemented to allow applications to clear the bytecode cache used\nby a particular environment.",
              "signature": "(self) -> None"
            },
            {
              "name": "dump_bytecode",
              "doc": "Subclasses have to override this method to write the bytecode\nfrom a bucket back to the cache.  If it unable to do so it must not\nfail silently but raise an exception.",
              "signature": "(self, bucket: jinja2.bccache.Bucket) -> None"
            },
            {
              "name": "get_bucket",
              "doc": "Return a cache bucket for the given template.  All arguments are\nmandatory but filename may be `None`.",
              "signature": "(self, environment: 'Environment', name: str, filename: Optional[str], source: str) -> jinja2.bccache.Bucket"
            },
            {
              "name": "get_cache_key",
              "doc": "Returns the unique hash key for this template name.",
              "signature": "(self, name: str, filename: Optional[str] = None) -> str"
            },
            {
              "name": "get_source_checksum",
              "doc": "Returns a checksum for the source.",
              "signature": "(self, source: str) -> str"
            },
            {
              "name": "load_bytecode",
              "doc": "Subclasses have to override this method to load bytecode into a\nbucket.  If they are not able to find code in the cache for the\nbucket, it must not do anything.",
              "signature": "(self, bucket: jinja2.bccache.Bucket) -> None"
            },
            {
              "name": "set_bucket",
              "doc": "Put the bucket into the cache.",
              "signature": "(self, bucket: jinja2.bccache.Bucket) -> None"
            }
          ]
        },
        {
          "name": "ModuleLoader",
          "doc": "This loader loads templates from precompiled templates.\n\nExample usage:\n\n>>> loader = ModuleLoader('/path/to/compiled/templates')\n\nTemplates can be precompiled with :meth:`Environment.compile_templates`.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, path: Union[str, ForwardRef('os.PathLike[str]'), Sequence[Union[str, ForwardRef('os.PathLike[str]')]]]) -> None"
            },
            {
              "name": "get_module_filename",
              "doc": null,
              "signature": "(name: str) -> str"
            },
            {
              "name": "get_source",
              "doc": "Get the template source, filename and reload helper for a template.\nIt's passed the environment and template name and has to return a\ntuple in the form ``(source, filename, uptodate)`` or raise a\n`TemplateNotFound` error if it can't locate the template.\n\nThe source part of the returned tuple must be the source of the\ntemplate as a string. The filename should be the name of the\nfile on the filesystem if it was loaded from there, otherwise\n``None``. The filename is used by Python for the tracebacks\nif no loader extension is used.\n\nThe last item in the tuple is the `uptodate` function.  If auto\nreloading is enabled it's always called to check if the template\nchanged.  No arguments are passed so the function must store the\nold state somewhere (for example in a closure).  If it returns `False`\nthe template will be reloaded.",
              "signature": "(self, environment: 'Environment', template: str) -> Tuple[str, Optional[str], Optional[Callable[[], bool]]]"
            },
            {
              "name": "get_template_key",
              "doc": null,
              "signature": "(name: str) -> str"
            },
            {
              "name": "list_templates",
              "doc": "Iterates over all templates.  If the loader does not support that\nit should raise a :exc:`TypeError` which is the default behavior.",
              "signature": "(self) -> List[str]"
            },
            {
              "name": "load",
              "doc": "Loads a template.  This method looks up the template in the cache\nor loads one by calling :meth:`get_source`.  Subclasses should not\noverride this method as loaders working on collections of other\nloaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)\nwill not call this method but `get_source` directly.",
              "signature": "(self, environment: 'Environment', name: str, globals: Optional[MutableMapping[str, Any]] = None) -> 'Template'"
            }
          ]
        },
        {
          "name": "PackageLoader",
          "doc": "Load templates from a directory in a Python package.\n\n:param package_name: Import name of the package that contains the\n    template directory.\n:param package_path: Directory within the imported package that\n    contains the templates.\n:param encoding: Encoding of template files.\n\nThe following example looks up templates in the ``pages`` directory\nwithin the ``project.ui`` package.\n\n.. code-block:: python\n\n    loader = PackageLoader(\"project.ui\", \"pages\")\n\nOnly packages installed as directories (standard pip behavior) or\nzip/egg files (less common) are supported. The Python API for\nintrospecting data in packages is too limited to support other\ninstallation methods the way this loader requires.\n\nThere is limited support for :pep:`420` namespace packages. The\ntemplate directory is assumed to only be in one namespace\ncontributor. Zip files contributing to a namespace are not\nsupported.\n\n.. versionchanged:: 3.0\n    No longer uses ``setuptools`` as a dependency.\n\n.. versionchanged:: 3.0\n    Limited PEP 420 namespace package support.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, package_name: str, package_path: 'str' = 'templates', encoding: str = 'utf-8') -> None"
            },
            {
              "name": "get_source",
              "doc": "Get the template source, filename and reload helper for a template.\nIt's passed the environment and template name and has to return a\ntuple in the form ``(source, filename, uptodate)`` or raise a\n`TemplateNotFound` error if it can't locate the template.\n\nThe source part of the returned tuple must be the source of the\ntemplate as a string. The filename should be the name of the\nfile on the filesystem if it was loaded from there, otherwise\n``None``. The filename is used by Python for the tracebacks\nif no loader extension is used.\n\nThe last item in the tuple is the `uptodate` function.  If auto\nreloading is enabled it's always called to check if the template\nchanged.  No arguments are passed so the function must store the\nold state somewhere (for example in a closure).  If it returns `False`\nthe template will be reloaded.",
              "signature": "(self, environment: 'Environment', template: str) -> Tuple[str, str, Optional[Callable[[], bool]]]"
            },
            {
              "name": "list_templates",
              "doc": "Iterates over all templates.  If the loader does not support that\nit should raise a :exc:`TypeError` which is the default behavior.",
              "signature": "(self) -> List[str]"
            },
            {
              "name": "load",
              "doc": "Loads a template.  This method looks up the template in the cache\nor loads one by calling :meth:`get_source`.  Subclasses should not\noverride this method as loaders working on collections of other\nloaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)\nwill not call this method but `get_source` directly.",
              "signature": "(self, environment: 'Environment', name: str, globals: Optional[MutableMapping[str, Any]] = None) -> 'Template'"
            }
          ]
        },
        {
          "name": "PrefixLoader",
          "doc": "A loader that is passed a dict of loaders where each loader is bound\nto a prefix.  The prefix is delimited from the template by a slash per\ndefault, which can be changed by setting the `delimiter` argument to\nsomething else::\n\n    loader = PrefixLoader({\n        'app1':     PackageLoader('mypackage.app1'),\n        'app2':     PackageLoader('mypackage.app2')\n    })\n\nBy loading ``'app1/index.html'`` the file from the app1 package is loaded,\nby loading ``'app2/index.html'`` the file from the second.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, mapping: Mapping[str, jinja2.loaders.BaseLoader], delimiter: str = '/') -> None"
            },
            {
              "name": "get_loader",
              "doc": null,
              "signature": "(self, template: str) -> Tuple[jinja2.loaders.BaseLoader, str]"
            },
            {
              "name": "get_source",
              "doc": "Get the template source, filename and reload helper for a template.\nIt's passed the environment and template name and has to return a\ntuple in the form ``(source, filename, uptodate)`` or raise a\n`TemplateNotFound` error if it can't locate the template.\n\nThe source part of the returned tuple must be the source of the\ntemplate as a string. The filename should be the name of the\nfile on the filesystem if it was loaded from there, otherwise\n``None``. The filename is used by Python for the tracebacks\nif no loader extension is used.\n\nThe last item in the tuple is the `uptodate` function.  If auto\nreloading is enabled it's always called to check if the template\nchanged.  No arguments are passed so the function must store the\nold state somewhere (for example in a closure).  If it returns `False`\nthe template will be reloaded.",
              "signature": "(self, environment: 'Environment', template: str) -> Tuple[str, Optional[str], Optional[Callable[[], bool]]]"
            },
            {
              "name": "list_templates",
              "doc": "Iterates over all templates.  If the loader does not support that\nit should raise a :exc:`TypeError` which is the default behavior.",
              "signature": "(self) -> List[str]"
            },
            {
              "name": "load",
              "doc": "Loads a template.  This method looks up the template in the cache\nor loads one by calling :meth:`get_source`.  Subclasses should not\noverride this method as loaders working on collections of other\nloaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)\nwill not call this method but `get_source` directly.",
              "signature": "(self, environment: 'Environment', name: str, globals: Optional[MutableMapping[str, Any]] = None) -> 'Template'"
            }
          ]
        },
        {
          "name": "StrictUndefined",
          "doc": "An undefined that barks on print and iteration as well as boolean\ntests and all kinds of comparisons.  In other words: you can do nothing\nwith it except checking if it's defined using the `defined` test.\n\n>>> foo = StrictUndefined(name='foo')\n>>> str(foo)\nTraceback (most recent call last):\n  ...\njinja2.exceptions.UndefinedError: 'foo' is undefined\n>>> not foo\nTraceback (most recent call last):\n  ...\njinja2.exceptions.UndefinedError: 'foo' is undefined\n>>> foo + 42\nTraceback (most recent call last):\n  ...\njinja2.exceptions.UndefinedError: 'foo' is undefined",
          "functions": [
            {
              "name": "__add__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__aiter__",
              "doc": null,
              "signature": "(self) -> AsyncIterator[Any]"
            },
            {
              "name": "__bool__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__call__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__complex__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__contains__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__div__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__eq__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__float__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__floordiv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__ge__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__getattr__",
              "doc": null,
              "signature": "(self, name: str) -> Any"
            },
            {
              "name": "__getitem__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__gt__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__hash__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, hint: Optional[str] = None, obj: Any = missing, name: Optional[str] = None, exc: Type[jinja2.exceptions.TemplateRuntimeError] = <class 'jinja2.exceptions.UndefinedError'>) -> None"
            },
            {
              "name": "__int__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__iter__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__le__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__len__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__lt__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__mod__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__mul__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__ne__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__neg__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__pos__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__pow__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__radd__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rdiv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "__rfloordiv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rmod__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rmul__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rpow__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rsub__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rtruediv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__str__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__sub__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__truediv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "_fail_with_undefined_error",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            }
          ]
        },
        {
          "name": "Template",
          "doc": "A compiled template that can be rendered.\n\nUse the methods on :class:`Environment` to create or load templates.\nThe environment is used to configure how templates are compiled and\nbehave.\n\nIt is also possible to create a template object directly. This is\nnot usually recommended. The constructor takes most of the same\narguments as :class:`Environment`. All templates created with the\nsame environment arguments share the same ephemeral ``Environment``\ninstance behind the scenes.\n\nA template object should be considered immutable. Modifications on\nthe object are not supported.",
          "functions": [
            {
              "name": "__new__",
              "doc": "Create and return a new object.  See help(type) for accurate signature.",
              "signature": "(cls, source: Union[str, jinja2.nodes.Template], block_start_string: str = '{%', block_end_string: str = '%}', variable_start_string: str = '{{', variable_end_string: str = '}}', comment_start_string: str = '{#', comment_end_string: str = '#}', line_statement_prefix: Optional[str] = None, line_comment_prefix: Optional[str] = None, trim_blocks: bool = False, lstrip_blocks: bool = False, newline_sequence: \"te.Literal['\\\\n', '\\\\r\\\\n', '\\\\r']\" = '\\n', keep_trailing_newline: bool = False, extensions: Sequence[Union[str, Type[ForwardRef('Extension')]]] = (), optimized: bool = True, undefined: Type[jinja2.runtime.Undefined] = <class 'jinja2.runtime.Undefined'>, finalize: Optional[Callable[..., Any]] = None, autoescape: Union[bool, Callable[[Optional[str]], bool]] = False, enable_async: bool = False) -> Any"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "_get_default_module",
              "doc": "If a context is passed in, this means that the template was\nimported. Imported templates have access to the current\ntemplate's globals by default, but they can only be accessed via\nthe context during runtime.\n\nIf there are new globals, we need to create a new module because\nthe cached module is already rendered and will not have access\nto globals from the current context. This new module is not\ncached because the template can be imported elsewhere, and it\nshould have access to only the current template's globals.",
              "signature": "(self, ctx: Optional[jinja2.runtime.Context] = None) -> 'TemplateModule'"
            },
            {
              "name": "_get_default_module_async",
              "doc": null,
              "signature": "(self, ctx: Optional[jinja2.runtime.Context] = None) -> 'TemplateModule'"
            },
            {
              "name": "generate",
              "doc": "For very large templates it can be useful to not render the whole\ntemplate at once but evaluate each statement after another and yield\npiece for piece.  This method basically does exactly that and returns\na generator that yields one item after another as strings.\n\nIt accepts the same arguments as :meth:`render`.",
              "signature": "(self, *args: Any, **kwargs: Any) -> Iterator[str]"
            },
            {
              "name": "generate_async",
              "doc": "An async version of :meth:`generate`.  Works very similarly but\nreturns an async iterator instead.",
              "signature": "(self, *args: Any, **kwargs: Any) -> AsyncGenerator[str, object]"
            },
            {
              "name": "get_corresponding_lineno",
              "doc": "Return the source line number of a line number in the\ngenerated bytecode as they are not in sync.",
              "signature": "(self, lineno: int) -> int"
            },
            {
              "name": "make_module",
              "doc": "This method works like the :attr:`module` attribute when called\nwithout arguments but it will evaluate the template on every call\nrather than caching it.  It's also possible to provide\na dict which is then used as context.  The arguments are the same\nas for the :meth:`new_context` method.",
              "signature": "(self, vars: Optional[Dict[str, Any]] = None, shared: bool = False, locals: Optional[Mapping[str, Any]] = None) -> 'TemplateModule'"
            },
            {
              "name": "make_module_async",
              "doc": "As template module creation can invoke template code for\nasynchronous executions this method must be used instead of the\nnormal :meth:`make_module` one.  Likewise the module attribute\nbecomes unavailable in async mode.",
              "signature": "(self, vars: Optional[Dict[str, Any]] = None, shared: bool = False, locals: Optional[Mapping[str, Any]] = None) -> 'TemplateModule'"
            },
            {
              "name": "new_context",
              "doc": "Create a new :class:`Context` for this template.  The vars\nprovided will be passed to the template.  Per default the globals\nare added to the context.  If shared is set to `True` the data\nis passed as is to the context without adding the globals.\n\n`locals` can be a dict of local variables for internal usage.",
              "signature": "(self, vars: Optional[Dict[str, Any]] = None, shared: bool = False, locals: Optional[Mapping[str, Any]] = None) -> jinja2.runtime.Context"
            },
            {
              "name": "render",
              "doc": "This method accepts the same arguments as the `dict` constructor:\nA dict, a dict subclass or some keyword arguments.  If no arguments\nare given the context will be empty.  These two calls do the same::\n\n    template.render(knights='that say nih')\n    template.render({'knights': 'that say nih'})\n\nThis will return the rendered template as a string.",
              "signature": "(self, *args: Any, **kwargs: Any) -> str"
            },
            {
              "name": "render_async",
              "doc": "This works similar to :meth:`render` but returns a coroutine\nthat when awaited returns the entire rendered template string.  This\nrequires the async feature to be enabled.\n\nExample usage::\n\n    await template.render_async(knights='that say nih; asynchronously')",
              "signature": "(self, *args: Any, **kwargs: Any) -> str"
            },
            {
              "name": "stream",
              "doc": "Works exactly like :meth:`generate` but returns a\n:class:`TemplateStream`.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'TemplateStream'"
            }
          ]
        },
        {
          "name": "TemplateAssertionError",
          "doc": "Like a template syntax error, but covers cases where something in the\ntemplate caused an error at compile time that wasn't necessarily caused\nby a syntax error.  However it's a direct subclass of\n:exc:`TemplateSyntaxError` and has the same attributes.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: str, lineno: int, name: Optional[str] = None, filename: Optional[str] = None) -> None"
            },
            {
              "name": "__reduce__",
              "doc": "Helper for pickle.",
              "signature": "(self)"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> str"
            }
          ]
        },
        {
          "name": "TemplateError",
          "doc": "Baseclass for all template errors.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: Optional[str] = None) -> None"
            }
          ]
        },
        {
          "name": "TemplateNotFound",
          "doc": "Raised if a template does not exist.\n\n.. versionchanged:: 2.11\n    If the given name is :class:`Undefined` and no message was\n    provided, an :exc:`UndefinedError` is raised.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, name: Union[str, ForwardRef('Undefined'), NoneType], message: Optional[str] = None) -> None"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> str"
            }
          ]
        },
        {
          "name": "TemplateRuntimeError",
          "doc": "A generic runtime error in the template engine.  Under some situations\nJinja may raise this exception.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: Optional[str] = None) -> None"
            }
          ]
        },
        {
          "name": "TemplateSyntaxError",
          "doc": "Raised to tell the user that there is a problem with the template.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: str, lineno: int, name: Optional[str] = None, filename: Optional[str] = None) -> None"
            },
            {
              "name": "__reduce__",
              "doc": "Helper for pickle.",
              "signature": "(self)"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> str"
            }
          ]
        },
        {
          "name": "TemplatesNotFound",
          "doc": "Like :class:`TemplateNotFound` but raised if multiple templates\nare selected.  This is a subclass of :class:`TemplateNotFound`\nexception, so just catching the base exception will catch both.\n\n.. versionchanged:: 2.11\n    If a name in the list of names is :class:`Undefined`, a message\n    about it being undefined is shown rather than the empty string.\n\n.. versionadded:: 2.2",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, names: Sequence[Union[str, ForwardRef('Undefined')]] = (), message: Optional[str] = None) -> None"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> str"
            }
          ]
        },
        {
          "name": "Undefined",
          "doc": "The default undefined type. This can be printed, iterated, and treated as\na boolean. Any other operation will raise an :exc:`UndefinedError`.\n\n>>> foo = Undefined(name='foo')\n>>> str(foo)\n''\n>>> not foo\nTrue\n>>> foo + 42\nTraceback (most recent call last):\n  ...\njinja2.exceptions.UndefinedError: 'foo' is undefined",
          "functions": [
            {
              "name": "__add__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__aiter__",
              "doc": null,
              "signature": "(self) -> AsyncIterator[Any]"
            },
            {
              "name": "__bool__",
              "doc": null,
              "signature": "(self) -> bool"
            },
            {
              "name": "__call__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__complex__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__div__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: Any) -> bool"
            },
            {
              "name": "__float__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__floordiv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__ge__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__getattr__",
              "doc": null,
              "signature": "(self, name: str) -> Any"
            },
            {
              "name": "__getitem__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__gt__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> int"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, hint: Optional[str] = None, obj: Any = missing, name: Optional[str] = None, exc: Type[jinja2.exceptions.TemplateRuntimeError] = <class 'jinja2.exceptions.UndefinedError'>) -> None"
            },
            {
              "name": "__int__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__iter__",
              "doc": null,
              "signature": "(self) -> Iterator[Any]"
            },
            {
              "name": "__le__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> int"
            },
            {
              "name": "__lt__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__mod__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__mul__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__ne__",
              "doc": "Return self!=value.",
              "signature": "(self, other: Any) -> bool"
            },
            {
              "name": "__neg__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__pos__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__pow__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__radd__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rdiv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "__rfloordiv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rmod__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rmul__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rpow__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rsub__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__rtruediv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "__sub__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "__truediv__",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            },
            {
              "name": "_fail_with_undefined_error",
              "doc": "Raise an :exc:`UndefinedError` when operations are performed\non the undefined value.",
              "signature": "(self, *args: Any, **kwargs: Any) -> 'te.NoReturn'"
            }
          ]
        },
        {
          "name": "UndefinedError",
          "doc": "Raised if a template tries to operate on :class:`Undefined`.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: Optional[str] = None) -> None"
            }
          ]
        }
      ]
    }
  },
  {
    "package": "pydantic_core",
    "base": {
      "functions": [],
      "classes": [
        {
          "name": "ArgsKwargs",
          "doc": "",
          "functions": []
        },
        {
          "name": "CoreConfig",
          "doc": "Base class for schema configuration options.\n\nAttributes:\n    title: The name of the configuration.\n    strict: Whether the configuration should strictly adhere to specified rules.\n    extra_fields_behavior: The behavior for handling extra fields.\n    typed_dict_total: Whether the TypedDict should be considered total. Default is `True`.\n    from_attributes: Whether to use attributes for models, dataclasses, and tagged union keys.\n    loc_by_alias: Whether to use the used alias (or first alias for \"field required\" errors) instead of\n        `field_names` to construct error `loc`s. Default is `True`.\n    revalidate_instances: Whether instances of models and dataclasses should re-validate. Default is 'never'.\n    validate_default: Whether to validate default values during validation. Default is `False`.\n    str_max_length: The maximum length for string fields.\n    str_min_length: The minimum length for string fields.\n    str_strip_whitespace: Whether to strip whitespace from string fields.\n    str_to_lower: Whether to convert string fields to lowercase.\n    str_to_upper: Whether to convert string fields to uppercase.\n    allow_inf_nan: Whether to allow infinity and NaN values for float fields. Default is `True`.\n    ser_json_timedelta: The serialization option for `timedelta` values. Default is 'iso8601'.\n    ser_json_bytes: The serialization option for `bytes` values. Default is 'utf8'.\n    ser_json_inf_nan: The serialization option for infinity and NaN values\n        in float fields. Default is 'null'.\n    val_json_bytes: The validation option for `bytes` values, complementing ser_json_bytes. Default is 'utf8'.\n    hide_input_in_errors: Whether to hide input data from `ValidationError` representation.\n    validation_error_cause: Whether to add user-python excs to the __cause__ of a ValidationError.\n        Requires exceptiongroup backport pre Python 3.11.\n    coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).\n    regex_engine: The regex engine to use for regex pattern validation. Default is 'rust-regex'. See `StringSchema`.\n    cache_strings: Whether to cache strings. Default is `True`, `True` or `'all'` is required to cache strings\n        during general validation since validators don't know if they're in a key or a value.\n    validate_by_alias: Whether to use the field's alias when validating against the provided input data. Default is `True`.\n    validate_by_name: Whether to use the field's name when validating against the provided input data. Default is `False`. Replacement for `populate_by_name`.\n    serialize_by_alias: Whether to serialize by alias. Default is `False`, expected to change to `True` in V3.",
          "functions": []
        },
        {
          "name": "ErrorDetails",
          "doc": "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
          "functions": []
        },
        {
          "name": "ErrorTypeInfo",
          "doc": "Gives information about errors.",
          "functions": []
        },
        {
          "name": "InitErrorDetails",
          "doc": "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
          "functions": []
        },
        {
          "name": "MultiHostHost",
          "doc": "A host part of a multi-host URL.",
          "functions": []
        },
        {
          "name": "MultiHostUrl",
          "doc": "",
          "functions": []
        },
        {
          "name": "PydanticCustomError",
          "doc": "",
          "functions": []
        },
        {
          "name": "PydanticKnownError",
          "doc": "",
          "functions": []
        },
        {
          "name": "PydanticOmit",
          "doc": "",
          "functions": []
        },
        {
          "name": "PydanticSerializationError",
          "doc": "",
          "functions": []
        },
        {
          "name": "PydanticSerializationUnexpectedValue",
          "doc": "",
          "functions": []
        },
        {
          "name": "PydanticUndefinedType",
          "doc": "",
          "functions": []
        },
        {
          "name": "PydanticUseDefault",
          "doc": "",
          "functions": []
        },
        {
          "name": "SchemaError",
          "doc": "",
          "functions": []
        },
        {
          "name": "SchemaSerializer",
          "doc": "",
          "functions": []
        },
        {
          "name": "SchemaValidator",
          "doc": "",
          "functions": []
        },
        {
          "name": "Some",
          "doc": "",
          "functions": []
        },
        {
          "name": "TzInfo",
          "doc": "",
          "functions": []
        },
        {
          "name": "Url",
          "doc": "",
          "functions": []
        },
        {
          "name": "ValidationError",
          "doc": "",
          "functions": []
        },
        {
          "name": "Any",
          "doc": "Special type indicating an unconstrained type.\n\n- Any is compatible with every type.\n- Any assumed to have all methods.\n- All values assumed to be instances of Any.\n\nNote that all the above statements are true from the point of view of\nstatic type checkers. At runtime, Any should not be used with instance\nchecks.",
          "functions": []
        }
      ]
    }
  },
  {
    "package": "pydantic",
    "base": {
      "functions": [
        {
          "name": "Field",
          "doc": "!!! abstract \"Usage Documentation\"\n    [Fields](../concepts/fields.md)\n\nCreate a field for objects that can be configured.\n\nUsed to provide extra information about a field, either for the model schema or complex validation. Some arguments\napply only to number fields (`int`, `float`, `Decimal`) and some apply only to `str`.\n\nNote:\n    - Any `_Unset` objects will be replaced by the corresponding value defined in the `_DefaultValues` dictionary. If a key for the `_Unset` object is not found in the `_DefaultValues` dictionary, it will default to `None`\n\nArgs:\n    default: Default value if the field is not set.\n    default_factory: A callable to generate the default value. The callable can either take 0 arguments\n        (in which case it is called as is) or a single argument containing the already validated data.\n    alias: The name to use for the attribute when validating or serializing by alias.\n        This is often used for things like converting between snake and camel case.\n    alias_priority: Priority of the alias. This affects whether an alias generator is used.\n    validation_alias: Like `alias`, but only affects validation, not serialization.\n    serialization_alias: Like `alias`, but only affects serialization, not validation.\n    title: Human-readable title.\n    field_title_generator: A callable that takes a field name and returns title for it.\n    description: Human-readable description.\n    examples: Example values for this field.\n    exclude: Whether to exclude the field from the model serialization.\n    discriminator: Field name or Discriminator for discriminating the type in a tagged union.\n    deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport,\n        or a boolean. If `True`, a default deprecation message will be emitted when accessing the field.\n    json_schema_extra: A dict or callable to provide extra JSON schema properties.\n    frozen: Whether the field is frozen. If true, attempts to change the value on an instance will raise an error.\n    validate_default: If `True`, apply validation to the default value every time you create an instance.\n        Otherwise, for performance reasons, the default value of the field is trusted and not validated.\n    repr: A boolean indicating whether to include the field in the `__repr__` output.\n    init: Whether the field should be included in the constructor of the dataclass.\n        (Only applies to dataclasses.)\n    init_var: Whether the field should _only_ be included in the constructor of the dataclass.\n        (Only applies to dataclasses.)\n    kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.\n        (Only applies to dataclasses.)\n    coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).\n    strict: If `True`, strict validation is applied to the field.\n        See [Strict Mode](../concepts/strict_mode.md) for details.\n    gt: Greater than. If set, value must be greater than this. Only applicable to numbers.\n    ge: Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.\n    lt: Less than. If set, value must be less than this. Only applicable to numbers.\n    le: Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.\n    multiple_of: Value must be a multiple of this. Only applicable to numbers.\n    min_length: Minimum length for iterables.\n    max_length: Maximum length for iterables.\n    pattern: Pattern for strings (a regular expression).\n    allow_inf_nan: Allow `inf`, `-inf`, `nan`. Only applicable to float and [`Decimal`][decimal.Decimal] numbers.\n    max_digits: Maximum number of allow digits for strings.\n    decimal_places: Maximum number of decimal places allowed for numbers.\n    union_mode: The strategy to apply when validating a union. Can be `smart` (the default), or `left_to_right`.\n        See [Union Mode](../concepts/unions.md#union-modes) for details.\n    fail_fast: If `True`, validation will stop on the first error. If `False`, all validation errors will be collected.\n        This option can be applied only to iterable types (list, tuple, set, and frozenset).\n    extra: (Deprecated) Extra fields that will be included in the JSON schema.\n\n        !!! warning Deprecated\n            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\n\nReturns:\n    A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is `Any` so `Field` can be used on\n        type-annotated fields without causing a type error.",
          "signature": "(default: 'Any' = PydanticUndefined, *, default_factory: 'Callable[[], Any] | Callable[[dict[str, Any]], Any] | None' = PydanticUndefined, alias: 'str | None' = PydanticUndefined, alias_priority: 'int | None' = PydanticUndefined, validation_alias: 'str | AliasPath | AliasChoices | None' = PydanticUndefined, serialization_alias: 'str | None' = PydanticUndefined, title: 'str | None' = PydanticUndefined, field_title_generator: 'Callable[[str, FieldInfo], str] | None' = PydanticUndefined, description: 'str | None' = PydanticUndefined, examples: 'list[Any] | None' = PydanticUndefined, exclude: 'bool | None' = PydanticUndefined, discriminator: 'str | types.Discriminator | None' = PydanticUndefined, deprecated: 'Deprecated | str | bool | None' = PydanticUndefined, json_schema_extra: 'JsonDict | Callable[[JsonDict], None] | None' = PydanticUndefined, frozen: 'bool | None' = PydanticUndefined, validate_default: 'bool | None' = PydanticUndefined, repr: 'bool' = PydanticUndefined, init: 'bool | None' = PydanticUndefined, init_var: 'bool | None' = PydanticUndefined, kw_only: 'bool | None' = PydanticUndefined, pattern: 'str | typing.Pattern[str] | None' = PydanticUndefined, strict: 'bool | None' = PydanticUndefined, coerce_numbers_to_str: 'bool | None' = PydanticUndefined, gt: 'annotated_types.SupportsGt | None' = PydanticUndefined, ge: 'annotated_types.SupportsGe | None' = PydanticUndefined, lt: 'annotated_types.SupportsLt | None' = PydanticUndefined, le: 'annotated_types.SupportsLe | None' = PydanticUndefined, multiple_of: 'float | None' = PydanticUndefined, allow_inf_nan: 'bool | None' = PydanticUndefined, max_digits: 'int | None' = PydanticUndefined, decimal_places: 'int | None' = PydanticUndefined, min_length: 'int | None' = PydanticUndefined, max_length: 'int | None' = PydanticUndefined, union_mode: \"Literal['smart', 'left_to_right']\" = PydanticUndefined, fail_fast: 'bool | None' = PydanticUndefined, **extra: 'Unpack[_EmptyKwargs]') -> 'Any'"
        },
        {
          "name": "PrivateAttr",
          "doc": "!!! abstract \"Usage Documentation\"\n    [Private Model Attributes](../concepts/models.md#private-model-attributes)\n\nIndicates that an attribute is intended for private use and not handled during normal validation/serialization.\n\nPrivate attributes are not validated by Pydantic, so it's up to you to ensure they are used in a type-safe manner.\n\nPrivate attributes are stored in `__private_attributes__` on the model.\n\nArgs:\n    default: The attribute's default value. Defaults to Undefined.\n    default_factory: Callable that will be\n        called when a default value is needed for this attribute.\n        If both `default` and `default_factory` are set, an error will be raised.\n    init: Whether the attribute should be included in the constructor of the dataclass. Always `False`.\n\nReturns:\n    An instance of [`ModelPrivateAttr`][pydantic.fields.ModelPrivateAttr] class.\n\nRaises:\n    ValueError: If both `default` and `default_factory` are set.",
          "signature": "(default: 'Any' = PydanticUndefined, *, default_factory: 'Callable[[], Any] | None' = None, init: 'Literal[False]' = False) -> 'Any'"
        },
        {
          "name": "computed_field",
          "doc": "!!! abstract \"Usage Documentation\"\n    [The `computed_field` decorator](../concepts/fields.md#the-computed_field-decorator)\n\nDecorator to include `property` and `cached_property` when serializing models or dataclasses.\n\nThis is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached.\n\n```python\nfrom pydantic import BaseModel, computed_field\n\nclass Rectangle(BaseModel):\n    width: int\n    length: int\n\n    @computed_field\n    @property\n    def area(self) -> int:\n        return self.width * self.length\n\nprint(Rectangle(width=3, length=2).model_dump())\n#> {'width': 3, 'length': 2, 'area': 6}\n```\n\nIf applied to functions not yet decorated with `@property` or `@cached_property`, the function is\nautomatically wrapped with `property`. Although this is more concise, you will lose IntelliSense in your IDE,\nand confuse static type checkers, thus explicit use of `@property` is recommended.\n\n!!! warning \"Mypy Warning\"\n    Even with the `@property` or `@cached_property` applied to your function before `@computed_field`,\n    mypy may throw a `Decorated property not supported` error.\n    See [mypy issue #1362](https://github.com/python/mypy/issues/1362), for more information.\n    To avoid this error message, add `# type: ignore[prop-decorator]` to the `@computed_field` line.\n\n    [pyright](https://github.com/microsoft/pyright) supports `@computed_field` without error.\n\n```python\nimport random\n\nfrom pydantic import BaseModel, computed_field\n\nclass Square(BaseModel):\n    width: float\n\n    @computed_field\n    def area(self) -> float:  # converted to a `property` by `computed_field`\n        return round(self.width**2, 2)\n\n    @area.setter\n    def area(self, new_area: float) -> None:\n        self.width = new_area**0.5\n\n    @computed_field(alias='the magic number', repr=False)\n    def random_number(self) -> int:\n        return random.randint(0, 1_000)\n\nsquare = Square(width=1.3)\n\n# `random_number` does not appear in representation\nprint(repr(square))\n#> Square(width=1.3, area=1.69)\n\nprint(square.random_number)\n#> 3\n\nsquare.area = 4\n\nprint(square.model_dump_json(by_alias=True))\n#> {\"width\":2.0,\"area\":4.0,\"the magic number\":3}\n```\n\n!!! warning \"Overriding with `computed_field`\"\n    You can't override a field from a parent class with a `computed_field` in the child class.\n    `mypy` complains about this behavior if allowed, and `dataclasses` doesn't allow this pattern either.\n    See the example below:\n\n```python\nfrom pydantic import BaseModel, computed_field\n\nclass Parent(BaseModel):\n    a: str\n\ntry:\n\n    class Child(Parent):\n        @computed_field\n        @property\n        def a(self) -> str:\n            return 'new a'\n\nexcept TypeError as e:\n    print(e)\n    '''\n    Field 'a' of class 'Child' overrides symbol of same name in a parent class. This override with a computed_field is incompatible.\n    '''\n```\n\nPrivate properties decorated with `@computed_field` have `repr=False` by default.\n\n```python\nfrom functools import cached_property\n\nfrom pydantic import BaseModel, computed_field\n\nclass Model(BaseModel):\n    foo: int\n\n    @computed_field\n    @cached_property\n    def _private_cached_property(self) -> int:\n        return -self.foo\n\n    @computed_field\n    @property\n    def _private_property(self) -> int:\n        return -self.foo\n\nm = Model(foo=1)\nprint(repr(m))\n#> Model(foo=1)\n```\n\nArgs:\n    func: the function to wrap.\n    alias: alias to use when serializing this computed field, only used when `by_alias=True`\n    alias_priority: priority of the alias. This affects whether an alias generator is used\n    title: Title to use when including this computed field in JSON Schema\n    field_title_generator: A callable that takes a field name and returns title for it.\n    description: Description to use when including this computed field in JSON Schema, defaults to the function's\n        docstring\n    deprecated: A deprecation message (or an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport).\n        to be emitted when accessing the field. Or a boolean. This will automatically be set if the property is decorated with the\n        `deprecated` decorator.\n    examples: Example values to use when including this computed field in JSON Schema\n    json_schema_extra: A dict or callable to provide extra JSON schema properties.\n    repr: whether to include this computed field in model repr.\n        Default is `False` for private properties and `True` for public properties.\n    return_type: optional return for serialization logic to expect when serializing to JSON, if included\n        this must be correct, otherwise a `TypeError` is raised.\n        If you don't include a return type Any is used, which does runtime introspection to handle arbitrary\n        objects.\n\nReturns:\n    A proxy wrapper for the property.",
          "signature": "(func: 'PropertyT | None' = None, /, *, alias: 'str | None' = None, alias_priority: 'int | None' = None, title: 'str | None' = None, field_title_generator: 'typing.Callable[[str, ComputedFieldInfo], str] | None' = None, description: 'str | None' = None, deprecated: 'Deprecated | str | bool | None' = None, examples: 'list[Any] | None' = None, json_schema_extra: 'JsonDict | typing.Callable[[JsonDict], None] | None' = None, repr: 'bool | None' = None, return_type: 'Any' = PydanticUndefined) -> 'PropertyT | typing.Callable[[PropertyT], PropertyT]'"
        },
        {
          "name": "conbytes",
          "doc": "A wrapper around `bytes` that allows for additional constraints.\n\nArgs:\n    min_length: The minimum length of the bytes.\n    max_length: The maximum length of the bytes.\n    strict: Whether to validate the bytes in strict mode.\n\nReturns:\n    The wrapped bytes type.",
          "signature": "(*, min_length: 'int | None' = None, max_length: 'int | None' = None, strict: 'bool | None' = None) -> 'type[bytes]'"
        },
        {
          "name": "condate",
          "doc": "A wrapper for date that adds constraints.\n\nArgs:\n    strict: Whether to validate the date value in strict mode. Defaults to `None`.\n    gt: The value must be greater than this. Defaults to `None`.\n    ge: The value must be greater than or equal to this. Defaults to `None`.\n    lt: The value must be less than this. Defaults to `None`.\n    le: The value must be less than or equal to this. Defaults to `None`.\n\nReturns:\n    A date type with the specified constraints.",
          "signature": "(*, strict: 'bool | None' = None, gt: 'date | None' = None, ge: 'date | None' = None, lt: 'date | None' = None, le: 'date | None' = None) -> 'type[date]'"
        },
        {
          "name": "condecimal",
          "doc": "!!! warning \"Discouraged\"\n    This function is **discouraged** in favor of using\n    [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n    [`Field`][pydantic.fields.Field] instead.\n\n    This function will be **deprecated** in Pydantic 3.0.\n\n    The reason is that `condecimal` returns a type, which doesn't play well with static analysis tools.\n\n    === \":x: Don't do this\"\n        ```python\n        from pydantic import BaseModel, condecimal\n\n        class Foo(BaseModel):\n            bar: condecimal(strict=True, allow_inf_nan=True)\n        ```\n\n    === \":white_check_mark: Do this\"\n        ```python\n        from decimal import Decimal\n        from typing import Annotated\n\n        from pydantic import BaseModel, Field\n\n        class Foo(BaseModel):\n            bar: Annotated[Decimal, Field(strict=True, allow_inf_nan=True)]\n        ```\n\nA wrapper around Decimal that adds validation.\n\nArgs:\n    strict: Whether to validate the value in strict mode. Defaults to `None`.\n    gt: The value must be greater than this. Defaults to `None`.\n    ge: The value must be greater than or equal to this. Defaults to `None`.\n    lt: The value must be less than this. Defaults to `None`.\n    le: The value must be less than or equal to this. Defaults to `None`.\n    multiple_of: The value must be a multiple of this. Defaults to `None`.\n    max_digits: The maximum number of digits. Defaults to `None`.\n    decimal_places: The number of decimal places. Defaults to `None`.\n    allow_inf_nan: Whether to allow infinity and NaN. Defaults to `None`.\n\n```python\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, ValidationError, condecimal\n\nclass ConstrainedExample(BaseModel):\n    constrained_decimal: condecimal(gt=Decimal('1.0'))\n\nm = ConstrainedExample(constrained_decimal=Decimal('1.1'))\nprint(repr(m))\n#> ConstrainedExample(constrained_decimal=Decimal('1.1'))\n\ntry:\n    ConstrainedExample(constrained_decimal=Decimal('0.9'))\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('constrained_decimal',),\n            'msg': 'Input should be greater than 1.0',\n            'input': Decimal('0.9'),\n            'ctx': {'gt': Decimal('1.0')},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```",
          "signature": "(*, strict: 'bool | None' = None, gt: 'int | Decimal | None' = None, ge: 'int | Decimal | None' = None, lt: 'int | Decimal | None' = None, le: 'int | Decimal | None' = None, multiple_of: 'int | Decimal | None' = None, max_digits: 'int | None' = None, decimal_places: 'int | None' = None, allow_inf_nan: 'bool | None' = None) -> 'type[Decimal]'"
        },
        {
          "name": "confloat",
          "doc": "!!! warning \"Discouraged\"\n    This function is **discouraged** in favor of using\n    [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n    [`Field`][pydantic.fields.Field] instead.\n\n    This function will be **deprecated** in Pydantic 3.0.\n\n    The reason is that `confloat` returns a type, which doesn't play well with static analysis tools.\n\n    === \":x: Don't do this\"\n        ```python\n        from pydantic import BaseModel, confloat\n\n        class Foo(BaseModel):\n            bar: confloat(strict=True, gt=0)\n        ```\n\n    === \":white_check_mark: Do this\"\n        ```python\n        from typing import Annotated\n\n        from pydantic import BaseModel, Field\n\n        class Foo(BaseModel):\n            bar: Annotated[float, Field(strict=True, gt=0)]\n        ```\n\nA wrapper around `float` that allows for additional constraints.\n\nArgs:\n    strict: Whether to validate the float in strict mode.\n    gt: The value must be greater than this.\n    ge: The value must be greater than or equal to this.\n    lt: The value must be less than this.\n    le: The value must be less than or equal to this.\n    multiple_of: The value must be a multiple of this.\n    allow_inf_nan: Whether to allow `-inf`, `inf`, and `nan`.\n\nReturns:\n    The wrapped float type.\n\n```python\nfrom pydantic import BaseModel, ValidationError, confloat\n\nclass ConstrainedExample(BaseModel):\n    constrained_float: confloat(gt=1.0)\n\nm = ConstrainedExample(constrained_float=1.1)\nprint(repr(m))\n#> ConstrainedExample(constrained_float=1.1)\n\ntry:\n    ConstrainedExample(constrained_float=0.9)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('constrained_float',),\n            'msg': 'Input should be greater than 1',\n            'input': 0.9,\n            'ctx': {'gt': 1.0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```",
          "signature": "(*, strict: 'bool | None' = None, gt: 'float | None' = None, ge: 'float | None' = None, lt: 'float | None' = None, le: 'float | None' = None, multiple_of: 'float | None' = None, allow_inf_nan: 'bool | None' = None) -> 'type[float]'"
        },
        {
          "name": "confrozenset",
          "doc": "A wrapper around `typing.FrozenSet` that allows for additional constraints.\n\nArgs:\n    item_type: The type of the items in the frozenset.\n    min_length: The minimum length of the frozenset.\n    max_length: The maximum length of the frozenset.\n\nReturns:\n    The wrapped frozenset type.",
          "signature": "(item_type: 'type[HashableItemType]', *, min_length: 'int | None' = None, max_length: 'int | None' = None) -> 'type[frozenset[HashableItemType]]'"
        },
        {
          "name": "conint",
          "doc": "!!! warning \"Discouraged\"\n    This function is **discouraged** in favor of using\n    [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n    [`Field`][pydantic.fields.Field] instead.\n\n    This function will be **deprecated** in Pydantic 3.0.\n\n    The reason is that `conint` returns a type, which doesn't play well with static analysis tools.\n\n    === \":x: Don't do this\"\n        ```python\n        from pydantic import BaseModel, conint\n\n        class Foo(BaseModel):\n            bar: conint(strict=True, gt=0)\n        ```\n\n    === \":white_check_mark: Do this\"\n        ```python\n        from typing import Annotated\n\n        from pydantic import BaseModel, Field\n\n        class Foo(BaseModel):\n            bar: Annotated[int, Field(strict=True, gt=0)]\n        ```\n\nA wrapper around `int` that allows for additional constraints.\n\nArgs:\n    strict: Whether to validate the integer in strict mode. Defaults to `None`.\n    gt: The value must be greater than this.\n    ge: The value must be greater than or equal to this.\n    lt: The value must be less than this.\n    le: The value must be less than or equal to this.\n    multiple_of: The value must be a multiple of this.\n\nReturns:\n    The wrapped integer type.\n\n```python\nfrom pydantic import BaseModel, ValidationError, conint\n\nclass ConstrainedExample(BaseModel):\n    constrained_int: conint(gt=1)\n\nm = ConstrainedExample(constrained_int=2)\nprint(repr(m))\n#> ConstrainedExample(constrained_int=2)\n\ntry:\n    ConstrainedExample(constrained_int=0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('constrained_int',),\n            'msg': 'Input should be greater than 1',\n            'input': 0,\n            'ctx': {'gt': 1},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```",
          "signature": "(*, strict: 'bool | None' = None, gt: 'int | None' = None, ge: 'int | None' = None, lt: 'int | None' = None, le: 'int | None' = None, multiple_of: 'int | None' = None) -> 'type[int]'"
        },
        {
          "name": "conlist",
          "doc": "A wrapper around [`list`][] that adds validation.\n\nArgs:\n    item_type: The type of the items in the list.\n    min_length: The minimum length of the list. Defaults to None.\n    max_length: The maximum length of the list. Defaults to None.\n    unique_items: Whether the items in the list must be unique. Defaults to None.\n        !!! warning Deprecated\n            The `unique_items` parameter is deprecated, use `Set` instead.\n            See [this issue](https://github.com/pydantic/pydantic-core/issues/296) for more details.\n\nReturns:\n    The wrapped list type.",
          "signature": "(item_type: 'type[AnyItemType]', *, min_length: 'int | None' = None, max_length: 'int | None' = None, unique_items: 'bool | None' = None) -> 'type[list[AnyItemType]]'"
        },
        {
          "name": "conset",
          "doc": "A wrapper around `typing.Set` that allows for additional constraints.\n\nArgs:\n    item_type: The type of the items in the set.\n    min_length: The minimum length of the set.\n    max_length: The maximum length of the set.\n\nReturns:\n    The wrapped set type.",
          "signature": "(item_type: 'type[HashableItemType]', *, min_length: 'int | None' = None, max_length: 'int | None' = None) -> 'type[set[HashableItemType]]'"
        },
        {
          "name": "constr",
          "doc": "!!! warning \"Discouraged\"\n    This function is **discouraged** in favor of using\n    [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n    [`StringConstraints`][pydantic.types.StringConstraints] instead.\n\n    This function will be **deprecated** in Pydantic 3.0.\n\n    The reason is that `constr` returns a type, which doesn't play well with static analysis tools.\n\n    === \":x: Don't do this\"\n        ```python\n        from pydantic import BaseModel, constr\n\n        class Foo(BaseModel):\n            bar: constr(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')\n        ```\n\n    === \":white_check_mark: Do this\"\n        ```python\n        from typing import Annotated\n\n        from pydantic import BaseModel, StringConstraints\n\n        class Foo(BaseModel):\n            bar: Annotated[\n                str,\n                StringConstraints(\n                    strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$'\n                ),\n            ]\n        ```\n\nA wrapper around `str` that allows for additional constraints.\n\n```python\nfrom pydantic import BaseModel, constr\n\nclass Foo(BaseModel):\n    bar: constr(strip_whitespace=True, to_upper=True)\n\nfoo = Foo(bar='  hello  ')\nprint(foo)\n#> bar='HELLO'\n```\n\nArgs:\n    strip_whitespace: Whether to remove leading and trailing whitespace.\n    to_upper: Whether to turn all characters to uppercase.\n    to_lower: Whether to turn all characters to lowercase.\n    strict: Whether to validate the string in strict mode.\n    min_length: The minimum length of the string.\n    max_length: The maximum length of the string.\n    pattern: A regex pattern to validate the string against.\n\nReturns:\n    The wrapped string type.",
          "signature": "(*, strip_whitespace: 'bool | None' = None, to_upper: 'bool | None' = None, to_lower: 'bool | None' = None, strict: 'bool | None' = None, min_length: 'int | None' = None, max_length: 'int | None' = None, pattern: 'str | Pattern[str] | None' = None) -> 'type[str]'"
        },
        {
          "name": "create_model",
          "doc": "!!! abstract \"Usage Documentation\"\n    [Dynamic Model Creation](../concepts/models.md#dynamic-model-creation)\n\nDynamically creates and returns a new Pydantic model, in other words, `create_model` dynamically creates a\nsubclass of [`BaseModel`][pydantic.BaseModel].\n\nArgs:\n    model_name: The name of the newly created model.\n    __config__: The configuration of the new model.\n    __doc__: The docstring of the new model.\n    __base__: The base class or classes for the new model.\n    __module__: The name of the module that the model belongs to;\n        if `None`, the value is taken from `sys._getframe(1)`\n    __validators__: A dictionary of methods that validate fields. The keys are the names of the validation methods to\n        be added to the model, and the values are the validation methods themselves. You can read more about functional\n        validators [here](https://docs.pydantic.dev/2.9/concepts/validators/#field-validators).\n    __cls_kwargs__: A dictionary of keyword arguments for class creation, such as `metaclass`.\n    **field_definitions: Field definitions of the new model. Either:\n\n        - a single element, representing the type annotation of the field.\n        - a two-tuple, the first element being the type and the second element the assigned value\n          (either a default or the [`Field()`][pydantic.Field] function).\n\nReturns:\n    The new [model][pydantic.BaseModel].\n\nRaises:\n    PydanticUserError: If `__base__` and `__config__` are both passed.",
          "signature": "(model_name: 'str', /, *, __config__: 'ConfigDict | None' = None, __doc__: 'str | None' = None, __base__: 'type[ModelT] | tuple[type[ModelT], ...] | None' = None, __module__: 'str | None' = None, __validators__: 'dict[str, Callable[..., Any]] | None' = None, __cls_kwargs__: 'dict[str, Any] | None' = None, **field_definitions: 'Any | tuple[str, Any]') -> 'type[ModelT]'"
        },
        {
          "name": "field_serializer",
          "doc": "Decorator that enables custom field serialization.\n\nIn the below example, a field of type `set` is used to mitigate duplication. A `field_serializer` is used to serialize the data as a sorted list.\n\n```python\nfrom typing import Set\n\nfrom pydantic import BaseModel, field_serializer\n\nclass StudentModel(BaseModel):\n    name: str = 'Jane'\n    courses: Set[str]\n\n    @field_serializer('courses', when_used='json')\n    def serialize_courses_in_order(self, courses: Set[str]):\n        return sorted(courses)\n\nstudent = StudentModel(courses={'Math', 'Chemistry', 'English'})\nprint(student.model_dump_json())\n#> {\"name\":\"Jane\",\"courses\":[\"Chemistry\",\"English\",\"Math\"]}\n```\n\nSee [Custom serializers](../concepts/serialization.md#custom-serializers) for more information.\n\nFour signatures are supported:\n\n- `(self, value: Any, info: FieldSerializationInfo)`\n- `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)`\n- `(value: Any, info: SerializationInfo)`\n- `(value: Any, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`\n\nArgs:\n    fields: Which field(s) the method should be called on.\n    mode: The serialization mode.\n\n        - `plain` means the function will be called instead of the default serialization logic,\n        - `wrap` means the function will be called with an argument to optionally call the\n           default serialization logic.\n    return_type: Optional return type for the function, if omitted it will be inferred from the type annotation.\n    when_used: Determines the serializer will be used for serialization.\n    check_fields: Whether to check that the fields actually exist on the model.\n\nReturns:\n    The decorator function.",
          "signature": "(*fields: 'str', mode: \"Literal['plain', 'wrap']\" = 'plain', return_type: 'Any' = PydanticUndefined, when_used: 'WhenUsed' = 'always', check_fields: 'bool | None' = None) -> 'Callable[[_FieldWrapSerializerT], _FieldWrapSerializerT] | Callable[[_FieldPlainSerializerT], _FieldPlainSerializerT]'"
        },
        {
          "name": "field_validator",
          "doc": "!!! abstract \"Usage Documentation\"\n    [field validators](../concepts/validators.md#field-validators)\n\nDecorate methods on the class indicating that they should be used to validate fields.\n\nExample usage:\n```python\nfrom typing import Any\n\nfrom pydantic import (\n    BaseModel,\n    ValidationError,\n    field_validator,\n)\n\nclass Model(BaseModel):\n    a: str\n\n    @field_validator('a')\n    @classmethod\n    def ensure_foobar(cls, v: Any):\n        if 'foobar' not in v:\n            raise ValueError('\"foobar\" not found in a')\n        return v\n\nprint(repr(Model(a='this is foobar good')))\n#> Model(a='this is foobar good')\n\ntry:\n    Model(a='snap')\nexcept ValidationError as exc_info:\n    print(exc_info)\n    '''\n    1 validation error for Model\n    a\n      Value error, \"foobar\" not found in a [type=value_error, input_value='snap', input_type=str]\n    '''\n```\n\nFor more in depth examples, see [Field Validators](../concepts/validators.md#field-validators).\n\nArgs:\n    field: The first field the `field_validator` should be called on; this is separate\n        from `fields` to ensure an error is raised if you don't pass at least one.\n    *fields: Additional field(s) the `field_validator` should be called on.\n    mode: Specifies whether to validate the fields before or after validation.\n    check_fields: Whether to check that the fields actually exist on the model.\n    json_schema_input_type: The input type of the function. This is only used to generate\n        the appropriate JSON Schema (in validation mode) and can only specified\n        when `mode` is either `'before'`, `'plain'` or `'wrap'`.\n\nReturns:\n    A decorator that can be used to decorate a function to be used as a field_validator.\n\nRaises:\n    PydanticUserError:\n        - If `@field_validator` is used bare (with no fields).\n        - If the args passed to `@field_validator` as fields are not strings.\n        - If `@field_validator` applied to instance methods.",
          "signature": "(field: 'str', /, *fields: 'str', mode: 'FieldValidatorModes' = 'after', check_fields: 'bool | None' = None, json_schema_input_type: 'Any' = PydanticUndefined) -> 'Callable[[Any], Any]'"
        },
        {
          "name": "model_serializer",
          "doc": "Decorator that enables custom model serialization.\n\nThis is useful when a model need to be serialized in a customized manner, allowing for flexibility beyond just specific fields.\n\nAn example would be to serialize temperature to the same temperature scale, such as degrees Celsius.\n\n```python\nfrom typing import Literal\n\nfrom pydantic import BaseModel, model_serializer\n\nclass TemperatureModel(BaseModel):\n    unit: Literal['C', 'F']\n    value: int\n\n    @model_serializer()\n    def serialize_model(self):\n        if self.unit == 'F':\n            return {'unit': 'C', 'value': int((self.value - 32) / 1.8)}\n        return {'unit': self.unit, 'value': self.value}\n\ntemperature = TemperatureModel(unit='F', value=212)\nprint(temperature.model_dump())\n#> {'unit': 'C', 'value': 100}\n```\n\nTwo signatures are supported for `mode='plain'`, which is the default:\n\n- `(self)`\n- `(self, info: SerializationInfo)`\n\nAnd two other signatures for `mode='wrap'`:\n\n- `(self, nxt: SerializerFunctionWrapHandler)`\n- `(self, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`\n\n    See [Custom serializers](../concepts/serialization.md#custom-serializers) for more information.\n\nArgs:\n    f: The function to be decorated.\n    mode: The serialization mode.\n\n        - `'plain'` means the function will be called instead of the default serialization logic\n        - `'wrap'` means the function will be called with an argument to optionally call the default\n            serialization logic.\n    when_used: Determines when this serializer should be used.\n    return_type: The return type for the function. If omitted it will be inferred from the type annotation.\n\nReturns:\n    The decorator function.",
          "signature": "(f: '_ModelPlainSerializerT | _ModelWrapSerializerT | None' = None, /, *, mode: \"Literal['plain', 'wrap']\" = 'plain', when_used: 'WhenUsed' = 'always', return_type: 'Any' = PydanticUndefined) -> '_ModelPlainSerializerT | Callable[[_ModelWrapSerializerT], _ModelWrapSerializerT] | Callable[[_ModelPlainSerializerT], _ModelPlainSerializerT]'"
        },
        {
          "name": "model_validator",
          "doc": "!!! abstract \"Usage Documentation\"\n    [Model Validators](../concepts/validators.md#model-validators)\n\nDecorate model methods for validation purposes.\n\nExample usage:\n```python\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, ValidationError, model_validator\n\nclass Square(BaseModel):\n    width: float\n    height: float\n\n    @model_validator(mode='after')\n    def verify_square(self) -> Self:\n        if self.width != self.height:\n            raise ValueError('width and height do not match')\n        return self\n\ns = Square(width=1, height=1)\nprint(repr(s))\n#> Square(width=1.0, height=1.0)\n\ntry:\n    Square(width=1, height=2)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Square\n      Value error, width and height do not match [type=value_error, input_value={'width': 1, 'height': 2}, input_type=dict]\n    '''\n```\n\nFor more in depth examples, see [Model Validators](../concepts/validators.md#model-validators).\n\nArgs:\n    mode: A required string literal that specifies the validation mode.\n        It can be one of the following: 'wrap', 'before', or 'after'.\n\nReturns:\n    A decorator that can be used to decorate a function to be used as a model validator.",
          "signature": "(*, mode: \"Literal['wrap', 'before', 'after']\") -> 'Any'"
        },
        {
          "name": "parse_obj_as",
          "doc": null,
          "signature": "(type_: 'type[T]', obj: 'Any', type_name: 'NameFactory | None' = None) -> 'T'"
        },
        {
          "name": "root_validator",
          "doc": "Decorate methods on a model indicating that they should be used to validate (and perhaps\nmodify) data either before or after standard model parsing/validation is performed.\n\nArgs:\n    pre (bool, optional): Whether this validator should be called before the standard\n        validators (else after). Defaults to False.\n    skip_on_failure (bool, optional): Whether to stop validation and return as soon as a\n        failure is encountered. Defaults to False.\n    allow_reuse (bool, optional): Whether to track and raise an error if another validator\n        refers to the decorated function. Defaults to False.\n\nReturns:\n    Any: A decorator that can be used to decorate a function to be used as a root_validator.",
          "signature": "(*__args, pre: 'bool' = False, skip_on_failure: 'bool' = False, allow_reuse: 'bool' = False) -> 'Any'"
        },
        {
          "name": "schema_json_of",
          "doc": "Generate a JSON schema (as JSON) for the passed model or dynamically generated one.",
          "signature": "(type_: 'Any', *, title: 'NameFactory | None' = None, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, **dumps_kwargs: 'Any') -> 'str'"
        },
        {
          "name": "schema_of",
          "doc": "Generate a JSON schema (as dict) for the passed model or dynamically generated one.",
          "signature": "(type_: 'Any', *, title: 'NameFactory | None' = None, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>) -> 'dict[str, Any]'"
        },
        {
          "name": "validate_call",
          "doc": "!!! abstract \"Usage Documentation\"\n    [Validation Decorator](../concepts/validation_decorator.md)\n\nReturns a decorated wrapper around the function that validates the arguments and, optionally, the return value.\n\nUsage may be either as a plain decorator `@validate_call` or with arguments `@validate_call(...)`.\n\nArgs:\n    func: The function to be decorated.\n    config: The configuration dictionary.\n    validate_return: Whether to validate the return value.\n\nReturns:\n    The decorated function.",
          "signature": "(func: 'AnyCallableT | None' = None, /, *, config: 'ConfigDict | None' = None, validate_return: 'bool' = False) -> 'AnyCallableT | Callable[[AnyCallableT], AnyCallableT]'"
        },
        {
          "name": "validate_email",
          "doc": "Email address validation using [email-validator](https://pypi.org/project/email-validator/).\n\nReturns:\n    A tuple containing the local part of the email (or the name for \"pretty\" email addresses)\n        and the normalized email.\n\nRaises:\n    PydanticCustomError: If the email is invalid.\n\nNote:\n    Note that:\n\n    * Raw IP address (literal) domain parts are not allowed.\n    * `\"John Doe <local_part@domain.com>\"` style \"pretty\" email addresses are processed.\n    * Spaces are striped from the beginning and end of addresses, but no error is raised.",
          "signature": "(value: 'str') -> 'tuple[str, str]'"
        },
        {
          "name": "validator",
          "doc": "Decorate methods on the class indicating that they should be used to validate fields.\n\nArgs:\n    __field (str): The first field the validator should be called on; this is separate\n        from `fields` to ensure an error is raised if you don't pass at least one.\n    *fields (str): Additional field(s) the validator should be called on.\n    pre (bool, optional): Whether this validator should be called before the standard\n        validators (else after). Defaults to False.\n    each_item (bool, optional): For complex objects (sets, lists etc.) whether to validate\n        individual elements rather than the whole object. Defaults to False.\n    always (bool, optional): Whether this method and other validators should be called even if\n        the value is missing. Defaults to False.\n    check_fields (bool | None, optional): Whether to check that the fields actually exist on the model.\n        Defaults to None.\n    allow_reuse (bool, optional): Whether to track and raise an error if another validator refers to\n        the decorated function. Defaults to False.\n\nReturns:\n    Callable: A decorator that can be used to decorate a\n        function to be used as a validator.",
          "signature": "(__field: 'str', *fields: 'str', pre: 'bool' = False, each_item: 'bool' = False, always: 'bool' = False, check_fields: 'bool | None' = None, allow_reuse: 'bool' = False) -> 'Callable[[_V1ValidatorType], _V1ValidatorType]'"
        },
        {
          "name": "with_config",
          "doc": "!!! abstract \"Usage Documentation\"\n    [Configuration with other types](../concepts/config.md#configuration-on-other-supported-types)\n\nA convenience decorator to set a [Pydantic configuration](config.md) on a `TypedDict` or a `dataclass` from the standard library.\n\nAlthough the configuration can be set using the `__pydantic_config__` attribute, it does not play well with type checkers,\nespecially with `TypedDict`.\n\n!!! example \"Usage\"\n\n    ```python\n    from typing_extensions import TypedDict\n\n    from pydantic import ConfigDict, TypeAdapter, with_config\n\n    @with_config(ConfigDict(str_to_lower=True))\n    class TD(TypedDict):\n        x: str\n\n    ta = TypeAdapter(TD)\n\n    print(ta.validate_python({'x': 'ABC'}))\n    #> {'x': 'abc'}\n    ```",
          "signature": "(config: 'ConfigDict | None' = None, /, **kwargs: 'Any') -> 'Callable[[_TypeT], _TypeT]'"
        }
      ],
      "classes": [
        {
          "name": "AfterValidator",
          "doc": "!!! abstract \"Usage Documentation\"\n    [field *after* validators](../concepts/validators.md#field-after-validator)\n\nA metadata class that indicates that a validation should be applied **after** the inner validation logic.\n\nAttributes:\n    func: The validator function.\n\nExample:\n    ```python\n    from typing import Annotated\n\n    from pydantic import AfterValidator, BaseModel, ValidationError\n\n    MyInt = Annotated[int, AfterValidator(lambda v: v + 1)]\n\n    class Model(BaseModel):\n        a: MyInt\n\n    print(Model(a=1).a)\n    #> 2\n\n    try:\n        Model(a='a')\n    except ValidationError as e:\n        print(e.json(indent=2))\n        '''\n        [\n          {\n            \"type\": \"int_parsing\",\n            \"loc\": [\n              \"a\"\n            ],\n            \"msg\": \"Input should be a valid integer, unable to parse string as an integer\",\n            \"input\": \"a\",\n            \"url\": \"https://errors.pydantic.dev/2/v/int_parsing\"\n          }\n        ]\n        '''\n    ```",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_core_schema__",
              "doc": null,
              "signature": "(self, source_type: 'Any', handler: 'GetCoreSchemaHandler') -> 'core_schema.CoreSchema'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, func: 'core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction') -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "AliasChoices",
          "doc": "!!! abstract \"Usage Documentation\"\n    [`AliasPath` and `AliasChoices`](../concepts/alias.md#aliaspath-and-aliaschoices)\n\nA data class used by `validation_alias` as a convenience to create aliases.\n\nAttributes:\n    choices: A list containing a string or `AliasPath`.",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, first_choice: 'str | AliasPath', *choices: 'str | AliasPath') -> 'None'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "convert_to_aliases",
              "doc": "Converts arguments to a list of lists containing string or integer aliases.\n\nReturns:\n    The list of aliases.",
              "signature": "(self) -> 'list[list[str | int]]'"
            }
          ]
        },
        {
          "name": "AliasGenerator",
          "doc": "!!! abstract \"Usage Documentation\"\n    [Using an `AliasGenerator`](../concepts/alias.md#using-an-aliasgenerator)\n\nA data class used by `alias_generator` as a convenience to create various aliases.\n\nAttributes:\n    alias: A callable that takes a field name and returns an alias for it.\n    validation_alias: A callable that takes a field name and returns a validation alias for it.\n    serialization_alias: A callable that takes a field name and returns a serialization alias for it.",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, alias: 'Callable[[str], str] | None' = None, validation_alias: 'Callable[[str], str | AliasPath | AliasChoices] | None' = None, serialization_alias: 'Callable[[str], str] | None' = None) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "_generate_alias",
              "doc": "Generate an alias of the specified kind. Returns None if the alias generator is None.\n\nRaises:\n    TypeError: If the alias generator produces an invalid type.",
              "signature": "(self, alias_kind: \"Literal['alias', 'validation_alias', 'serialization_alias']\", allowed_types: 'tuple[type[str] | type[AliasPath] | type[AliasChoices], ...]', field_name: 'str') -> 'str | AliasPath | AliasChoices | None'"
            },
            {
              "name": "generate_aliases",
              "doc": "Generate `alias`, `validation_alias`, and `serialization_alias` for a field.\n\nReturns:\n    A tuple of three aliases - validation, alias, and serialization.",
              "signature": "(self, field_name: 'str') -> 'tuple[str | None, str | AliasPath | AliasChoices | None, str | None]'"
            }
          ]
        },
        {
          "name": "AliasPath",
          "doc": "!!! abstract \"Usage Documentation\"\n    [`AliasPath` and `AliasChoices`](../concepts/alias.md#aliaspath-and-aliaschoices)\n\nA data class used by `validation_alias` as a convenience to create aliases.\n\nAttributes:\n    path: A list of string or integer aliases.",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, first_arg: 'str', *args: 'str | int') -> 'None'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "convert_to_aliases",
              "doc": "Converts arguments to a list of string or integer aliases.\n\nReturns:\n    The list of aliases.",
              "signature": "(self) -> 'list[str | int]'"
            },
            {
              "name": "search_dict_for_path",
              "doc": "Searches a dictionary for the path specified by the alias.\n\nReturns:\n    The value at the specified path, or `PydanticUndefined` if the path is not found.",
              "signature": "(self, d: 'dict') -> 'Any'"
            }
          ]
        },
        {
          "name": "AllowInfNan",
          "doc": "A field metadata class to indicate that a field should allow `-inf`, `inf`, and `nan`.\n\nUse this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\nAttributes:\n    allow_inf_nan: Whether to allow `-inf`, `inf`, and `nan`. Defaults to `True`.\n\nExample:\n    ```python\n    from typing import Annotated\n\n    from pydantic.types import AllowInfNan\n\n    LaxFloat = Annotated[float, AllowInfNan()]\n    ```",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, allow_inf_nan: 'bool' = True) -> None"
            },
            {
              "name": "__pretty__",
              "doc": "Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.",
              "signature": "(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__repr_args__",
              "doc": "Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.\n\nCan either return:\n* name - value pairs, e.g.: `[('foo_name', 'foo'), ('bar_name', ['b', 'a', 'r'])]`\n* or, just values, e.g.: `[(None, 'foo'), (None, ['b', 'a', 'r'])]`",
              "signature": "(self) -> 'ReprArgs'"
            },
            {
              "name": "__repr_name__",
              "doc": "Name of the instance's class, used in __repr__.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__repr_recursion__",
              "doc": "Returns the string representation of a recursive object.",
              "signature": "(self, object: 'Any') -> 'str'"
            },
            {
              "name": "__repr_str__",
              "doc": null,
              "signature": "(self, join_str: 'str') -> 'str'"
            },
            {
              "name": "__rich_repr__",
              "doc": "Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.",
              "signature": "(self) -> 'RichReprResult'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "AmqpDsn",
          "doc": "A type that will accept any AMQP DSN.\n\n* User info required\n* TLD not required\n* Host not required",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "AnyHttpUrl",
          "doc": "A type that will accept any http or https URL.\n\n* TLD not required\n* Host not required",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "AnyUrl",
          "doc": "Base type for all URLs.\n\n* Any scheme allowed\n* Top-level domain (TLD) not required\n* Host not required\n\nAssuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\nthe types export the following properties:\n\n- `scheme`: the URL scheme (`http`), always set.\n- `host`: the URL host (`example.com`).\n- `username`: optional username if included (`samuel`).\n- `password`: optional password if included (`pass`).\n- `port`: optional port (`8000`).\n- `path`: optional path (`/the/path/`).\n- `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`).\n- `fragment`: optional fragment (`fragment=is;this=bit`).",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "AnyWebsocketUrl",
          "doc": "A type that will accept any ws or wss URL.\n\n* TLD not required\n* Host not required",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "AwareDatetime",
          "doc": "A datetime that requires timezone info.",
          "functions": [
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "Base64Encoder",
          "doc": "Standard (non-URL-safe) Base64 encoder.",
          "functions": []
        },
        {
          "name": "BaseConfig",
          "doc": "This class is only retained for backwards compatibility.\n\n!!! Warning \"Deprecated\"\n    BaseConfig is deprecated. Use the [`pydantic.ConfigDict`][pydantic.ConfigDict] instead.",
          "functions": [
            {
              "name": "__getattr__",
              "doc": null,
              "signature": "(self, item: 'str') -> 'Any'"
            }
          ]
        },
        {
          "name": "BaseModel",
          "doc": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "functions": [
            {
              "name": "__copy__",
              "doc": "Returns a shallow copy of the model.",
              "signature": "(self) -> 'Self'"
            },
            {
              "name": "__deepcopy__",
              "doc": "Returns a deep copy of the model.",
              "signature": "(self, memo: 'dict[int, Any] | None' = None) -> 'Self'"
            },
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, item: 'str') -> 'Any'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__getattr__",
              "doc": null,
              "signature": "(self, item: 'str') -> 'Any'"
            },
            {
              "name": "__getstate__",
              "doc": "Helper for pickle.",
              "signature": "(self) -> 'dict[Any, Any]'"
            },
            {
              "name": "__init__",
              "doc": "Create a new model by parsing and validating input data from keyword arguments.\n\nRaises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model.\n\n`self` is explicitly positional-only to allow `self` as a field name.",
              "signature": "(self, /, **data: 'Any') -> 'None'"
            },
            {
              "name": "__iter__",
              "doc": "So `dict(model)` works.",
              "signature": "(self) -> 'TupleGenerator'"
            },
            {
              "name": "__pretty__",
              "doc": "Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.",
              "signature": "(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'"
            },
            {
              "name": "__replace__",
              "doc": null,
              "signature": "(self, **changes: 'Any') -> 'Self'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__repr_args__",
              "doc": null,
              "signature": "(self) -> '_repr.ReprArgs'"
            },
            {
              "name": "__repr_name__",
              "doc": "Name of the instance's class, used in __repr__.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__repr_recursion__",
              "doc": "Returns the string representation of a recursive object.",
              "signature": "(self, object: 'Any') -> 'str'"
            },
            {
              "name": "__repr_str__",
              "doc": null,
              "signature": "(self, join_str: 'str') -> 'str'"
            },
            {
              "name": "__rich_repr__",
              "doc": "Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.",
              "signature": "(self) -> 'RichReprResult'"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name: 'str', value: 'Any') -> 'None'"
            },
            {
              "name": "__setstate__",
              "doc": null,
              "signature": "(self, state: 'dict[Any, Any]') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "_calculate_keys",
              "doc": null,
              "signature": "(self, *args: 'Any', **kwargs: 'Any') -> 'Any'"
            },
            {
              "name": "_copy_and_set_values",
              "doc": null,
              "signature": "(self, *args: 'Any', **kwargs: 'Any') -> 'Any'"
            },
            {
              "name": "_iter",
              "doc": null,
              "signature": "(self, *args: 'Any', **kwargs: 'Any') -> 'Any'"
            },
            {
              "name": "_setattr_handler",
              "doc": "Get a handler for setting an attribute on the model instance.\n\nReturns:\n    A handler for setting an attribute on the model instance. Used for memoization of the handler.\n    Memoizing the handlers leads to a dramatic performance improvement in `__setattr__`\n    Returns `None` when memoization is not safe, then the attribute is set directly.",
              "signature": "(self, name: 'str', value: 'Any') -> 'Callable[[BaseModel, str, Any], None] | None'"
            },
            {
              "name": "copy",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified.",
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'"
            },
            {
              "name": "dict",
              "doc": null,
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'"
            },
            {
              "name": "json",
              "doc": null,
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'"
            },
            {
              "name": "model_copy",
              "doc": "!!! abstract \"Usage Documentation\"\n    [`model_copy`](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n    The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n    might have unexpected side effects if you store anything in it, on top of the model\n    fields (e.g. the value of [cached properties][functools.cached_property]).\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance.",
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'"
            },
            {
              "name": "model_dump",
              "doc": "!!! abstract \"Usage Documentation\"\n    [`model_dump`](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    fallback: A function to call when an unknown value is encountered. If not provided,\n        a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model.",
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'"
            },
            {
              "name": "model_dump_json",
              "doc": "!!! abstract \"Usage Documentation\"\n    [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    fallback: A function to call when an unknown value is encountered. If not provided,\n        a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model.",
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'"
            },
            {
              "name": "model_post_init",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized.",
              "signature": "(self, context: 'Any', /) -> 'None'"
            }
          ]
        },
        {
          "name": "BeforeValidator",
          "doc": "!!! abstract \"Usage Documentation\"\n    [field *before* validators](../concepts/validators.md#field-before-validator)\n\nA metadata class that indicates that a validation should be applied **before** the inner validation logic.\n\nAttributes:\n    func: The validator function.\n    json_schema_input_type: The input type of the function. This is only used to generate the appropriate\n        JSON Schema (in validation mode).\n\nExample:\n    ```python\n    from typing import Annotated\n\n    from pydantic import BaseModel, BeforeValidator\n\n    MyInt = Annotated[int, BeforeValidator(lambda v: v + 1)]\n\n    class Model(BaseModel):\n        a: MyInt\n\n    print(Model(a=1).a)\n    #> 2\n\n    try:\n        Model(a='a')\n    except TypeError as e:\n        print(e)\n        #> can only concatenate str (not \"int\") to str\n    ```",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_core_schema__",
              "doc": null,
              "signature": "(self, source_type: 'Any', handler: 'GetCoreSchemaHandler') -> 'core_schema.CoreSchema'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, func: 'core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction', json_schema_input_type: 'Any' = PydanticUndefined) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "ByteSize",
          "doc": "Converts a string representing a number of bytes with units (such as `'1KB'` or `'11.5MiB'`) into an integer.\n\nYou can use the `ByteSize` data type to (case-insensitively) convert a string representation of a number of bytes into\nan integer, and also to print out human-readable strings representing a number of bytes.\n\nIn conformance with [IEC 80000-13 Standard](https://en.wikipedia.org/wiki/ISO/IEC_80000) we interpret `'1KB'` to mean 1000 bytes,\nand `'1KiB'` to mean 1024 bytes. In general, including a middle `'i'` will cause the unit to be interpreted as a power of 2,\nrather than a power of 10 (so, for example, `'1 MB'` is treated as `1_000_000` bytes, whereas `'1 MiB'` is treated as `1_048_576` bytes).\n\n!!! info\n    Note that `1b` will be parsed as \"1 byte\" and not \"1 bit\".\n\n```python\nfrom pydantic import BaseModel, ByteSize\n\nclass MyModel(BaseModel):\n    size: ByteSize\n\nprint(MyModel(size=52000).size)\n#> 52000\nprint(MyModel(size='3000 KiB').size)\n#> 3072000\n\nm = MyModel(size='50 PB')\nprint(m.size.human_readable())\n#> 44.4PiB\nprint(m.size.human_readable(decimal=True))\n#> 50.0PB\nprint(m.size.human_readable(separator=' '))\n#> 44.4 PiB\n\nprint(m.size.to('TiB'))\n#> 45474.73508864641\n```",
          "functions": [
            {
              "name": "human_readable",
              "doc": "Converts a byte size to a human readable string.\n\nArgs:\n    decimal: If True, use decimal units (e.g. 1000 bytes per KB). If False, use binary units\n        (e.g. 1024 bytes per KiB).\n    separator: A string used to split the value and unit. Defaults to an empty string ('').\n\nReturns:\n    A human readable string representation of the byte size.",
              "signature": "(self, decimal: 'bool' = False, separator: 'str' = '') -> 'str'"
            },
            {
              "name": "to",
              "doc": "Converts a byte size to another unit, including both byte and bit units.\n\nArgs:\n    unit: The unit to convert to. Must be one of the following: B, KB, MB, GB, TB, PB, EB,\n        KiB, MiB, GiB, TiB, PiB, EiB (byte units) and\n        bit, kbit, mbit, gbit, tbit, pbit, ebit,\n        kibit, mibit, gibit, tibit, pibit, eibit (bit units).\n\nReturns:\n    The byte size in the new unit.",
              "signature": "(self, unit: 'str') -> 'float'"
            }
          ]
        },
        {
          "name": "ClickHouseDsn",
          "doc": "A type that will accept any ClickHouse DSN.\n\n* User info required\n* TLD not required\n* Host not required",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "CockroachDsn",
          "doc": "A type that will accept any Cockroach DSN.\n\n* User info required\n* TLD not required\n* Host required",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "ConfigDict",
          "doc": "A TypedDict for configuring Pydantic behaviour.",
          "functions": []
        },
        {
          "name": "Discriminator",
          "doc": "!!! abstract \"Usage Documentation\"\n    [Discriminated Unions with `Callable` `Discriminator`](../concepts/unions.md#discriminated-unions-with-callable-discriminator)\n\nProvides a way to use a custom callable as the way to extract the value of a union discriminator.\n\nThis allows you to get validation behavior like you'd get from `Field(discriminator=<field_name>)`,\nbut without needing to have a single shared field across all the union choices. This also makes it\npossible to handle unions of models and primitive types with discriminated-union-style validation errors.\nFinally, this allows you to use a custom callable as the way to identify which member of a union a value\nbelongs to, while still seeing all the performance benefits of a discriminated union.\n\nConsider this example, which is much more performant with the use of `Discriminator` and thus a `TaggedUnion`\nthan it would be as a normal `Union`.\n\n```python\nfrom typing import Annotated, Any, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\ndef get_discriminator_value(v: Any) -> str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        Union[\n            Annotated[ApplePie, Tag('apple')],\n            Annotated[PumpkinPie, Tag('pumpkin')],\n        ],\n        Discriminator(get_discriminator_value),\n    ]\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n'''\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n'''\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n'''\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n'''\n```\n\nSee the [Discriminated Unions] concepts docs for more details on how to use `Discriminator`s.\n\n[Discriminated Unions]: ../concepts/unions.md#discriminated-unions",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_core_schema__",
              "doc": null,
              "signature": "(self, source_type: 'Any', handler: 'GetCoreSchemaHandler') -> 'CoreSchema'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, discriminator: 'str | Callable[[Any], Hashable]', custom_error_type: 'str | None' = None, custom_error_message: 'str | None' = None, custom_error_context: 'dict[str, int | str | float] | None' = None) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            },
            {
              "name": "_convert_schema",
              "doc": null,
              "signature": "(self, original_schema: 'core_schema.CoreSchema') -> 'core_schema.TaggedUnionSchema'"
            }
          ]
        },
        {
          "name": "EmailStr",
          "doc": "Info:\n    To use this type, you need to install the optional\n    [`email-validator`](https://github.com/JoshData/python-email-validator) package:\n\n    ```bash\n    pip install email-validator\n    ```\n\nValidate email addresses.\n\n```python\nfrom pydantic import BaseModel, EmailStr\n\nclass Model(BaseModel):\n    email: EmailStr\n\nprint(Model(email='contact@mail.com'))\n#> email='contact@mail.com'\n```",
          "functions": []
        },
        {
          "name": "EncodedBytes",
          "doc": "A bytes type that is encoded and decoded using the specified encoder.\n\n`EncodedBytes` needs an encoder that implements `EncoderProtocol` to operate.\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, EncodedBytes, EncoderProtocol, ValidationError\n\nclass MyEncoder(EncoderProtocol):\n    @classmethod\n    def decode(cls, data: bytes) -> bytes:\n        if data == b'**undecodable**':\n            raise ValueError('Cannot decode data')\n        return data[13:]\n\n    @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        return b'**encoded**: ' + value\n\n    @classmethod\n    def get_json_format(cls) -> str:\n        return 'my-encoder'\n\nMyEncodedBytes = Annotated[bytes, EncodedBytes(encoder=MyEncoder)]\n\nclass Model(BaseModel):\n    my_encoded_bytes: MyEncodedBytes\n\n# Initialize the model with encoded data\nm = Model(my_encoded_bytes=b'**encoded**: some bytes')\n\n# Access decoded value\nprint(m.my_encoded_bytes)\n#> b'some bytes'\n\n# Serialize into the encoded form\nprint(m.model_dump())\n#> {'my_encoded_bytes': b'**encoded**: some bytes'}\n\n# Validate encoded data\ntry:\n    Model(my_encoded_bytes=b'**undecodable**')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    my_encoded_bytes\n      Value error, Cannot decode data [type=value_error, input_value=b'**undecodable**', input_type=bytes]\n    '''\n```",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_core_schema__",
              "doc": null,
              "signature": "(self, source: 'type[Any]', handler: 'GetCoreSchemaHandler') -> 'core_schema.CoreSchema'"
            },
            {
              "name": "__get_pydantic_json_schema__",
              "doc": null,
              "signature": "(self, core_schema: 'core_schema.CoreSchema', handler: 'GetJsonSchemaHandler') -> 'JsonSchemaValue'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, encoder: 'type[EncoderProtocol]') -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "decode",
              "doc": "Decode the data using the specified encoder.\n\nArgs:\n    data: The data to decode.\n\nReturns:\n    The decoded data.",
              "signature": "(self, data: 'bytes', _: 'core_schema.ValidationInfo') -> 'bytes'"
            },
            {
              "name": "encode",
              "doc": "Encode the data using the specified encoder.\n\nArgs:\n    value: The data to encode.\n\nReturns:\n    The encoded data.",
              "signature": "(self, value: 'bytes') -> 'bytes'"
            }
          ]
        },
        {
          "name": "EncodedStr",
          "doc": "A str type that is encoded and decoded using the specified encoder.\n\n`EncodedStr` needs an encoder that implements `EncoderProtocol` to operate.\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, EncodedStr, EncoderProtocol, ValidationError\n\nclass MyEncoder(EncoderProtocol):\n    @classmethod\n    def decode(cls, data: bytes) -> bytes:\n        if data == b'**undecodable**':\n            raise ValueError('Cannot decode data')\n        return data[13:]\n\n    @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        return b'**encoded**: ' + value\n\n    @classmethod\n    def get_json_format(cls) -> str:\n        return 'my-encoder'\n\nMyEncodedStr = Annotated[str, EncodedStr(encoder=MyEncoder)]\n\nclass Model(BaseModel):\n    my_encoded_str: MyEncodedStr\n\n# Initialize the model with encoded data\nm = Model(my_encoded_str='**encoded**: some str')\n\n# Access decoded value\nprint(m.my_encoded_str)\n#> some str\n\n# Serialize into the encoded form\nprint(m.model_dump())\n#> {'my_encoded_str': '**encoded**: some str'}\n\n# Validate encoded data\ntry:\n    Model(my_encoded_str='**undecodable**')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    my_encoded_str\n      Value error, Cannot decode data [type=value_error, input_value='**undecodable**', input_type=str]\n    '''\n```",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_core_schema__",
              "doc": null,
              "signature": "(self, source: 'type[Any]', handler: 'GetCoreSchemaHandler') -> 'core_schema.CoreSchema'"
            },
            {
              "name": "__get_pydantic_json_schema__",
              "doc": null,
              "signature": "(self, core_schema: 'core_schema.CoreSchema', handler: 'GetJsonSchemaHandler') -> 'JsonSchemaValue'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, encoder: 'type[EncoderProtocol]') -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "decode_str",
              "doc": "Decode the data using the specified encoder.\n\nArgs:\n    data: The data to decode.\n\nReturns:\n    The decoded data.",
              "signature": "(self, data: 'str', _: 'core_schema.ValidationInfo') -> 'str'"
            },
            {
              "name": "encode_str",
              "doc": "Encode the data using the specified encoder.\n\nArgs:\n    value: The data to encode.\n\nReturns:\n    The encoded data.",
              "signature": "(self, value: 'str') -> 'str'"
            }
          ]
        },
        {
          "name": "EncoderProtocol",
          "doc": "Protocol for encoding and decoding data to and from bytes.",
          "functions": []
        },
        {
          "name": "Extra",
          "doc": null,
          "functions": []
        },
        {
          "name": "FailFast",
          "doc": "A `FailFast` annotation can be used to specify that validation should stop at the first error.\n\nThis can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.\n\nYou might want to enable this setting if you want to validate your data faster (basically, if you use this,\nvalidation will be more performant with the caveat that you get less information).\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, FailFast, ValidationError\n\nclass Model(BaseModel):\n    x: Annotated[list[int], FailFast()]\n\n# This will raise a single error for the first invalid value and stop validation\ntry:\n    obj = Model(x=[1, 2, 'a', 4, 5, 'b', 7, 8, 9, 'c'])\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    x.2\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    '''\n```",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, fail_fast: 'bool' = True) -> None"
            },
            {
              "name": "__pretty__",
              "doc": "Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.",
              "signature": "(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__repr_args__",
              "doc": "Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.\n\nCan either return:\n* name - value pairs, e.g.: `[('foo_name', 'foo'), ('bar_name', ['b', 'a', 'r'])]`\n* or, just values, e.g.: `[(None, 'foo'), (None, ['b', 'a', 'r'])]`",
              "signature": "(self) -> 'ReprArgs'"
            },
            {
              "name": "__repr_name__",
              "doc": "Name of the instance's class, used in __repr__.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__repr_recursion__",
              "doc": "Returns the string representation of a recursive object.",
              "signature": "(self, object: 'Any') -> 'str'"
            },
            {
              "name": "__repr_str__",
              "doc": null,
              "signature": "(self, join_str: 'str') -> 'str'"
            },
            {
              "name": "__rich_repr__",
              "doc": "Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.",
              "signature": "(self) -> 'RichReprResult'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "FieldSerializationInfo",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": [
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "mode_is_json",
              "doc": null,
              "signature": "(self) -> 'bool'"
            }
          ]
        },
        {
          "name": "FileUrl",
          "doc": "A type that will accept any file URL.\n\n* Host not required",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "FtpUrl",
          "doc": "A type that will accept ftp URL.\n\n* TLD not required\n* Host not required",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "FutureDate",
          "doc": "A date in the future.",
          "functions": [
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "FutureDatetime",
          "doc": "A datetime that must be in the future.",
          "functions": [
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "GetCoreSchemaHandler",
          "doc": "Handler to call into the next CoreSchema schema generation function.",
          "functions": [
            {
              "name": "__call__",
              "doc": "Call the inner handler and get the CoreSchema it returns.\nThis will call the next CoreSchema modifying function up until it calls\ninto Pydantic's internal schema generation machinery, which will raise a\n`pydantic.errors.PydanticSchemaGenerationError` error if it cannot generate\na CoreSchema for the given source type.\n\nArgs:\n    source_type: The input type.\n\nReturns:\n    CoreSchema: The `pydantic-core` CoreSchema generated.",
              "signature": "(self, source_type: 'Any', /) -> 'core_schema.CoreSchema'"
            },
            {
              "name": "_get_types_namespace",
              "doc": "Internal method used during type resolution for serializer annotations.",
              "signature": "(self) -> 'NamespacesTuple'"
            },
            {
              "name": "generate_schema",
              "doc": "Generate a schema unrelated to the current context.\nUse this function if e.g. you are handling schema generation for a sequence\nand want to generate a schema for its items.\nOtherwise, you may end up doing something like applying a `min_length` constraint\nthat was intended for the sequence itself to its items!\n\nArgs:\n    source_type: The input type.\n\nReturns:\n    CoreSchema: The `pydantic-core` CoreSchema generated.",
              "signature": "(self, source_type: 'Any', /) -> 'core_schema.CoreSchema'"
            },
            {
              "name": "resolve_ref_schema",
              "doc": "Get the real schema for a `definition-ref` schema.\nIf the schema given is not a `definition-ref` schema, it will be returned as is.\nThis means you don't have to check before calling this function.\n\nArgs:\n    maybe_ref_schema: A `CoreSchema`, `ref`-based or not.\n\nRaises:\n    LookupError: If the `ref` is not found.\n\nReturns:\n    A concrete `CoreSchema`.",
              "signature": "(self, maybe_ref_schema: 'core_schema.CoreSchema', /) -> 'core_schema.CoreSchema'"
            }
          ]
        },
        {
          "name": "GetJsonSchemaHandler",
          "doc": "Handler to call into the next JSON schema generation function.\n\nAttributes:\n    mode: Json schema mode, can be `validation` or `serialization`.",
          "functions": [
            {
              "name": "__call__",
              "doc": "Call the inner handler and get the JsonSchemaValue it returns.\nThis will call the next JSON schema modifying function up until it calls\ninto `pydantic.json_schema.GenerateJsonSchema`, which will raise a\n`pydantic.errors.PydanticInvalidForJsonSchema` error if it cannot generate\na JSON schema.\n\nArgs:\n    core_schema: A `pydantic_core.core_schema.CoreSchema`.\n\nReturns:\n    JsonSchemaValue: The JSON schema generated by the inner JSON schema modify\n    functions.",
              "signature": "(self, core_schema: 'CoreSchemaOrField', /) -> 'JsonSchemaValue'"
            },
            {
              "name": "resolve_ref_schema",
              "doc": "Get the real schema for a `{\"$ref\": ...}` schema.\nIf the schema given is not a `$ref` schema, it will be returned as is.\nThis means you don't have to check before calling this function.\n\nArgs:\n    maybe_ref_json_schema: A JsonSchemaValue which may be a `$ref` schema.\n\nRaises:\n    LookupError: If the ref is not found.\n\nReturns:\n    JsonSchemaValue: A JsonSchemaValue that has no `$ref`.",
              "signature": "(self, maybe_ref_json_schema: 'JsonSchemaValue', /) -> 'JsonSchemaValue'"
            }
          ]
        },
        {
          "name": "GetPydanticSchema",
          "doc": "!!! abstract \"Usage Documentation\"\n    [Using `GetPydanticSchema` to Reduce Boilerplate](../concepts/types.md#using-getpydanticschema-to-reduce-boilerplate)\n\nA convenience class for creating an annotation that provides pydantic custom type hooks.\n\nThis class is intended to eliminate the need to create a custom \"marker\" which defines the\n `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__` custom hook methods.\n\nFor example, to have a field treated by type checkers as `int`, but by pydantic as `Any`, you can do:\n```python\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, GetPydanticSchema\n\nHandleAsAny = GetPydanticSchema(lambda _s, h: h(Any))\n\nclass Model(BaseModel):\n    x: Annotated[int, HandleAsAny]  # pydantic sees `x: Any`\n\nprint(repr(Model(x='abc').x))\n#> 'abc'\n```",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__getattr__",
              "doc": "Use this rather than defining `__get_pydantic_core_schema__` etc. to reduce the number of nested calls.",
              "signature": "(self, item: 'str') -> 'Any'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, get_pydantic_core_schema: 'Callable[[Any, GetCoreSchemaHandler], CoreSchema] | None' = None, get_pydantic_json_schema: 'Callable[[Any, GetJsonSchemaHandler], JsonSchemaValue] | None' = None) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "HttpUrl",
          "doc": "A type that will accept any http or https URL.\n\n* TLD not required\n* Host not required\n* Max length 2083\n\n```python\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm = MyModel(url='http://www.example.com')  # (1)!\nprint(m.url)\n#> http://www.example.com/\n\ntry:\n    MyModel(url='ftp://invalid.url')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyModel\n    url\n      URL scheme should be 'http' or 'https' [type=url_scheme, input_value='ftp://invalid.url', input_type=str]\n    '''\n\ntry:\n    MyModel(url='not a url')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyModel\n    url\n      Input should be a valid URL, relative URL without a base [type=url_parsing, input_value='not a url', input_type=str]\n    '''\n```\n\n1. Note: mypy would prefer `m = MyModel(url=HttpUrl('http://www.example.com'))`, but Pydantic will convert the string to an HttpUrl instance anyway.\n\n\"International domains\" (e.g. a URL where the host or TLD includes non-ascii characters) will be encoded via\n[punycode](https://en.wikipedia.org/wiki/Punycode) (see\n[this article](https://www.xudongz.com/blog/2017/idn-phishing/) for a good description of why this is important):\n\n```python\nfrom pydantic import BaseModel, HttpUrl\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm1 = MyModel(url='http://puny\u00a3code.com')\nprint(m1.url)\n#> http://xn--punycode-eja.com/\nm2 = MyModel(url='https://www.\u0430\u0440\u0440\u04cf\u0435.com/')\nprint(m2.url)\n#> https://www.xn--80ak6aa92e.com/\nm3 = MyModel(url='https://www.example.\u73e0\u5b9d/')\nprint(m3.url)\n#> https://www.example.xn--pbt977c/\n```\n\n\n!!! warning \"Underscores in Hostnames\"\n    In Pydantic, underscores are allowed in all parts of a domain except the TLD.\n    Technically this might be wrong - in theory the hostname cannot have underscores, but subdomains can.\n\n    To explain this; consider the following two cases:\n\n    - `exam_ple.co.uk`: the hostname is `exam_ple`, which should not be allowed since it contains an underscore.\n    - `foo_bar.example.com` the hostname is `example`, which should be allowed since the underscore is in the subdomain.\n\n    Without having an exhaustive list of TLDs, it would be impossible to differentiate between these two. Therefore\n    underscores are allowed, but you can always do further validation in a validator if desired.\n\n    Also, Chrome, Firefox, and Safari all currently accept `http://exam_ple.com` as a URL, so we're in good\n    (or at least big) company.",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "IPvAnyAddress",
          "doc": "Validate an IPv4 or IPv6 address.\n\n```python\nfrom pydantic import BaseModel\nfrom pydantic.networks import IPvAnyAddress\n\nclass IpModel(BaseModel):\n    ip: IPvAnyAddress\n\nprint(IpModel(ip='127.0.0.1'))\n#> ip=IPv4Address('127.0.0.1')\n\ntry:\n    IpModel(ip='http://www.example.com')\nexcept ValueError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'ip_any_address',\n            'loc': ('ip',),\n            'msg': 'value is not a valid IPv4 or IPv6 address',\n            'input': 'http://www.example.com',\n        }\n    ]\n    '''\n```",
          "functions": [
            {
              "name": "__new__",
              "doc": "Validate an IPv4 or IPv6 address.",
              "signature": "(cls, value: 'Any') -> 'IPvAnyAddressType'"
            }
          ]
        },
        {
          "name": "IPvAnyInterface",
          "doc": "Validate an IPv4 or IPv6 interface.",
          "functions": [
            {
              "name": "__new__",
              "doc": "Validate an IPv4 or IPv6 interface.",
              "signature": "(cls, value: 'NetworkType') -> 'IPvAnyInterfaceType'"
            }
          ]
        },
        {
          "name": "IPvAnyNetwork",
          "doc": "Validate an IPv4 or IPv6 network.",
          "functions": [
            {
              "name": "__new__",
              "doc": "Validate an IPv4 or IPv6 network.",
              "signature": "(cls, value: 'NetworkType') -> 'IPvAnyNetworkType'"
            }
          ]
        },
        {
          "name": "ImportString",
          "doc": "A type that can be used to import a Python object from a string.\n\n`ImportString` expects a string and loads the Python object importable at that dotted path.\nAttributes of modules may be separated from the module by `:` or `.`, e.g. if `'math:cos'` is provided,\nthe resulting field value would be the function `cos`. If a `.` is used and both an attribute and submodule\nare present at the same path, the module will be preferred.\n\nOn model instantiation, pointers will be evaluated and imported. There is\nsome nuance to this behavior, demonstrated in the examples below.\n\n```python\nimport math\n\nfrom pydantic import BaseModel, Field, ImportString, ValidationError\n\nclass ImportThings(BaseModel):\n    obj: ImportString\n\n# A string value will cause an automatic import\nmy_cos = ImportThings(obj='math.cos')\n\n# You can use the imported function as you would expect\ncos_of_0 = my_cos.obj(0)\nassert cos_of_0 == 1\n\n# A string whose value cannot be imported will raise an error\ntry:\n    ImportThings(obj='foo.bar')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for ImportThings\n    obj\n      Invalid python path: No module named 'foo.bar' [type=import_error, input_value='foo.bar', input_type=str]\n    '''\n\n# Actual python objects can be assigned as well\nmy_cos = ImportThings(obj=math.cos)\nmy_cos_2 = ImportThings(obj='math.cos')\nmy_cos_3 = ImportThings(obj='math:cos')\nassert my_cos == my_cos_2 == my_cos_3\n\n# You can set default field value either as Python object:\nclass ImportThingsDefaultPyObj(BaseModel):\n    obj: ImportString = math.cos\n\n# or as a string value (but only if used with `validate_default=True`)\nclass ImportThingsDefaultString(BaseModel):\n    obj: ImportString = Field(default='math.cos', validate_default=True)\n\nmy_cos_default1 = ImportThingsDefaultPyObj()\nmy_cos_default2 = ImportThingsDefaultString()\nassert my_cos_default1.obj == my_cos_default2.obj == math.cos\n\n# note: this will not work!\nclass ImportThingsMissingValidateDefault(BaseModel):\n    obj: ImportString = 'math.cos'\n\nmy_cos_default3 = ImportThingsMissingValidateDefault()\nassert my_cos_default3.obj == 'math.cos'  # just string, not evaluated\n```\n\nSerializing an `ImportString` type to json is also possible.\n\n```python\nfrom pydantic import BaseModel, ImportString\n\nclass ImportThings(BaseModel):\n    obj: ImportString\n\n# Create an instance\nm = ImportThings(obj='math.cos')\nprint(m)\n#> obj=<built-in function cos>\nprint(m.model_dump_json())\n#> {\"obj\":\"math.cos\"}\n```",
          "functions": [
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "_serialize",
              "doc": null,
              "signature": "(v: 'Any') -> 'str'"
            }
          ]
        },
        {
          "name": "InstanceOf",
          "doc": "Generic type for annotating a type that is an instance of a given class.\n\nExample:\n    ```python\n    from pydantic import BaseModel, InstanceOf\n\n    class Foo:\n        ...\n\n    class Bar(BaseModel):\n        foo: InstanceOf[Foo]\n\n    Bar(foo=Foo())\n    try:\n        Bar(foo=42)\n    except ValidationError as e:\n        print(e)\n        \"\"\"\n        [\n        \u2502   {\n        \u2502   \u2502   'type': 'is_instance_of',\n        \u2502   \u2502   'loc': ('foo',),\n        \u2502   \u2502   'msg': 'Input should be an instance of Foo',\n        \u2502   \u2502   'input': 42,\n        \u2502   \u2502   'ctx': {'class': 'Foo'},\n        \u2502   \u2502   'url': 'https://errors.pydantic.dev/0.38.0/v/is_instance_of'\n        \u2502   }\n        ]\n        \"\"\"\n    ```",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "Json",
          "doc": "A special type wrapper which loads JSON before parsing.\n\nYou can use the `Json` data type to make Pydantic first load a raw JSON string before\nvalidating the loaded data into the parametrized type:\n\n```python\nfrom typing import Any\n\nfrom pydantic import BaseModel, Json, ValidationError\n\nclass AnyJsonModel(BaseModel):\n    json_obj: Json[Any]\n\nclass ConstrainedJsonModel(BaseModel):\n    json_obj: Json[list[int]]\n\nprint(AnyJsonModel(json_obj='{\"b\": 1}'))\n#> json_obj={'b': 1}\nprint(ConstrainedJsonModel(json_obj='[1, 2, 3]'))\n#> json_obj=[1, 2, 3]\n\ntry:\n    ConstrainedJsonModel(json_obj=12)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for ConstrainedJsonModel\n    json_obj\n      JSON input should be string, bytes or bytearray [type=json_type, input_value=12, input_type=int]\n    '''\n\ntry:\n    ConstrainedJsonModel(json_obj='[a, b]')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for ConstrainedJsonModel\n    json_obj\n      Invalid JSON: expected value at line 1 column 2 [type=json_invalid, input_value='[a, b]', input_type=str]\n    '''\n\ntry:\n    ConstrainedJsonModel(json_obj='[\"a\", \"b\"]')\nexcept ValidationError as e:\n    print(e)\n    '''\n    2 validation errors for ConstrainedJsonModel\n    json_obj.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    json_obj.1\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='b', input_type=str]\n    '''\n```\n\nWhen you dump the model using `model_dump` or `model_dump_json`, the dumped value will be the result of validation,\nnot the original JSON string. However, you can use the argument `round_trip=True` to get the original JSON string back:\n\n```python\nfrom pydantic import BaseModel, Json\n\nclass ConstrainedJsonModel(BaseModel):\n    json_obj: Json[list[int]]\n\nprint(ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json())\n#> {\"json_obj\":[1,2,3]}\nprint(\n    ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json(round_trip=True)\n)\n#> {\"json_obj\":\"[1,2,3]\"}\n```",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "KafkaDsn",
          "doc": "A type that will accept any Kafka DSN.\n\n* User info required\n* TLD not required\n* Host not required",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "MariaDBDsn",
          "doc": "A type that will accept any MariaDB DSN.\n\n* User info required\n* TLD not required\n* Host not required",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "ModelWrapValidatorHandler",
          "doc": "`@model_validator` decorated function handler argument type. This is used when `mode='wrap'`.",
          "functions": [
            {
              "name": "__call__",
              "doc": "Call self as a function.",
              "signature": "(self, value: 'Any', outer_location: 'str | int | None' = None, /) -> '_ModelTypeCo'"
            }
          ]
        },
        {
          "name": "MongoDsn",
          "doc": "A type that will accept any MongoDB DSN.\n\n* User info not required\n* Database name not required\n* Port not required\n* User info may be passed without user part (e.g., `mongodb://mongodb0.example.com:27017`).",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreMultiHostUrl | _BaseMultiHostUrl') -> 'None'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "hosts",
              "doc": "The hosts of the `MultiHostUrl` as [`MultiHostHost`][pydantic_core.MultiHostHost] typed dicts.\n\n```python\nfrom pydantic_core import MultiHostUrl\n\nmhu = MultiHostUrl('https://foo.com:123,foo:bar@bar.com/path')\nprint(mhu.hosts())\n\"\"\"\n[\n    {'username': None, 'password': None, 'host': 'foo.com', 'port': 123},\n    {'username': 'foo', 'password': 'bar', 'host': 'bar.com', 'port': 443}\n]\n```\nReturns:\n    A list of dicts, each representing a host.",
              "signature": "(self) -> 'list[MultiHostHost]'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://foo.com,bar.com/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the hosts.",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "MySQLDsn",
          "doc": "A type that will accept any MySQL DSN.\n\n* User info required\n* TLD not required\n* Host not required",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "NaiveDatetime",
          "doc": "A datetime that doesn't require timezone info.",
          "functions": [
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "NameEmail",
          "doc": "Info:\n    To use this type, you need to install the optional\n    [`email-validator`](https://github.com/JoshData/python-email-validator) package:\n\n    ```bash\n    pip install email-validator\n    ```\n\nValidate a name and email address combination, as specified by\n[RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4).\n\nThe `NameEmail` has two properties: `name` and `email`.\nIn case the `name` is not provided, it's inferred from the email address.\n\n```python\nfrom pydantic import BaseModel, NameEmail\n\nclass User(BaseModel):\n    email: NameEmail\n\nuser = User(email='Fred Bloggs <fred.bloggs@example.com>')\nprint(user.email)\n#> Fred Bloggs <fred.bloggs@example.com>\nprint(user.email.name)\n#> Fred Bloggs\n\nuser = User(email='fred.bloggs@example.com')\nprint(user.email)\n#> fred.bloggs <fred.bloggs@example.com>\nprint(user.email.name)\n#> fred.bloggs\n```",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, name: 'str', email: 'str')"
            },
            {
              "name": "__pretty__",
              "doc": "Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.",
              "signature": "(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__repr_args__",
              "doc": "Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.\n\nCan either return:\n* name - value pairs, e.g.: `[('foo_name', 'foo'), ('bar_name', ['b', 'a', 'r'])]`\n* or, just values, e.g.: `[(None, 'foo'), (None, ['b', 'a', 'r'])]`",
              "signature": "(self) -> 'ReprArgs'"
            },
            {
              "name": "__repr_name__",
              "doc": "Name of the instance's class, used in __repr__.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__repr_recursion__",
              "doc": "Returns the string representation of a recursive object.",
              "signature": "(self, object: 'Any') -> 'str'"
            },
            {
              "name": "__repr_str__",
              "doc": null,
              "signature": "(self, join_str: 'str') -> 'str'"
            },
            {
              "name": "__rich_repr__",
              "doc": "Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.",
              "signature": "(self) -> 'RichReprResult'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "NatsDsn",
          "doc": "A type that will accept any NATS DSN.\n\nNATS is a connective technology built for the ever increasingly hyper-connected world.\nIt is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices.\nMore: https://nats.io",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreMultiHostUrl | _BaseMultiHostUrl') -> 'None'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "hosts",
              "doc": "The hosts of the `MultiHostUrl` as [`MultiHostHost`][pydantic_core.MultiHostHost] typed dicts.\n\n```python\nfrom pydantic_core import MultiHostUrl\n\nmhu = MultiHostUrl('https://foo.com:123,foo:bar@bar.com/path')\nprint(mhu.hosts())\n\"\"\"\n[\n    {'username': None, 'password': None, 'host': 'foo.com', 'port': 123},\n    {'username': 'foo', 'password': 'bar', 'host': 'bar.com', 'port': 443}\n]\n```\nReturns:\n    A list of dicts, each representing a host.",
              "signature": "(self) -> 'list[MultiHostHost]'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://foo.com,bar.com/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the hosts.",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PastDate",
          "doc": "A date in the past.",
          "functions": [
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PastDatetime",
          "doc": "A datetime that must be in the past.",
          "functions": [
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PaymentCardNumber",
          "doc": "Based on: https://en.wikipedia.org/wiki/Payment_card_number.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, card_number: 'str')"
            },
            {
              "name": "validate_brand",
              "doc": "Validate length based on BIN for major brands:\nhttps://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN).",
              "signature": "(card_number: 'str') -> 'PaymentCardBrand'"
            }
          ]
        },
        {
          "name": "PlainSerializer",
          "doc": "Plain serializers use a function to modify the output of serialization.\n\nThis is particularly helpful when you want to customize the serialization for annotated types.\nConsider an input of `list`, which will be serialized into a space-delimited string.\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, PlainSerializer\n\nCustomStr = Annotated[\n    list, PlainSerializer(lambda x: ' '.join(x), return_type=str)\n]\n\nclass StudentModel(BaseModel):\n    courses: CustomStr\n\nstudent = StudentModel(courses=['Math', 'Chemistry', 'English'])\nprint(student.model_dump())\n#> {'courses': 'Math Chemistry English'}\n```\n\nAttributes:\n    func: The serializer function.\n    return_type: The return type for the function. If omitted it will be inferred from the type annotation.\n    when_used: Determines when this serializer should be used. Accepts a string with values `'always'`,\n        `'unless-none'`, `'json'`, and `'json-unless-none'`. Defaults to 'always'.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_core_schema__",
              "doc": "Gets the Pydantic core schema.\n\nArgs:\n    source_type: The source type.\n    handler: The `GetCoreSchemaHandler` instance.\n\nReturns:\n    The Pydantic core schema.",
              "signature": "(self, source_type: 'Any', handler: 'GetCoreSchemaHandler') -> 'core_schema.CoreSchema'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, func: 'core_schema.SerializerFunction', return_type: 'Any' = PydanticUndefined, when_used: 'WhenUsed' = 'always') -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "PlainValidator",
          "doc": "!!! abstract \"Usage Documentation\"\n    [field *plain* validators](../concepts/validators.md#field-plain-validator)\n\nA metadata class that indicates that a validation should be applied **instead** of the inner validation logic.\n\n!!! note\n    Before v2.9, `PlainValidator` wasn't always compatible with JSON Schema generation for `mode='validation'`.\n    You can now use the `json_schema_input_type` argument to specify the input type of the function\n    to be used in the JSON schema when `mode='validation'` (the default). See the example below for more details.\n\nAttributes:\n    func: The validator function.\n    json_schema_input_type: The input type of the function. This is only used to generate the appropriate\n        JSON Schema (in validation mode). If not provided, will default to `Any`.\n\nExample:\n    ```python\n    from typing import Annotated, Union\n\n    from pydantic import BaseModel, PlainValidator\n\n    MyInt = Annotated[\n        int,\n        PlainValidator(\n            lambda v: int(v) + 1, json_schema_input_type=Union[str, int]  # (1)!\n        ),\n    ]\n\n    class Model(BaseModel):\n        a: MyInt\n\n    print(Model(a='1').a)\n    #> 2\n\n    print(Model(a=1).a)\n    #> 2\n    ```\n\n    1. In this example, we've specified the `json_schema_input_type` as `Union[str, int]` which indicates to the JSON schema\n    generator that in validation mode, the input type for the `a` field can be either a `str` or an `int`.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_core_schema__",
              "doc": null,
              "signature": "(self, source_type: 'Any', handler: 'GetCoreSchemaHandler') -> 'core_schema.CoreSchema'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, func: 'core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction', json_schema_input_type: 'Any' = typing.Any) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "PostgresDsn",
          "doc": "A type that will accept any Postgres DSN.\n\n* User info required\n* TLD not required\n* Host required\n* Supports multiple hosts\n\nIf further validation is required, these properties can be used by validators to enforce specific behaviour:\n\n```python\nfrom pydantic import (\n    BaseModel,\n    HttpUrl,\n    PostgresDsn,\n    ValidationError,\n    field_validator,\n)\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm = MyModel(url='http://www.example.com')\n\n# the repr() method for a url will display all properties of the url\nprint(repr(m.url))\n#> HttpUrl('http://www.example.com/')\nprint(m.url.scheme)\n#> http\nprint(m.url.host)\n#> www.example.com\nprint(m.url.port)\n#> 80\n\nclass MyDatabaseModel(BaseModel):\n    db: PostgresDsn\n\n    @field_validator('db')\n    def check_db_name(cls, v):\n        assert v.path and len(v.path) > 1, 'database must be provided'\n        return v\n\nm = MyDatabaseModel(db='postgres://user:pass@localhost:5432/foobar')\nprint(m.db)\n#> postgres://user:pass@localhost:5432/foobar\n\ntry:\n    MyDatabaseModel(db='postgres://user:pass@localhost:5432')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyDatabaseModel\n    db\n      Assertion failed, database must be provided\n    assert (None)\n     +  where None = PostgresDsn('postgres://user:pass@localhost:5432').path [type=assertion_error, input_value='postgres://user:pass@localhost:5432', input_type=str]\n    '''\n```",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreMultiHostUrl | _BaseMultiHostUrl') -> 'None'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "hosts",
              "doc": "The hosts of the `MultiHostUrl` as [`MultiHostHost`][pydantic_core.MultiHostHost] typed dicts.\n\n```python\nfrom pydantic_core import MultiHostUrl\n\nmhu = MultiHostUrl('https://foo.com:123,foo:bar@bar.com/path')\nprint(mhu.hosts())\n\"\"\"\n[\n    {'username': None, 'password': None, 'host': 'foo.com', 'port': 123},\n    {'username': 'foo', 'password': 'bar', 'host': 'bar.com', 'port': 443}\n]\n```\nReturns:\n    A list of dicts, each representing a host.",
              "signature": "(self) -> 'list[MultiHostHost]'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://foo.com,bar.com/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the hosts.",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PydanticDeprecatedSince20",
          "doc": "A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.0.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: 'str', *args: 'object') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PydanticDeprecatedSince210",
          "doc": "A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.10.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: 'str', *args: 'object') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PydanticDeprecatedSince211",
          "doc": "A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.11.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: 'str', *args: 'object') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PydanticDeprecatedSince26",
          "doc": "A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.6.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: 'str', *args: 'object') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PydanticDeprecatedSince29",
          "doc": "A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.9.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: 'str', *args: 'object') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PydanticDeprecationWarning",
          "doc": "A Pydantic specific deprecation warning.\n\nThis warning is raised when using deprecated functionality in Pydantic. It provides information on when the\ndeprecation was introduced and the expected version in which the corresponding functionality will be removed.\n\nAttributes:\n    message: Description of the warning.\n    since: Pydantic version in what the deprecation was introduced.\n    expected_removal: Pydantic version in what the corresponding functionality expected to be removed.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: 'str', *args: 'object', since: 'tuple[int, int]', expected_removal: 'tuple[int, int] | None' = None) -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PydanticExperimentalWarning",
          "doc": "A Pydantic specific experimental functionality warning.\n\nThis warning is raised when using experimental functionality in Pydantic.\nIt is raised to warn users that the functionality may change or be removed in future versions of Pydantic.",
          "functions": []
        },
        {
          "name": "PydanticForbiddenQualifier",
          "doc": "An error raised if a forbidden type qualifier is found in a type annotation.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, qualifier: 'Qualifier', annotation: 'Any') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PydanticImportError",
          "doc": "An error raised when an import fails due to module changes between V1 and V2.\n\nAttributes:\n    message: Description of the error.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: 'str') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PydanticInvalidForJsonSchema",
          "doc": "An error raised during failures to generate a JSON schema for some `CoreSchema`.\n\nAttributes:\n    message: Description of the error.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: 'str') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PydanticSchemaGenerationError",
          "doc": "An error raised during failures to generate a `CoreSchema` for some type.\n\nAttributes:\n    message: Description of the error.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: 'str') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PydanticUndefinedAnnotation",
          "doc": "A subclass of `NameError` raised when handling undefined annotations during `CoreSchema` generation.\n\nAttributes:\n    name: Name of the error.\n    message: Description of the error.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, name: 'str', message: 'str') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "PydanticUserError",
          "doc": "An error raised due to incorrect use of Pydantic.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, message: 'str', *, code: 'PydanticErrorCodes | None') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "RedisDsn",
          "doc": "A type that will accept any Redis DSN.\n\n* User info required\n* TLD not required\n* Host required (e.g., `rediss://:pass@localhost`)",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "RootModel",
          "doc": "!!! abstract \"Usage Documentation\"\n    [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)\n\nA Pydantic `BaseModel` for the root object of the model.\n\nAttributes:\n    root: The root object of the model.\n    __pydantic_root_model__: Whether the model is a RootModel.\n    __pydantic_private__: Private fields in the model.\n    __pydantic_extra__: Extra fields in the model.",
          "functions": [
            {
              "name": "__copy__",
              "doc": "Returns a shallow copy of the model.",
              "signature": "(self) -> 'Self'"
            },
            {
              "name": "__deepcopy__",
              "doc": "Returns a deep copy of the model.",
              "signature": "(self, memo: 'dict[int, Any] | None' = None) -> 'Self'"
            },
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, item: 'str') -> 'Any'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__getattr__",
              "doc": null,
              "signature": "(self, item: 'str') -> 'Any'"
            },
            {
              "name": "__getstate__",
              "doc": "Helper for pickle.",
              "signature": "(self) -> 'dict[Any, Any]'"
            },
            {
              "name": "__init__",
              "doc": "Create a new model by parsing and validating input data from keyword arguments.\n\nRaises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model.\n\n`self` is explicitly positional-only to allow `self` as a field name.",
              "signature": "(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'"
            },
            {
              "name": "__iter__",
              "doc": "So `dict(model)` works.",
              "signature": "(self) -> 'TupleGenerator'"
            },
            {
              "name": "__pretty__",
              "doc": "Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.",
              "signature": "(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'"
            },
            {
              "name": "__replace__",
              "doc": null,
              "signature": "(self, **changes: 'Any') -> 'Self'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__repr_args__",
              "doc": null,
              "signature": "(self) -> '_repr.ReprArgs'"
            },
            {
              "name": "__repr_name__",
              "doc": "Name of the instance's class, used in __repr__.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__repr_recursion__",
              "doc": "Returns the string representation of a recursive object.",
              "signature": "(self, object: 'Any') -> 'str'"
            },
            {
              "name": "__repr_str__",
              "doc": null,
              "signature": "(self, join_str: 'str') -> 'str'"
            },
            {
              "name": "__rich_repr__",
              "doc": "Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.",
              "signature": "(self) -> 'RichReprResult'"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name: 'str', value: 'Any') -> 'None'"
            },
            {
              "name": "__setstate__",
              "doc": null,
              "signature": "(self, state: 'dict[Any, Any]') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "_calculate_keys",
              "doc": null,
              "signature": "(self, *args: 'Any', **kwargs: 'Any') -> 'Any'"
            },
            {
              "name": "_copy_and_set_values",
              "doc": null,
              "signature": "(self, *args: 'Any', **kwargs: 'Any') -> 'Any'"
            },
            {
              "name": "_iter",
              "doc": null,
              "signature": "(self, *args: 'Any', **kwargs: 'Any') -> 'Any'"
            },
            {
              "name": "_setattr_handler",
              "doc": "Get a handler for setting an attribute on the model instance.\n\nReturns:\n    A handler for setting an attribute on the model instance. Used for memoization of the handler.\n    Memoizing the handlers leads to a dramatic performance improvement in `__setattr__`\n    Returns `None` when memoization is not safe, then the attribute is set directly.",
              "signature": "(self, name: 'str', value: 'Any') -> 'Callable[[BaseModel, str, Any], None] | None'"
            },
            {
              "name": "copy",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified.",
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'"
            },
            {
              "name": "dict",
              "doc": null,
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'"
            },
            {
              "name": "json",
              "doc": null,
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'"
            },
            {
              "name": "model_copy",
              "doc": "!!! abstract \"Usage Documentation\"\n    [`model_copy`](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n    The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n    might have unexpected side effects if you store anything in it, on top of the model\n    fields (e.g. the value of [cached properties][functools.cached_property]).\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance.",
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'"
            },
            {
              "name": "model_dump",
              "doc": "!!! abstract \"Usage Documentation\"\n    [`model_dump`](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    fallback: A function to call when an unknown value is encountered. If not provided,\n        a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model.",
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'"
            },
            {
              "name": "model_dump_json",
              "doc": "!!! abstract \"Usage Documentation\"\n    [`model_dump_json`](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    fallback: A function to call when an unknown value is encountered. If not provided,\n        a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model.",
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'"
            },
            {
              "name": "model_post_init",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized.",
              "signature": "(self, context: 'Any', /) -> 'None'"
            }
          ]
        },
        {
          "name": "Secret",
          "doc": "A generic base class used for defining a field with sensitive information that you do not want to be visible in logging or tracebacks.\n\nYou may either directly parametrize `Secret` with a type, or subclass from `Secret` with a parametrized type. The benefit of subclassing\nis that you can define a custom `_display` method, which will be used for `repr()` and `str()` methods. The examples below demonstrate both\nways of using `Secret` to create a new secret type.\n\n1. Directly parametrizing `Secret` with a type:\n\n```python\nfrom pydantic import BaseModel, Secret\n\nSecretBool = Secret[bool]\n\nclass Model(BaseModel):\n    secret_bool: SecretBool\n\nm = Model(secret_bool=True)\nprint(m.model_dump())\n#> {'secret_bool': Secret('**********')}\n\nprint(m.model_dump_json())\n#> {\"secret_bool\":\"**********\"}\n\nprint(m.secret_bool.get_secret_value())\n#> True\n```\n\n2. Subclassing from parametrized `Secret`:\n\n```python\nfrom datetime import date\n\nfrom pydantic import BaseModel, Secret\n\nclass SecretDate(Secret[date]):\n    def _display(self) -> str:\n        return '****/**/**'\n\nclass Model(BaseModel):\n    secret_date: SecretDate\n\nm = Model(secret_date=date(2022, 1, 1))\nprint(m.model_dump())\n#> {'secret_date': SecretDate('****/**/**')}\n\nprint(m.model_dump_json())\n#> {\"secret_date\":\"****/**/**\"}\n\nprint(m.secret_date.get_secret_value())\n#> 2022-01-01\n```\n\nThe value returned by the `_display` method will be used for `repr()` and `str()`.\n\nYou can enforce constraints on the underlying type through annotations:\nFor example:\n\n```python\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, Secret, ValidationError\n\nSecretPosInt = Secret[Annotated[int, Field(gt=0, strict=True)]]\n\nclass Model(BaseModel):\n    sensitive_int: SecretPosInt\n\nm = Model(sensitive_int=42)\nprint(m.model_dump())\n#> {'sensitive_int': Secret('**********')}\n\ntry:\n    m = Model(sensitive_int=-42)  # (1)!\nexcept ValidationError as exc_info:\n    print(exc_info.errors(include_url=False, include_input=False))\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('sensitive_int',),\n            'msg': 'Input should be greater than 0',\n            'ctx': {'gt': 0},\n        }\n    ]\n    '''\n\ntry:\n    m = Model(sensitive_int='42')  # (2)!\nexcept ValidationError as exc_info:\n    print(exc_info.errors(include_url=False, include_input=False))\n    '''\n    [\n        {\n            'type': 'int_type',\n            'loc': ('sensitive_int',),\n            'msg': 'Input should be a valid integer',\n        }\n    ]\n    '''\n```\n\n1. The input value is not greater than 0, so it raises a validation error.\n2. The input value is not an integer, so it raises a validation error because the `SecretPosInt` type has strict mode enabled.",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, secret_value: 'SecretType') -> 'None'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "_display",
              "doc": null,
              "signature": "(self) -> 'str | bytes'"
            },
            {
              "name": "get_secret_value",
              "doc": "Get the secret value.\n\nReturns:\n    The secret value.",
              "signature": "(self) -> 'SecretType'"
            }
          ]
        },
        {
          "name": "SecretBytes",
          "doc": "A bytes used for storing sensitive information that you do not want to be visible in logging or tracebacks.\n\nIt displays `b'**********'` instead of the string value on `repr()` and `str()` calls.\nWhen the secret value is nonempty, it is displayed as `b'**********'` instead of the underlying value in\ncalls to `repr()` and `str()`. If the value _is_ empty, it is displayed as `b''`.\n\n```python\nfrom pydantic import BaseModel, SecretBytes\n\nclass User(BaseModel):\n    username: str\n    password: SecretBytes\n\nuser = User(username='scolvin', password=b'password1')\n#> username='scolvin' password=SecretBytes(b'**********')\nprint(user.password.get_secret_value())\n#> b'password1'\nprint((SecretBytes(b'password'), SecretBytes(b'')))\n#> (SecretBytes(b'**********'), SecretBytes(b''))\n```",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, secret_value: 'SecretType') -> 'None'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "_display",
              "doc": null,
              "signature": "(self) -> 'bytes'"
            },
            {
              "name": "get_secret_value",
              "doc": "Get the secret value.\n\nReturns:\n    The secret value.",
              "signature": "(self) -> 'SecretType'"
            }
          ]
        },
        {
          "name": "SecretStr",
          "doc": "A string used for storing sensitive information that you do not want to be visible in logging or tracebacks.\n\nWhen the secret value is nonempty, it is displayed as `'**********'` instead of the underlying value in\ncalls to `repr()` and `str()`. If the value _is_ empty, it is displayed as `''`.\n\n```python\nfrom pydantic import BaseModel, SecretStr\n\nclass User(BaseModel):\n    username: str\n    password: SecretStr\n\nuser = User(username='scolvin', password='password1')\n\nprint(user)\n#> username='scolvin' password=SecretStr('**********')\nprint(user.password.get_secret_value())\n#> password1\nprint((SecretStr('password'), SecretStr('')))\n#> (SecretStr('**********'), SecretStr(''))\n```\n\nAs seen above, by default, [`SecretStr`][pydantic.types.SecretStr] (and [`SecretBytes`][pydantic.types.SecretBytes])\nwill be serialized as `**********` when serializing to json.\n\nYou can use the [`field_serializer`][pydantic.functional_serializers.field_serializer] to dump the\nsecret as plain-text when serializing to json.\n\n```python\nfrom pydantic import BaseModel, SecretBytes, SecretStr, field_serializer\n\nclass Model(BaseModel):\n    password: SecretStr\n    password_bytes: SecretBytes\n\n    @field_serializer('password', 'password_bytes', when_used='json')\n    def dump_secret(self, v):\n        return v.get_secret_value()\n\nmodel = Model(password='IAmSensitive', password_bytes=b'IAmSensitiveBytes')\nprint(model)\n#> password=SecretStr('**********') password_bytes=SecretBytes(b'**********')\nprint(model.password)\n#> **********\nprint(model.model_dump())\n'''\n{\n    'password': SecretStr('**********'),\n    'password_bytes': SecretBytes(b'**********'),\n}\n'''\nprint(model.model_dump_json())\n#> {\"password\":\"IAmSensitive\",\"password_bytes\":\"IAmSensitiveBytes\"}\n```",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, secret_value: 'SecretType') -> 'None'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "_display",
              "doc": null,
              "signature": "(self) -> 'str'"
            },
            {
              "name": "get_secret_value",
              "doc": "Get the secret value.\n\nReturns:\n    The secret value.",
              "signature": "(self) -> 'SecretType'"
            }
          ]
        },
        {
          "name": "SerializationInfo",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": [
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "mode_is_json",
              "doc": null,
              "signature": "(self) -> 'bool'"
            }
          ]
        },
        {
          "name": "SerializeAsAny",
          "doc": "SerializeAsAny()",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_core_schema__",
              "doc": null,
              "signature": "(self, source_type: 'Any', handler: 'GetCoreSchemaHandler') -> 'core_schema.CoreSchema'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "SerializerFunctionWrapHandler",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": [
            {
              "name": "__call__",
              "doc": "Call self as a function.",
              "signature": "(self, input_value: 'Any', index_key: 'int | str | None' = None, /) -> 'Any'"
            }
          ]
        },
        {
          "name": "SkipValidation",
          "doc": "If this is applied as an annotation (e.g., via `x: Annotated[int, SkipValidation]`), validation will be\n    skipped. You can also use `SkipValidation[int]` as a shorthand for `Annotated[int, SkipValidation]`.\n\nThis can be useful if you want to use a type annotation for documentation/IDE/type-checking purposes,\nand know that it is safe to skip validation for one or more of the fields.\n\nBecause this converts the validation schema to `any_schema`, subsequent annotation-applied transformations\nmay not have the expected effects. Therefore, when used, this annotation should generally be the final\nannotation applied to a type.",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "SnowflakeDsn",
          "doc": "A type that will accept any Snowflake DSN.\n\n* User info required\n* TLD not required\n* Host required",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "Strict",
          "doc": "!!! abstract \"Usage Documentation\"\n    [Strict Mode with `Annotated` `Strict`](../concepts/strict_mode.md#strict-mode-with-annotated-strict)\n\nA field metadata class to indicate that a field should be validated in strict mode.\nUse this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\nAttributes:\n    strict: Whether to validate the field in strict mode.\n\nExample:\n    ```python\n    from typing import Annotated\n\n    from pydantic.types import Strict\n\n    StrictBool = Annotated[bool, Strict()]\n    ```",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, strict: 'bool' = True) -> None"
            },
            {
              "name": "__pretty__",
              "doc": "Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.",
              "signature": "(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__repr_args__",
              "doc": "Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.\n\nCan either return:\n* name - value pairs, e.g.: `[('foo_name', 'foo'), ('bar_name', ['b', 'a', 'r'])]`\n* or, just values, e.g.: `[(None, 'foo'), (None, ['b', 'a', 'r'])]`",
              "signature": "(self) -> 'ReprArgs'"
            },
            {
              "name": "__repr_name__",
              "doc": "Name of the instance's class, used in __repr__.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__repr_recursion__",
              "doc": "Returns the string representation of a recursive object.",
              "signature": "(self, object: 'Any') -> 'str'"
            },
            {
              "name": "__repr_str__",
              "doc": null,
              "signature": "(self, join_str: 'str') -> 'str'"
            },
            {
              "name": "__rich_repr__",
              "doc": "Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.",
              "signature": "(self) -> 'RichReprResult'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "StringConstraints",
          "doc": "!!! abstract \"Usage Documentation\"\n    [`StringConstraints`](../concepts/fields.md#string-constraints)\n\nA field metadata class to apply constraints to `str` types.\nUse this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\nAttributes:\n    strip_whitespace: Whether to remove leading and trailing whitespace.\n    to_upper: Whether to convert the string to uppercase.\n    to_lower: Whether to convert the string to lowercase.\n    strict: Whether to validate the string in strict mode.\n    min_length: The minimum length of the string.\n    max_length: The maximum length of the string.\n    pattern: A regex pattern that the string must match.\n\nExample:\n    ```python\n    from typing import Annotated\n\n    from pydantic.types import StringConstraints\n\n    ConstrainedStr = Annotated[str, StringConstraints(min_length=1, max_length=10)]\n    ```",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, strip_whitespace: 'bool | None' = None, to_upper: 'bool | None' = None, to_lower: 'bool | None' = None, strict: 'bool | None' = None, min_length: 'int | None' = None, max_length: 'int | None' = None, pattern: 'str | Pattern[str] | None' = None) -> None"
            },
            {
              "name": "__iter__",
              "doc": null,
              "signature": "(self) -> 'Iterator[BaseMetadata]'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "Tag",
          "doc": "Provides a way to specify the expected tag to use for a case of a (callable) discriminated union.\n\nAlso provides a way to label a union case in error messages.\n\nWhen using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that\nshould be used to identify that case. For example, in the below example, the `Tag` is used to specify that\nif `get_discriminator_value` returns `'apple'`, the input should be validated as an `ApplePie`, and if it\nreturns `'pumpkin'`, the input should be validated as a `PumpkinPie`.\n\nThe primary role of the `Tag` here is to map the return value from the callable `Discriminator` function to\nthe appropriate member of the `Union` in question.\n\n```python\nfrom typing import Annotated, Any, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\ndef get_discriminator_value(v: Any) -> str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        Union[\n            Annotated[ApplePie, Tag('apple')],\n            Annotated[PumpkinPie, Tag('pumpkin')],\n        ],\n        Discriminator(get_discriminator_value),\n    ]\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n'''\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n'''\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n'''\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n'''\n```\n\n!!! note\n    You must specify a `Tag` for every case in a `Tag` that is associated with a\n    callable `Discriminator`. Failing to do so will result in a `PydanticUserError` with code\n    [`callable-discriminator-no-tag`](../errors/usage_errors.md#callable-discriminator-no-tag).\n\nSee the [Discriminated Unions] concepts docs for more details on how to use `Tag`s.\n\n[Discriminated Unions]: ../concepts/unions.md#discriminated-unions",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_core_schema__",
              "doc": null,
              "signature": "(self, source_type: 'Any', handler: 'GetCoreSchemaHandler') -> 'CoreSchema'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, tag: 'str') -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "TypeAdapter",
          "doc": "!!! abstract \"Usage Documentation\"\n    [`TypeAdapter`](../concepts/type_adapter.md)\n\nType adapters provide a flexible way to perform validation and serialization based on a Python type.\n\nA `TypeAdapter` instance exposes some of the functionality from `BaseModel` instance methods\nfor types that do not have such methods (such as dataclasses, primitive types, and more).\n\n**Note:** `TypeAdapter` instances are not types, and cannot be used as type annotations for fields.\n\nArgs:\n    type: The type associated with the `TypeAdapter`.\n    config: Configuration for the `TypeAdapter`, should be a dictionary conforming to\n        [`ConfigDict`][pydantic.config.ConfigDict].\n\n        !!! note\n            You cannot provide a configuration when instantiating a `TypeAdapter` if the type you're using\n            has its own config that cannot be overridden (ex: `BaseModel`, `TypedDict`, and `dataclass`). A\n            [`type-adapter-config-unused`](../errors/usage_errors.md#type-adapter-config-unused) error will\n            be raised in this case.\n    _parent_depth: Depth at which to search for the [parent frame][frame-objects]. This frame is used when\n        resolving forward annotations during schema building, by looking for the globals and locals of this\n        frame. Defaults to 2, which will result in the frame where the `TypeAdapter` was instantiated.\n\n        !!! note\n            This parameter is named with an underscore to suggest its private nature and discourage use.\n            It may be deprecated in a minor version, so we only recommend using it if you're comfortable\n            with potential change in behavior/support. It's default value is 2 because internally,\n            the `TypeAdapter` class makes another call to fetch the frame.\n    module: The module that passes to plugin if provided.\n\nAttributes:\n    core_schema: The core schema for the type.\n    validator: The schema validator for the type.\n    serializer: The schema serializer for the type.\n    pydantic_complete: Whether the core schema for the type is successfully built.\n\n??? tip \"Compatibility with `mypy`\"\n    Depending on the type used, `mypy` might raise an error when instantiating a `TypeAdapter`. As a workaround, you can explicitly\n    annotate your variable:\n\n    ```py\n    from typing import Union\n\n    from pydantic import TypeAdapter\n\n    ta: TypeAdapter[Union[str, int]] = TypeAdapter(Union[str, int])  # type: ignore[arg-type]\n    ```\n\n??? info \"Namespace management nuances and implementation details\"\n\n    Here, we collect some notes on namespace management, and subtle differences from `BaseModel`:\n\n    `BaseModel` uses its own `__module__` to find out where it was defined\n    and then looks for symbols to resolve forward references in those globals.\n    On the other hand, `TypeAdapter` can be initialized with arbitrary objects,\n    which may not be types and thus do not have a `__module__` available.\n    So instead we look at the globals in our parent stack frame.\n\n    It is expected that the `ns_resolver` passed to this function will have the correct\n    namespace for the type we're adapting. See the source code for `TypeAdapter.__init__`\n    and `TypeAdapter.rebuild` for various ways to construct this namespace.\n\n    This works for the case where this function is called in a module that\n    has the target of forward references in its scope, but\n    does not always work for more complex cases.\n\n    For example, take the following:\n\n    ```python {title=\"a.py\"}\n    IntList = list[int]\n    OuterDict = dict[str, 'IntList']\n    ```\n\n    ```python {test=\"skip\" title=\"b.py\"}\n    from a import OuterDict\n\n    from pydantic import TypeAdapter\n\n    IntList = int  # replaces the symbol the forward reference is looking for\n    v = TypeAdapter(OuterDict)\n    v({'x': 1})  # should fail but doesn't\n    ```\n\n    If `OuterDict` were a `BaseModel`, this would work because it would resolve\n    the forward reference within the `a.py` namespace.\n    But `TypeAdapter(OuterDict)` can't determine what module `OuterDict` came from.\n\n    In other words, the assumption that _all_ forward references exist in the\n    module we are being called from is not technically always true.\n    Although most of the time it is and it works fine for recursive models and such,\n    `BaseModel`'s behavior isn't perfect either and _can_ break in similar ways,\n    so there is no right or wrong between the two.\n\n    But at the very least this behavior is _subtly_ different from `BaseModel`'s.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, type: 'Any', *, config: 'ConfigDict | None' = None, _parent_depth: 'int' = 2, module: 'str | None' = None) -> 'None'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "_fetch_parent_frame",
              "doc": null,
              "signature": "(self) -> 'FrameType | None'"
            },
            {
              "name": "_init_core_attrs",
              "doc": "Initialize the core schema, validator, and serializer for the type.\n\nArgs:\n    ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n    force: Whether to force the construction of the core schema, validator, and serializer.\n        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n    raise_errors: Whether to raise errors if initializing any of the core attrs fails.\n\nReturns:\n    `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n\nRaises:\n    PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n        and `raise_errors=True`.",
              "signature": "(self, ns_resolver: '_namespace_utils.NsResolver', force: 'bool', raise_errors: 'bool' = False) -> 'bool'"
            },
            {
              "name": "dump_json",
              "doc": "!!! abstract \"Usage Documentation\"\n    [JSON Serialization](../concepts/json.md#json-serialization)\n\nSerialize an instance of the adapted type to JSON.\n\nArgs:\n    instance: The instance to be serialized.\n    indent: Number of spaces for JSON indentation.\n    include: Fields to include.\n    exclude: Fields to exclude.\n    by_alias: Whether to use alias names for field names.\n    exclude_unset: Whether to exclude unset fields.\n    exclude_defaults: Whether to exclude fields with default values.\n    exclude_none: Whether to exclude fields with a value of `None`.\n    round_trip: Whether to serialize and deserialize the instance to ensure round-tripping.\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    fallback: A function to call when an unknown value is encountered. If not provided,\n        a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n    context: Additional context to pass to the serializer.\n\nReturns:\n    The JSON representation of the given instance as bytes.",
              "signature": "(self, instance: 'T', /, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False, context: 'dict[str, Any] | None' = None) -> 'bytes'"
            },
            {
              "name": "dump_python",
              "doc": "Dump an instance of the adapted type to a Python object.\n\nArgs:\n    instance: The Python object to serialize.\n    mode: The output format.\n    include: Fields to include in the output.\n    exclude: Fields to exclude from the output.\n    by_alias: Whether to use alias names for field names.\n    exclude_unset: Whether to exclude unset fields.\n    exclude_defaults: Whether to exclude fields with default values.\n    exclude_none: Whether to exclude fields with None values.\n    round_trip: Whether to output the serialized data in a way that is compatible with deserialization.\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    fallback: A function to call when an unknown value is encountered. If not provided,\n        a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n    context: Additional context to pass to the serializer.\n\nReturns:\n    The serialized object.",
              "signature": "(self, instance: 'T', /, *, mode: \"Literal['json', 'python']\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False, context: 'dict[str, Any] | None' = None) -> 'Any'"
            },
            {
              "name": "get_default_value",
              "doc": "Get the default value for the wrapped type.\n\nArgs:\n    strict: Whether to strictly check types.\n    context: Additional context to pass to the validator.\n\nReturns:\n    The default value wrapped in a `Some` if there is one or None if not.",
              "signature": "(self, *, strict: 'bool | None' = None, context: 'dict[str, Any] | None' = None) -> 'Some[T] | None'"
            },
            {
              "name": "json_schema",
              "doc": "Generate a JSON schema for the adapted type.\n\nArgs:\n    by_alias: Whether to use alias names for field names.\n    ref_template: The format string used for generating $ref strings.\n    schema_generator: The generator class used for creating the schema.\n    mode: The mode to use for schema generation.\n\nReturns:\n    The JSON schema for the model as a dictionary.",
              "signature": "(self, *, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'"
            },
            {
              "name": "json_schemas",
              "doc": "Generate a JSON schema including definitions from multiple type adapters.\n\nArgs:\n    inputs: Inputs to schema generation. The first two items will form the keys of the (first)\n        output mapping; the type adapters will provide the core schemas that get converted into\n        definitions in the output JSON schema.\n    by_alias: Whether to use alias names.\n    title: The title for the schema.\n    description: The description for the schema.\n    ref_template: The format string used for generating $ref strings.\n    schema_generator: The generator class used for creating the schema.\n\nReturns:\n    A tuple where:\n\n        - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and\n            whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have\n            JsonRef references to definitions that are defined in the second returned element.)\n        - The second element is a JSON schema containing all definitions referenced in the first returned\n            element, along with the optional title and description keys.",
              "signature": "(inputs: 'Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, TypeAdapter[Any]]]', /, *, by_alias: 'bool' = True, title: 'str | None' = None, description: 'str | None' = None, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>) -> 'tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]'"
            },
            {
              "name": "rebuild",
              "doc": "Try to rebuild the pydantic-core schema for the adapter's type.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the type adapter's schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: Depth at which to search for the [parent frame][frame-objects]. This\n        frame is used when resolving forward annotations during schema rebuilding, by looking for\n        the locals of this frame. Defaults to 2, which will result in the frame where the method\n        was called.\n    _types_namespace: An explicit types namespace to use, instead of using the local namespace\n        from the parent frame. Defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(self, *, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: '_namespace_utils.MappingNamespace | None' = None) -> 'bool | None'"
            },
            {
              "name": "validate_json",
              "doc": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate a JSON string or bytes against the model.\n\nArgs:\n    data: The JSON data to validate against the model.\n    strict: Whether to strictly check types.\n    context: Additional context to use during validation.\n    experimental_allow_partial: **Experimental** whether to enable\n        [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.\n        * False / 'off': Default behavior, no partial validation.\n        * True / 'on': Enable partial validation.\n        * 'trailing-strings': Enable partial validation and allow trailing strings in the input.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated object.",
              "signature": "(self, data: 'str | bytes | bytearray', /, *, strict: 'bool | None' = None, context: 'dict[str, Any] | None' = None, experimental_allow_partial: \"bool | Literal['off', 'on', 'trailing-strings']\" = False, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'T'"
            },
            {
              "name": "validate_python",
              "doc": "Validate a Python object against the model.\n\nArgs:\n    object: The Python object to validate against the model.\n    strict: Whether to strictly check types.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    experimental_allow_partial: **Experimental** whether to enable\n        [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.\n        * False / 'off': Default behavior, no partial validation.\n        * True / 'on': Enable partial validation.\n        * 'trailing-strings': Enable partial validation and allow trailing strings in the input.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\n!!! note\n    When using `TypeAdapter` with a Pydantic `dataclass`, the use of the `from_attributes`\n    argument is not supported.\n\nReturns:\n    The validated object.",
              "signature": "(self, object: 'Any', /, *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'dict[str, Any] | None' = None, experimental_allow_partial: \"bool | Literal['off', 'on', 'trailing-strings']\" = False, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'T'"
            },
            {
              "name": "validate_strings",
              "doc": "Validate object contains string data against the model.\n\nArgs:\n    obj: The object contains string data to validate.\n    strict: Whether to strictly check types.\n    context: Additional context to use during validation.\n    experimental_allow_partial: **Experimental** whether to enable\n        [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.\n        * False / 'off': Default behavior, no partial validation.\n        * True / 'on': Enable partial validation.\n        * 'trailing-strings': Enable partial validation and allow trailing strings in the input.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated object.",
              "signature": "(self, obj: 'Any', /, *, strict: 'bool | None' = None, context: 'dict[str, Any] | None' = None, experimental_allow_partial: \"bool | Literal['off', 'on', 'trailing-strings']\" = False, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'T'"
            }
          ]
        },
        {
          "name": "UrlConstraints",
          "doc": "Url constraints.\n\nAttributes:\n    max_length: The maximum length of the url. Defaults to `None`.\n    allowed_schemes: The allowed schemes. Defaults to `None`.\n    host_required: Whether the host is required. Defaults to `None`.\n    default_host: The default host. Defaults to `None`.\n    default_port: The default port. Defaults to `None`.\n    default_path: The default path. Defaults to `None`.",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_core_schema__",
              "doc": null,
              "signature": "(self, source: 'Any', handler: 'GetCoreSchemaHandler') -> 'core_schema.CoreSchema'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, max_length: 'int | None' = None, allowed_schemes: 'list[str] | None' = None, host_required: 'bool | None' = None, default_host: 'str | None' = None, default_port: 'int | None' = None, default_path: 'str | None' = None) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "ValidationError",
          "doc": "",
          "functions": []
        },
        {
          "name": "ValidationInfo",
          "doc": "Argument passed to validation functions.",
          "functions": []
        },
        {
          "name": "ValidatorFunctionWrapHandler",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": [
            {
              "name": "__call__",
              "doc": "Call self as a function.",
              "signature": "(self, input_value: 'Any', outer_location: 'str | int | None' = None, /) -> 'Any'"
            }
          ]
        },
        {
          "name": "WebsocketUrl",
          "doc": "A type that will accept any ws or wss URL.\n\n* TLD not required\n* Host not required\n* Max length 2083",
          "functions": [
            {
              "name": "__deepcopy__",
              "doc": null,
              "signature": "(self, memo: 'dict') -> 'Self'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, url: 'str | _CoreUrl | _BaseUrl') -> 'None'"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "The URL as a string, this will punycode encode the host if required.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "encoded_string",
              "doc": "The URL's encoded string representation via __str__().\n\nThis returns the punycode-encoded host version of the URL as a string.",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "query_params",
              "doc": "The query part of the URL as a list of key-value pairs.\n\ne.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`",
              "signature": "(self) -> 'list[tuple[str, str]]'"
            },
            {
              "name": "unicode_host",
              "doc": "The host part of the URL as a unicode string, or `None`.\n\ne.g. `host` in `https://user:pass@host:port/path?query#fragment`\n\nIf the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_host()` will be `\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "unicode_string",
              "doc": "The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n\nIf the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n`unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "WithJsonSchema",
          "doc": "!!! abstract \"Usage Documentation\"\n    [`WithJsonSchema` Annotation](../concepts/json_schema.md#withjsonschema-annotation)\n\nAdd this as an annotation on a field to override the (base) JSON schema that would be generated for that field.\nThis provides a way to set a JSON schema for types that would otherwise raise errors when producing a JSON schema,\nsuch as Callable, or types that have an is-instance core schema, without needing to go so far as creating a\ncustom subclass of pydantic.json_schema.GenerateJsonSchema.\nNote that any _modifications_ to the schema that would normally be made (such as setting the title for model fields)\nwill still be performed.\n\nIf `mode` is set this will only apply to that schema generation mode, allowing you\nto set different json schemas for validation and serialization.",
          "functions": [
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_json_schema__",
              "doc": null,
              "signature": "(self, core_schema: 'core_schema.CoreSchema', handler: 'GetJsonSchemaHandler') -> 'JsonSchemaValue'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, json_schema: 'JsonSchemaValue | None', mode: \"Literal['validation', 'serialization'] | None\" = None) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "WrapSerializer",
          "doc": "Wrap serializers receive the raw inputs along with a handler function that applies the standard serialization\nlogic, and can modify the resulting value before returning it as the final output of serialization.\n\nFor example, here's a scenario in which a wrap serializer transforms timezones to UTC **and** utilizes the existing `datetime` serialization logic.\n\n```python\nfrom datetime import datetime, timezone\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, WrapSerializer\n\nclass EventDatetime(BaseModel):\n    start: datetime\n    end: datetime\n\ndef convert_to_utc(value: Any, handler, info) -> dict[str, datetime]:\n    # Note that `handler` can actually help serialize the `value` for\n    # further custom serialization in case it's a subclass.\n    partial_result = handler(value, info)\n    if info.mode == 'json':\n        return {\n            k: datetime.fromisoformat(v).astimezone(timezone.utc)\n            for k, v in partial_result.items()\n        }\n    return {k: v.astimezone(timezone.utc) for k, v in partial_result.items()}\n\nUTCEventDatetime = Annotated[EventDatetime, WrapSerializer(convert_to_utc)]\n\nclass EventModel(BaseModel):\n    event_datetime: UTCEventDatetime\n\ndt = EventDatetime(\n    start='2024-01-01T07:00:00-08:00', end='2024-01-03T20:00:00+06:00'\n)\nevent = EventModel(event_datetime=dt)\nprint(event.model_dump())\n'''\n{\n    'event_datetime': {\n        'start': datetime.datetime(\n            2024, 1, 1, 15, 0, tzinfo=datetime.timezone.utc\n        ),\n        'end': datetime.datetime(\n            2024, 1, 3, 14, 0, tzinfo=datetime.timezone.utc\n        ),\n    }\n}\n'''\n\nprint(event.model_dump_json())\n'''\n{\"event_datetime\":{\"start\":\"2024-01-01T15:00:00Z\",\"end\":\"2024-01-03T14:00:00Z\"}}\n'''\n```\n\nAttributes:\n    func: The serializer function to be wrapped.\n    return_type: The return type for the function. If omitted it will be inferred from the type annotation.\n    when_used: Determines when this serializer should be used. Accepts a string with values `'always'`,\n        `'unless-none'`, `'json'`, and `'json-unless-none'`. Defaults to 'always'.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_core_schema__",
              "doc": "This method is used to get the Pydantic core schema of the class.\n\nArgs:\n    source_type: Source type.\n    handler: Core schema handler.\n\nReturns:\n    The generated core schema of the class.",
              "signature": "(self, source_type: 'Any', handler: 'GetCoreSchemaHandler') -> 'core_schema.CoreSchema'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, func: 'core_schema.WrapSerializerFunction', return_type: 'Any' = PydanticUndefined, when_used: 'WhenUsed' = 'always') -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "WrapValidator",
          "doc": "!!! abstract \"Usage Documentation\"\n    [field *wrap* validators](../concepts/validators.md#field-wrap-validator)\n\nA metadata class that indicates that a validation should be applied **around** the inner validation logic.\n\nAttributes:\n    func: The validator function.\n    json_schema_input_type: The input type of the function. This is only used to generate the appropriate\n        JSON Schema (in validation mode).\n\n```python\nfrom datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, ValidationError, WrapValidator\n\ndef validate_timestamp(v, handler):\n    if v == 'now':\n        # we don't want to bother with further validation, just return the new value\n        return datetime.now()\n    try:\n        return handler(v)\n    except ValidationError:\n        # validation failed, in this case we want to return a default value\n        return datetime(2000, 1, 1)\n\nMyTimestamp = Annotated[datetime, WrapValidator(validate_timestamp)]\n\nclass Model(BaseModel):\n    a: MyTimestamp\n\nprint(Model(a='now').a)\n#> 2032-01-02 03:04:05.000006\nprint(Model(a='invalid').a)\n#> 2000-01-01 00:00:00\n```",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__get_pydantic_core_schema__",
              "doc": null,
              "signature": "(self, source_type: 'Any', handler: 'GetCoreSchemaHandler') -> 'core_schema.CoreSchema'"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, func: 'core_schema.NoInfoWrapValidatorFunction | core_schema.WithInfoWrapValidatorFunction', json_schema_input_type: 'Any' = PydanticUndefined) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        }
      ]
    }
  },
  {
    "package": "numpy",
    "base": {
      "functions": [
        {
          "name": "__dir__",
          "doc": null,
          "signature": "()"
        },
        {
          "name": "__getattr__",
          "doc": null,
          "signature": "(attr)"
        },
        {
          "name": "_pyinstaller_hooks_dir",
          "doc": null,
          "signature": "()"
        },
        {
          "name": "asarray_chkfinite",
          "doc": "Convert the input to an array, checking for NaNs or Infs.\n\nParameters\n----------\na : array_like\n    Input data, in any form that can be converted to an array.  This\n    includes lists, lists of tuples, tuples, tuples of tuples, tuples\n    of lists and ndarrays.  Success requires no NaNs or Infs.\ndtype : data-type, optional\n    By default, the data-type is inferred from the input data.\norder : {'C', 'F', 'A', 'K'}, optional\n    Memory layout.  'A' and 'K' depend on the order of input array a.\n    'C' row-major (C-style),\n    'F' column-major (Fortran-style) memory representation.\n    'A' (any) means 'F' if `a` is Fortran contiguous, 'C' otherwise\n    'K' (keep) preserve input order\n    Defaults to 'C'.\n\nReturns\n-------\nout : ndarray\n    Array interpretation of `a`.  No copy is performed if the input\n    is already an ndarray.  If `a` is a subclass of ndarray, a base\n    class ndarray is returned.\n\nRaises\n------\nValueError\n    Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).\n\nSee Also\n--------\nasarray : Create and array.\nasanyarray : Similar function which passes through subclasses.\nascontiguousarray : Convert input to a contiguous array.\nasfortranarray : Convert input to an ndarray with column-major\n                 memory order.\nfromiter : Create an array from an iterator.\nfromfunction : Construct an array by executing a function on grid\n               positions.\n\nExamples\n--------\n>>> import numpy as np\n\nConvert a list into an array. If all elements are finite, then\n``asarray_chkfinite`` is identical to ``asarray``.\n\n>>> a = [1, 2]\n>>> np.asarray_chkfinite(a, dtype=float)\narray([1., 2.])\n\nRaises ValueError if array_like contains Nans or Infs.\n\n>>> a = [1, 2, np.inf]\n>>> try:\n...     np.asarray_chkfinite(a)\n... except ValueError:\n...     print('ValueError')\n...\nValueError",
          "signature": "(a, dtype=None, order=None)"
        },
        {
          "name": "asmatrix",
          "doc": "Interpret the input as a matrix.\n\nUnlike `matrix`, `asmatrix` does not make a copy if the input is already\na matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.\n\nParameters\n----------\ndata : array_like\n    Input data.\ndtype : data-type\n   Data-type of the output matrix.\n\nReturns\n-------\nmat : matrix\n    `data` interpreted as a matrix.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.array([[1, 2], [3, 4]])\n\n>>> m = np.asmatrix(x)\n\n>>> x[0,0] = 5\n\n>>> m\nmatrix([[5, 2],\n        [3, 4]])",
          "signature": "(data, dtype=None)"
        },
        {
          "name": "bartlett",
          "doc": "Return the Bartlett window.\n\nThe Bartlett window is very similar to a triangular window, except\nthat the end points are at zero.  It is often used in signal\nprocessing for tapering a signal, without generating too much\nripple in the frequency domain.\n\nParameters\n----------\nM : int\n    Number of points in the output window. If zero or less, an\n    empty array is returned.\n\nReturns\n-------\nout : array\n    The triangular window, with the maximum value normalized to one\n    (the value one appears only if the number of samples is odd), with\n    the first and last samples equal to zero.\n\nSee Also\n--------\nblackman, hamming, hanning, kaiser\n\nNotes\n-----\nThe Bartlett window is defined as\n\n.. math:: w(n) = \\frac{2}{M-1} \\left(\n          \\frac{M-1}{2} - \\left|n - \\frac{M-1}{2}\\right|\n          \\right)\n\nMost references to the Bartlett window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  Note that convolution with this window produces linear\ninterpolation.  It is also known as an apodization (which means \"removing\nthe foot\", i.e. smoothing discontinuities at the beginning and end of the\nsampled signal) or tapering function. The Fourier transform of the\nBartlett window is the product of two sinc functions. Note the excellent\ndiscussion in Kanasewich [2]_.\n\nReferences\n----------\n.. [1] M.S. Bartlett, \"Periodogram Analysis and Continuous Spectra\",\n       Biometrika 37, 1-16, 1950.\n.. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n       The University of Alberta Press, 1975, pp. 109-110.\n.. [3] A.V. Oppenheim and R.W. Schafer, \"Discrete-Time Signal\n       Processing\", Prentice-Hall, 1999, pp. 468-471.\n.. [4] Wikipedia, \"Window function\",\n       https://en.wikipedia.org/wiki/Window_function\n.. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n       \"Numerical Recipes\", Cambridge University Press, 1986, page 429.\n\nExamples\n--------\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> np.bartlett(12)\narray([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary\n        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n        0.18181818,  0.        ])\n\nPlot the window and its frequency response (requires SciPy and matplotlib).\n\n.. plot::\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from numpy.fft import fft, fftshift\n    window = np.bartlett(51)\n    plt.plot(window)\n    plt.title(\"Bartlett window\")\n    plt.ylabel(\"Amplitude\")\n    plt.xlabel(\"Sample\")\n    plt.show()\n    plt.figure()\n    A = fft(window, 2048) / 25.5\n    mag = np.abs(fftshift(A))\n    freq = np.linspace(-0.5, 0.5, len(A))\n    with np.errstate(divide='ignore', invalid='ignore'):\n        response = 20 * np.log10(mag)\n    response = np.clip(response, -100, 100)\n    plt.plot(freq, response)\n    plt.title(\"Frequency response of Bartlett window\")\n    plt.ylabel(\"Magnitude [dB]\")\n    plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    plt.axis('tight')\n    plt.show()",
          "signature": "(M)"
        },
        {
          "name": "base_repr",
          "doc": "Return a string representation of a number in the given base system.\n\nParameters\n----------\nnumber : int\n    The value to convert. Positive and negative values are handled.\nbase : int, optional\n    Convert `number` to the `base` number system. The valid range is 2-36,\n    the default value is 2.\npadding : int, optional\n    Number of zeros padded on the left. Default is 0 (no padding).\n\nReturns\n-------\nout : str\n    String representation of `number` in `base` system.\n\nSee Also\n--------\nbinary_repr : Faster version of `base_repr` for base 2.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.base_repr(5)\n'101'\n>>> np.base_repr(6, 5)\n'11'\n>>> np.base_repr(7, base=5, padding=3)\n'00012'\n\n>>> np.base_repr(10, base=16)\n'A'\n>>> np.base_repr(32, base=16)\n'20'",
          "signature": "(number, base=2, padding=0)"
        },
        {
          "name": "binary_repr",
          "doc": "Return the binary representation of the input number as a string.\n\nFor negative numbers, if width is not given, a minus sign is added to the\nfront. If width is given, the two's complement of the number is\nreturned, with respect to that width.\n\nIn a two's-complement system negative numbers are represented by the two's\ncomplement of the absolute value. This is the most common method of\nrepresenting signed integers on computers [1]_. A N-bit two's-complement\nsystem can represent every integer in the range\n:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\nParameters\n----------\nnum : int\n    Only an integer decimal number can be used.\nwidth : int, optional\n    The length of the returned string if `num` is positive, or the length\n    of the two's complement if `num` is negative, provided that `width` is\n    at least a sufficient number of bits for `num` to be represented in\n    the designated form. If the `width` value is insufficient, an error is\n    raised.\n\nReturns\n-------\nbin : str\n    Binary representation of `num` or two's complement of `num`.\n\nSee Also\n--------\nbase_repr: Return a string representation of a number in the given base\n           system.\nbin: Python's built-in binary representation generator of an integer.\n\nNotes\n-----\n`binary_repr` is equivalent to using `base_repr` with base 2, but about 25x\nfaster.\n\nReferences\n----------\n.. [1] Wikipedia, \"Two's complement\",\n    https://en.wikipedia.org/wiki/Two's_complement\n\nExamples\n--------\n>>> import numpy as np\n>>> np.binary_repr(3)\n'11'\n>>> np.binary_repr(-3)\n'-11'\n>>> np.binary_repr(3, width=4)\n'0011'\n\nThe two's complement is returned when the input number is negative and\nwidth is specified:\n\n>>> np.binary_repr(-3, width=3)\n'101'\n>>> np.binary_repr(-3, width=5)\n'11101'",
          "signature": "(num, width=None)"
        },
        {
          "name": "blackman",
          "doc": "Return the Blackman window.\n\nThe Blackman window is a taper formed by using the first three\nterms of a summation of cosines. It was designed to have close to the\nminimal leakage possible.  It is close to optimal, only slightly worse\nthan a Kaiser window.\n\nParameters\n----------\nM : int\n    Number of points in the output window. If zero or less, an empty\n    array is returned.\n\nReturns\n-------\nout : ndarray\n    The window, with the maximum value normalized to one (the value one\n    appears only if the number of samples is odd).\n\nSee Also\n--------\nbartlett, hamming, hanning, kaiser\n\nNotes\n-----\nThe Blackman window is defined as\n\n.. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)\n\nMost references to the Blackman window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  It is also known as an apodization (which means\n\"removing the foot\", i.e. smoothing discontinuities at the beginning\nand end of the sampled signal) or tapering function. It is known as a\n\"near optimal\" tapering function, almost as good (by some measures)\nas the kaiser window.\n\nReferences\n----------\nBlackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,\nDover Publications, New York.\n\nOppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.\nUpper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.\n\nExamples\n--------\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> np.blackman(12)\narray([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary\n        4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n        9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n        1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])\n\nPlot the window and the frequency response.\n\n.. plot::\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from numpy.fft import fft, fftshift\n    window = np.blackman(51)\n    plt.plot(window)\n    plt.title(\"Blackman window\")\n    plt.ylabel(\"Amplitude\")\n    plt.xlabel(\"Sample\")\n    plt.show()  # doctest: +SKIP\n\n    plt.figure()\n    A = fft(window, 2048) / 25.5\n    mag = np.abs(fftshift(A))\n    freq = np.linspace(-0.5, 0.5, len(A))\n    with np.errstate(divide='ignore', invalid='ignore'):\n        response = 20 * np.log10(mag)\n    response = np.clip(response, -100, 100)\n    plt.plot(freq, response)\n    plt.title(\"Frequency response of Blackman window\")\n    plt.ylabel(\"Magnitude [dB]\")\n    plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    plt.axis('tight')\n    plt.show()",
          "signature": "(M)"
        },
        {
          "name": "bmat",
          "doc": "Build a matrix object from a string, nested sequence, or array.\n\nParameters\n----------\nobj : str or array_like\n    Input data. If a string, variables in the current scope may be\n    referenced by name.\nldict : dict, optional\n    A dictionary that replaces local operands in current frame.\n    Ignored if `obj` is not a string or `gdict` is None.\ngdict : dict, optional\n    A dictionary that replaces global operands in current frame.\n    Ignored if `obj` is not a string.\n\nReturns\n-------\nout : matrix\n    Returns a matrix object, which is a specialized 2-D array.\n\nSee Also\n--------\nblock :\n    A generalization of this function for N-d arrays, that returns normal\n    ndarrays.\n\nExamples\n--------\n>>> import numpy as np\n>>> A = np.asmatrix('1 1; 1 1')\n>>> B = np.asmatrix('2 2; 2 2')\n>>> C = np.asmatrix('3 4; 5 6')\n>>> D = np.asmatrix('7 8; 9 0')\n\nAll the following expressions construct the same block matrix:\n\n>>> np.bmat([[A, B], [C, D]])\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n>>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n>>> np.bmat('A,B; C,D')\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])",
          "signature": "(obj, ldict=None, gdict=None)"
        },
        {
          "name": "broadcast_shapes",
          "doc": "Broadcast the input shapes into a single shape.\n\n:ref:`Learn more about broadcasting here <basics.broadcasting>`.\n\n.. versionadded:: 1.20.0\n\nParameters\n----------\n*args : tuples of ints, or ints\n    The shapes to be broadcast against each other.\n\nReturns\n-------\ntuple\n    Broadcasted shape.\n\nRaises\n------\nValueError\n    If the shapes are not compatible and cannot be broadcast according\n    to NumPy's broadcasting rules.\n\nSee Also\n--------\nbroadcast\nbroadcast_arrays\nbroadcast_to\n\nExamples\n--------\n>>> import numpy as np\n>>> np.broadcast_shapes((1, 2), (3, 1), (3, 2))\n(3, 2)\n\n>>> np.broadcast_shapes((6, 7), (5, 6, 1), (7,), (5, 1, 7))\n(5, 6, 7)",
          "signature": "(*args)"
        },
        {
          "name": "diag_indices",
          "doc": "Return the indices to access the main diagonal of an array.\n\nThis returns a tuple of indices that can be used to access the main\ndiagonal of an array `a` with ``a.ndim >= 2`` dimensions and shape\n(n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for\n``a.ndim > 2`` this is the set of indices to access ``a[i, i, ..., i]``\nfor ``i = [0..n-1]``.\n\nParameters\n----------\nn : int\n  The size, along each dimension, of the arrays for which the returned\n  indices can be used.\n\nndim : int, optional\n  The number of dimensions.\n\nSee Also\n--------\ndiag_indices_from\n\nExamples\n--------\n>>> import numpy as np\n\nCreate a set of indices to access the diagonal of a (4, 4) array:\n\n>>> di = np.diag_indices(4)\n>>> di\n(array([0, 1, 2, 3]), array([0, 1, 2, 3]))\n>>> a = np.arange(16).reshape(4, 4)\n>>> a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n>>> a[di] = 100\n>>> a\narray([[100,   1,   2,   3],\n       [  4, 100,   6,   7],\n       [  8,   9, 100,  11],\n       [ 12,  13,  14, 100]])\n\nNow, we create indices to manipulate a 3-D array:\n\n>>> d3 = np.diag_indices(2, 3)\n>>> d3\n(array([0, 1]), array([0, 1]), array([0, 1]))\n\nAnd use it to set the diagonal of an array of zeros to 1:\n\n>>> a = np.zeros((2, 2, 2), dtype=int)\n>>> a[d3] = 1\n>>> a\narray([[[1, 0],\n        [0, 0]],\n       [[0, 0],\n        [0, 1]]])",
          "signature": "(n, ndim=2)"
        },
        {
          "name": "eye",
          "doc": "Return a 2-D array with ones on the diagonal and zeros elsewhere.\n\nParameters\n----------\nN : int\n  Number of rows in the output.\nM : int, optional\n  Number of columns in the output. If None, defaults to `N`.\nk : int, optional\n  Index of the diagonal: 0 (the default) refers to the main diagonal,\n  a positive value refers to an upper diagonal, and a negative value\n  to a lower diagonal.\ndtype : data-type, optional\n  Data-type of the returned array.\norder : {'C', 'F'}, optional\n    Whether the output should be stored in row-major (C-style) or\n    column-major (Fortran-style) order in memory.\ndevice : str, optional\n    The device on which to place the created array. Default: None.\n    For Array-API interoperability only, so must be ``\"cpu\"`` if passed.\n\n    .. versionadded:: 2.0.0\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not\n    NumPy arrays. If an array-like passed in as ``like`` supports\n    the ``__array_function__`` protocol, the result will be defined\n    by it. In this case, it ensures the creation of an array object\n    compatible with that passed in via this argument.\n\n    .. versionadded:: 1.20.0\n\nReturns\n-------\nI : ndarray of shape (N,M)\n  An array where all elements are equal to zero, except for the `k`-th\n  diagonal, whose values are equal to one.\n\nSee Also\n--------\nidentity : (almost) equivalent function\ndiag : diagonal 2-D array from a 1-D array specified by the user.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.eye(2, dtype=int)\narray([[1, 0],\n       [0, 1]])\n>>> np.eye(3, k=1)\narray([[0.,  1.,  0.],\n       [0.,  0.,  1.],\n       [0.,  0.,  0.]])",
          "signature": "(N, M=None, k=0, dtype=<class 'float'>, order='C', *, device=None, like=None)"
        },
        {
          "name": "format_float_positional",
          "doc": "Format a floating-point scalar as a decimal string in positional notation.\n\nProvides control over rounding, trimming and padding. Uses and assumes\nIEEE unbiased rounding. Uses the \"Dragon4\" algorithm.\n\nParameters\n----------\nx : python float or numpy floating scalar\n    Value to format.\nprecision : non-negative integer or None, optional\n    Maximum number of digits to print. May be None if `unique` is\n    `True`, but must be an integer if unique is `False`.\nunique : boolean, optional\n    If `True`, use a digit-generation strategy which gives the shortest\n    representation which uniquely identifies the floating-point number from\n    other values of the same type, by judicious rounding. If `precision`\n    is given fewer digits than necessary can be printed, or if `min_digits`\n    is given more can be printed, in which cases the last digit is rounded\n    with unbiased rounding.\n    If `False`, digits are generated as if printing an infinite-precision\n    value and stopping after `precision` digits, rounding the remaining\n    value with unbiased rounding\nfractional : boolean, optional\n    If `True`, the cutoffs of `precision` and `min_digits` refer to the\n    total number of digits after the decimal point, including leading\n    zeros.\n    If `False`, `precision` and `min_digits` refer to the total number of\n    significant digits, before or after the decimal point, ignoring leading\n    zeros.\ntrim : one of 'k', '.', '0', '-', optional\n    Controls post-processing trimming of trailing digits, as follows:\n\n    * 'k' : keep trailing zeros, keep decimal point (no trimming)\n    * '.' : trim all trailing zeros, leave decimal point\n    * '0' : trim all but the zero before the decimal point. Insert the\n      zero if it is missing.\n    * '-' : trim trailing zeros and any trailing decimal point\nsign : boolean, optional\n    Whether to show the sign for positive values.\npad_left : non-negative integer, optional\n    Pad the left side of the string with whitespace until at least that\n    many characters are to the left of the decimal point.\npad_right : non-negative integer, optional\n    Pad the right side of the string with whitespace until at least that\n    many characters are to the right of the decimal point.\nmin_digits : non-negative integer or None, optional\n    Minimum number of digits to print. Only has an effect if `unique=True`\n    in which case additional digits past those necessary to uniquely\n    identify the value may be printed, rounding the last additional digit.\n\n    .. versionadded:: 1.21.0\n\nReturns\n-------\nrep : string\n    The string representation of the floating point value\n\nSee Also\n--------\nformat_float_scientific\n\nExamples\n--------\n>>> import numpy as np\n>>> np.format_float_positional(np.float32(np.pi))\n'3.1415927'\n>>> np.format_float_positional(np.float16(np.pi))\n'3.14'\n>>> np.format_float_positional(np.float16(0.3))\n'0.3'\n>>> np.format_float_positional(np.float16(0.3), unique=False, precision=10)\n'0.3000488281'",
          "signature": "(x, precision=None, unique=True, fractional=True, trim='k', sign=False, pad_left=None, pad_right=None, min_digits=None)"
        },
        {
          "name": "format_float_scientific",
          "doc": "Format a floating-point scalar as a decimal string in scientific notation.\n\nProvides control over rounding, trimming and padding. Uses and assumes\nIEEE unbiased rounding. Uses the \"Dragon4\" algorithm.\n\nParameters\n----------\nx : python float or numpy floating scalar\n    Value to format.\nprecision : non-negative integer or None, optional\n    Maximum number of digits to print. May be None if `unique` is\n    `True`, but must be an integer if unique is `False`.\nunique : boolean, optional\n    If `True`, use a digit-generation strategy which gives the shortest\n    representation which uniquely identifies the floating-point number from\n    other values of the same type, by judicious rounding. If `precision`\n    is given fewer digits than necessary can be printed. If `min_digits`\n    is given more can be printed, in which cases the last digit is rounded\n    with unbiased rounding.\n    If `False`, digits are generated as if printing an infinite-precision\n    value and stopping after `precision` digits, rounding the remaining\n    value with unbiased rounding\ntrim : one of 'k', '.', '0', '-', optional\n    Controls post-processing trimming of trailing digits, as follows:\n\n    * 'k' : keep trailing zeros, keep decimal point (no trimming)\n    * '.' : trim all trailing zeros, leave decimal point\n    * '0' : trim all but the zero before the decimal point. Insert the\n      zero if it is missing.\n    * '-' : trim trailing zeros and any trailing decimal point\nsign : boolean, optional\n    Whether to show the sign for positive values.\npad_left : non-negative integer, optional\n    Pad the left side of the string with whitespace until at least that\n    many characters are to the left of the decimal point.\nexp_digits : non-negative integer, optional\n    Pad the exponent with zeros until it contains at least this\n    many digits. If omitted, the exponent will be at least 2 digits.\nmin_digits : non-negative integer or None, optional\n    Minimum number of digits to print. This only has an effect for\n    `unique=True`. In that case more digits than necessary to uniquely\n    identify the value may be printed and rounded unbiased.\n\n    .. versionadded:: 1.21.0\n\nReturns\n-------\nrep : string\n    The string representation of the floating point value\n\nSee Also\n--------\nformat_float_positional\n\nExamples\n--------\n>>> import numpy as np\n>>> np.format_float_scientific(np.float32(np.pi))\n'3.1415927e+00'\n>>> s = np.float32(1.23e24)\n>>> np.format_float_scientific(s, unique=False, precision=15)\n'1.230000071797338e+24'\n>>> np.format_float_scientific(s, exp_digits=4)\n'1.23e+0024'",
          "signature": "(x, precision=None, unique=True, trim='k', sign=False, pad_left=None, exp_digits=None, min_digits=None)"
        },
        {
          "name": "fromfunction",
          "doc": "Construct an array by executing a function over each coordinate.\n\nThe resulting array therefore has a value ``fn(x, y, z)`` at\ncoordinate ``(x, y, z)``.\n\nParameters\n----------\nfunction : callable\n    The function is called with N parameters, where N is the rank of\n    `shape`.  Each parameter represents the coordinates of the array\n    varying along a specific axis.  For example, if `shape`\n    were ``(2, 2)``, then the parameters would be\n    ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``\nshape : (N,) tuple of ints\n    Shape of the output array, which also determines the shape of\n    the coordinate arrays passed to `function`.\ndtype : data-type, optional\n    Data-type of the coordinate arrays passed to `function`.\n    By default, `dtype` is float.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not\n    NumPy arrays. If an array-like passed in as ``like`` supports\n    the ``__array_function__`` protocol, the result will be defined\n    by it. In this case, it ensures the creation of an array object\n    compatible with that passed in via this argument.\n\n    .. versionadded:: 1.20.0\n\nReturns\n-------\nfromfunction : any\n    The result of the call to `function` is passed back directly.\n    Therefore the shape of `fromfunction` is completely determined by\n    `function`.  If `function` returns a scalar value, the shape of\n    `fromfunction` would not match the `shape` parameter.\n\nSee Also\n--------\nindices, meshgrid\n\nNotes\n-----\nKeywords other than `dtype` and `like` are passed to `function`.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.fromfunction(lambda i, j: i, (2, 2), dtype=float)\narray([[0., 0.],\n       [1., 1.]])\n\n>>> np.fromfunction(lambda i, j: j, (2, 2), dtype=float)\narray([[0., 1.],\n       [0., 1.]])\n\n>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]])\n\n>>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])",
          "signature": "(function, shape, *, dtype=<class 'float'>, like=None, **kwargs)"
        },
        {
          "name": "fromregex",
          "doc": "Construct an array from a text file, using regular expression parsing.\n\nThe returned array is always a structured array, and is constructed from\nall matches of the regular expression in the file. Groups in the regular\nexpression are converted to fields of the structured array.\n\nParameters\n----------\nfile : file, str, or pathlib.Path\n    Filename or file object to read.\n\n    .. versionchanged:: 1.22.0\n        Now accepts `os.PathLike` implementations.\n\nregexp : str or regexp\n    Regular expression used to parse the file.\n    Groups in the regular expression correspond to fields in the dtype.\ndtype : dtype or list of dtypes\n    Dtype for the structured array; must be a structured datatype.\nencoding : str, optional\n    Encoding used to decode the inputfile. Does not apply to input streams.\n\nReturns\n-------\noutput : ndarray\n    The output array, containing the part of the content of `file` that\n    was matched by `regexp`. `output` is always a structured array.\n\nRaises\n------\nTypeError\n    When `dtype` is not a valid dtype for a structured array.\n\nSee Also\n--------\nfromstring, loadtxt\n\nNotes\n-----\nDtypes for structured arrays can be specified in several forms, but all\nforms specify at least the data type and field name. For details see\n`basics.rec`.\n\nExamples\n--------\n>>> import numpy as np\n>>> from io import StringIO\n>>> text = StringIO(\"1312 foo\\n1534  bar\\n444   qux\")\n\n>>> regexp = r\"(\\d+)\\s+(...)\"  # match [digits, whitespace, anything]\n>>> output = np.fromregex(text, regexp,\n...                       [('num', np.int64), ('key', 'S3')])\n>>> output\narray([(1312, b'foo'), (1534, b'bar'), ( 444, b'qux')],\n      dtype=[('num', '<i8'), ('key', 'S3')])\n>>> output['num']\narray([1312, 1534,  444])",
          "signature": "(file, regexp, dtype, encoding=None)"
        },
        {
          "name": "full",
          "doc": "Return a new array of given shape and type, filled with `fill_value`.\n\nParameters\n----------\nshape : int or sequence of ints\n    Shape of the new array, e.g., ``(2, 3)`` or ``2``.\nfill_value : scalar or array_like\n    Fill value.\ndtype : data-type, optional\n    The desired data-type for the array  The default, None, means\n     ``np.array(fill_value).dtype``.\norder : {'C', 'F'}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous\n    (row- or column-wise) order in memory.\ndevice : str, optional\n    The device on which to place the created array. Default: None.\n    For Array-API interoperability only, so must be ``\"cpu\"`` if passed.\n\n    .. versionadded:: 2.0.0\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not\n    NumPy arrays. If an array-like passed in as ``like`` supports\n    the ``__array_function__`` protocol, the result will be defined\n    by it. In this case, it ensures the creation of an array object\n    compatible with that passed in via this argument.\n\n    .. versionadded:: 1.20.0\n\nReturns\n-------\nout : ndarray\n    Array of `fill_value` with the given shape, dtype, and order.\n\nSee Also\n--------\nfull_like : Return a new array with shape of input filled with value.\nempty : Return a new uninitialized array.\nones : Return a new array setting values to one.\nzeros : Return a new array setting values to zero.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.full((2, 2), np.inf)\narray([[inf, inf],\n       [inf, inf]])\n>>> np.full((2, 2), 10)\narray([[10, 10],\n       [10, 10]])\n\n>>> np.full((2, 2), [1, 2])\narray([[1, 2],\n       [1, 2]])",
          "signature": "(shape, fill_value, dtype=None, order='C', *, device=None, like=None)"
        },
        {
          "name": "genfromtxt",
          "doc": "Load data from a text file, with missing values handled as specified.\n\nEach line past the first `skip_header` lines is split at the `delimiter`\ncharacter, and characters following the `comments` character are discarded.\n\nParameters\n----------\nfname : file, str, pathlib.Path, list of str, generator\n    File, filename, list, or generator to read.  If the filename\n    extension is ``.gz`` or ``.bz2``, the file is first decompressed. Note\n    that generators must return bytes or strings. The strings\n    in a list or produced by a generator are treated as lines.\ndtype : dtype, optional\n    Data type of the resulting array.\n    If None, the dtypes will be determined by the contents of each\n    column, individually.\ncomments : str, optional\n    The character used to indicate the start of a comment.\n    All the characters occurring on a line after a comment are discarded.\ndelimiter : str, int, or sequence, optional\n    The string used to separate values.  By default, any consecutive\n    whitespaces act as delimiter.  An integer or sequence of integers\n    can also be provided as width(s) of each field.\nskiprows : int, optional\n    `skiprows` was removed in numpy 1.10. Please use `skip_header` instead.\nskip_header : int, optional\n    The number of lines to skip at the beginning of the file.\nskip_footer : int, optional\n    The number of lines to skip at the end of the file.\nconverters : variable, optional\n    The set of functions that convert the data of a column to a value.\n    The converters can also be used to provide a default value\n    for missing data: ``converters = {3: lambda s: float(s or 0)}``.\nmissing : variable, optional\n    `missing` was removed in numpy 1.10. Please use `missing_values`\n    instead.\nmissing_values : variable, optional\n    The set of strings corresponding to missing data.\nfilling_values : variable, optional\n    The set of values to be used as default when the data are missing.\nusecols : sequence, optional\n    Which columns to read, with 0 being the first.  For example,\n    ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.\nnames : {None, True, str, sequence}, optional\n    If `names` is True, the field names are read from the first line after\n    the first `skip_header` lines. This line can optionally be preceded\n    by a comment delimiter. Any content before the comment delimiter is\n    discarded. If `names` is a sequence or a single-string of\n    comma-separated names, the names will be used to define the field\n    names in a structured dtype. If `names` is None, the names of the\n    dtype fields will be used, if any.\nexcludelist : sequence, optional\n    A list of names to exclude. This list is appended to the default list\n    ['return','file','print']. Excluded names are appended with an\n    underscore: for example, `file` would become `file_`.\ndeletechars : str, optional\n    A string combining invalid characters that must be deleted from the\n    names.\ndefaultfmt : str, optional\n    A format used to define default field names, such as \"f%i\" or \"f_%02i\".\nautostrip : bool, optional\n    Whether to automatically strip white spaces from the variables.\nreplace_space : char, optional\n    Character(s) used in replacement of white spaces in the variable\n    names. By default, use a '_'.\ncase_sensitive : {True, False, 'upper', 'lower'}, optional\n    If True, field names are case sensitive.\n    If False or 'upper', field names are converted to upper case.\n    If 'lower', field names are converted to lower case.\nunpack : bool, optional\n    If True, the returned array is transposed, so that arguments may be\n    unpacked using ``x, y, z = genfromtxt(...)``.  When used with a\n    structured data-type, arrays are returned for each field.\n    Default is False.\nusemask : bool, optional\n    If True, return a masked array.\n    If False, return a regular array.\nloose : bool, optional\n    If True, do not raise errors for invalid values.\ninvalid_raise : bool, optional\n    If True, an exception is raised if an inconsistency is detected in the\n    number of columns.\n    If False, a warning is emitted and the offending lines are skipped.\nmax_rows : int,  optional\n    The maximum number of rows to read. Must not be used with skip_footer\n    at the same time.  If given, the value must be at least 1. Default is\n    to read the entire file.\nencoding : str, optional\n    Encoding used to decode the inputfile. Does not apply when `fname`\n    is a file object. The special value 'bytes' enables backward\n    compatibility workarounds that ensure that you receive byte arrays\n    when possible and passes latin1 encoded strings to converters.\n    Override this value to receive unicode arrays and pass strings\n    as input to converters.  If set to None the system default is used.\n    The default value is 'bytes'.\n\n    .. versionchanged:: 2.0\n        Before NumPy 2, the default was ``'bytes'`` for Python 2\n        compatibility. The default is now ``None``.\n\nndmin : int, optional\n    Same parameter as `loadtxt`\n\n    .. versionadded:: 1.23.0\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not\n    NumPy arrays. If an array-like passed in as ``like`` supports\n    the ``__array_function__`` protocol, the result will be defined\n    by it. In this case, it ensures the creation of an array object\n    compatible with that passed in via this argument.\n\n    .. versionadded:: 1.20.0\n\nReturns\n-------\nout : ndarray\n    Data read from the text file. If `usemask` is True, this is a\n    masked array.\n\nSee Also\n--------\nnumpy.loadtxt : equivalent function when no data is missing.\n\nNotes\n-----\n* When spaces are used as delimiters, or when no delimiter has been given\n  as input, there should not be any missing data between two fields.\n* When variables are named (either by a flexible dtype or with a `names`\n  sequence), there must not be any header in the file (else a ValueError\n  exception is raised).\n* Individual values are not stripped of spaces by default.\n  When using a custom converter, make sure the function does remove spaces.\n* Custom converters may receive unexpected values due to dtype\n  discovery.\n\nReferences\n----------\n.. [1] NumPy User Guide, section `I/O with NumPy\n       <https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html>`_.\n\nExamples\n--------\n>>> from io import StringIO\n>>> import numpy as np\n\nComma delimited file with mixed dtype\n\n>>> s = StringIO(\"1,1.3,abcde\")\n>>> data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),\n... ('mystring','S5')], delimiter=\",\")\n>>> data\narray((1, 1.3, b'abcde'),\n      dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', 'S5')])\n\nUsing dtype = None\n\n>>> _ = s.seek(0) # needed for StringIO example only\n>>> data = np.genfromtxt(s, dtype=None,\n... names = ['myint','myfloat','mystring'], delimiter=\",\")\n>>> data\narray((1, 1.3, 'abcde'),\n      dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', '<U5')])\n\nSpecifying dtype and names\n\n>>> _ = s.seek(0)\n>>> data = np.genfromtxt(s, dtype=\"i8,f8,S5\",\n... names=['myint','myfloat','mystring'], delimiter=\",\")\n>>> data\narray((1, 1.3, b'abcde'),\n      dtype=[('myint', '<i8'), ('myfloat', '<f8'), ('mystring', 'S5')])\n\nAn example with fixed-width columns\n\n>>> s = StringIO(\"11.3abcde\")\n>>> data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],\n...     delimiter=[1,3,5])\n>>> data\narray((1, 1.3, 'abcde'),\n      dtype=[('intvar', '<i8'), ('fltvar', '<f8'), ('strvar', '<U5')])\n\nAn example to show comments\n\n>>> f = StringIO('''\n... text,# of chars\n... hello world,11\n... numpy,5''')\n>>> np.genfromtxt(f, dtype='S12,S12', delimiter=',')\narray([(b'text', b''), (b'hello world', b'11'), (b'numpy', b'5')],\n  dtype=[('f0', 'S12'), ('f1', 'S12')])",
          "signature": "(fname, dtype=<class 'float'>, comments='#', delimiter=None, skip_header=0, skip_footer=0, converters=None, missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=\" !#$%&'()*+,-./:;<=>?@[\\\\]^{|}~\", replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True, max_rows=None, encoding=None, *, ndmin=0, like=None)"
        },
        {
          "name": "get_include",
          "doc": "Return the directory that contains the NumPy \\*.h header files.\n\nExtension modules that need to compile against NumPy may need to use this\nfunction to locate the appropriate include directory.\n\nNotes\n-----\nWhen using ``setuptools``, for example in ``setup.py``::\n\n    import numpy as np\n    ...\n    Extension('extension_name', ...\n              include_dirs=[np.get_include()])\n    ...\n\nNote that a CLI tool ``numpy-config`` was introduced in NumPy 2.0, using\nthat is likely preferred for build systems other than ``setuptools``::\n\n    $ numpy-config --cflags\n    -I/path/to/site-packages/numpy/_core/include\n\n    # Or rely on pkg-config:\n    $ export PKG_CONFIG_PATH=$(numpy-config --pkgconfigdir)\n    $ pkg-config --cflags\n    -I/path/to/site-packages/numpy/_core/include\n\nExamples\n--------\n>>> np.get_include()\n'.../site-packages/numpy/core/include'  # may vary",
          "signature": "()"
        },
        {
          "name": "get_printoptions",
          "doc": "Return the current print options.\n\nReturns\n-------\nprint_opts : dict\n    Dictionary of current print options with keys\n\n    - precision : int\n    - threshold : int\n    - edgeitems : int\n    - linewidth : int\n    - suppress : bool\n    - nanstr : str\n    - infstr : str\n    - sign : str\n    - formatter : dict of callables\n    - floatmode : str\n    - legacy : str or False\n\n    For a full description of these options, see `set_printoptions`.\n\nSee Also\n--------\nset_printoptions, printoptions\n\nExamples\n--------\n>>> import numpy as np\n\n>>> np.get_printoptions()\n{'edgeitems': 3, 'threshold': 1000, ..., 'override_repr': None}\n\n>>> np.get_printoptions()['linewidth']\n75\n>>> np.set_printoptions(linewidth=100)\n>>> np.get_printoptions()['linewidth']\n100",
          "signature": "()"
        },
        {
          "name": "getbufsize",
          "doc": "Return the size of the buffer used in ufuncs.\n\nReturns\n-------\ngetbufsize : int\n    Size of ufunc buffer in bytes.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.getbufsize()\n8192",
          "signature": "()"
        },
        {
          "name": "geterr",
          "doc": "Get the current way of handling floating-point errors.\n\nReturns\n-------\nres : dict\n    A dictionary with keys \"divide\", \"over\", \"under\", and \"invalid\",\n    whose values are from the strings \"ignore\", \"print\", \"log\", \"warn\",\n    \"raise\", and \"call\". The keys represent possible floating-point\n    exceptions, and the values define how these exceptions are handled.\n\nSee Also\n--------\ngeterrcall, seterr, seterrcall\n\nNotes\n-----\nFor complete documentation of the types of floating-point exceptions and\ntreatment options, see `seterr`.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.geterr()\n{'divide': 'warn', 'over': 'warn', 'under': 'ignore', 'invalid': 'warn'}\n>>> np.arange(3.) / np.arange(3.)  # doctest: +SKIP\narray([nan,  1.,  1.])\nRuntimeWarning: invalid value encountered in divide\n\n>>> oldsettings = np.seterr(all='warn', invalid='raise')\n>>> np.geterr()\n{'divide': 'warn', 'over': 'warn', 'under': 'warn', 'invalid': 'raise'}\n>>> np.arange(3.) / np.arange(3.)\nTraceback (most recent call last):\n  ...\nFloatingPointError: invalid value encountered in divide\n>>> oldsettings = np.seterr(**oldsettings)  # restore original",
          "signature": "()"
        },
        {
          "name": "geterrcall",
          "doc": "Return the current callback function used on floating-point errors.\n\nWhen the error handling for a floating-point error (one of \"divide\",\n\"over\", \"under\", or \"invalid\") is set to 'call' or 'log', the function\nthat is called or the log instance that is written to is returned by\n`geterrcall`. This function or log instance has been set with\n`seterrcall`.\n\nReturns\n-------\nerrobj : callable, log instance or None\n    The current error handler. If no handler was set through `seterrcall`,\n    ``None`` is returned.\n\nSee Also\n--------\nseterrcall, seterr, geterr\n\nNotes\n-----\nFor complete documentation of the types of floating-point exceptions and\ntreatment options, see `seterr`.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.geterrcall()  # we did not yet set a handler, returns None\n\n>>> orig_settings = np.seterr(all='call')\n>>> def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n>>> old_handler = np.seterrcall(err_handler)\n>>> np.array([1, 2, 3]) / 0.0\nFloating point error (divide by zero), with flag 1\narray([inf, inf, inf])\n\n>>> cur_handler = np.geterrcall()\n>>> cur_handler is err_handler\nTrue\n>>> old_settings = np.seterr(**orig_settings)  # restore original\n>>> old_handler = np.seterrcall(None)  # restore original",
          "signature": "()"
        },
        {
          "name": "hamming",
          "doc": "Return the Hamming window.\n\nThe Hamming window is a taper formed by using a weighted cosine.\n\nParameters\n----------\nM : int\n    Number of points in the output window. If zero or less, an\n    empty array is returned.\n\nReturns\n-------\nout : ndarray\n    The window, with the maximum value normalized to one (the value\n    one appears only if the number of samples is odd).\n\nSee Also\n--------\nbartlett, blackman, hanning, kaiser\n\nNotes\n-----\nThe Hamming window is defined as\n\n.. math::  w(n) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)\n           \\qquad 0 \\leq n \\leq M-1\n\nThe Hamming was named for R. W. Hamming, an associate of J. W. Tukey\nand is described in Blackman and Tukey. It was recommended for\nsmoothing the truncated autocovariance function in the time domain.\nMost references to the Hamming window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  It is also known as an apodization (which means\n\"removing the foot\", i.e. smoothing discontinuities at the beginning\nand end of the sampled signal) or tapering function.\n\nReferences\n----------\n.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n       spectra, Dover Publications, New York.\n.. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n       University of Alberta Press, 1975, pp. 109-110.\n.. [3] Wikipedia, \"Window function\",\n       https://en.wikipedia.org/wiki/Window_function\n.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n       \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.hamming(12)\narray([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary\n        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n        0.15302337,  0.08      ])\n\nPlot the window and the frequency response.\n\n.. plot::\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from numpy.fft import fft, fftshift\n    window = np.hamming(51)\n    plt.plot(window)\n    plt.title(\"Hamming window\")\n    plt.ylabel(\"Amplitude\")\n    plt.xlabel(\"Sample\")\n    plt.show()\n\n    plt.figure()\n    A = fft(window, 2048) / 25.5\n    mag = np.abs(fftshift(A))\n    freq = np.linspace(-0.5, 0.5, len(A))\n    response = 20 * np.log10(mag)\n    response = np.clip(response, -100, 100)\n    plt.plot(freq, response)\n    plt.title(\"Frequency response of Hamming window\")\n    plt.ylabel(\"Magnitude [dB]\")\n    plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    plt.axis('tight')\n    plt.show()",
          "signature": "(M)"
        },
        {
          "name": "hanning",
          "doc": "Return the Hanning window.\n\nThe Hanning window is a taper formed by using a weighted cosine.\n\nParameters\n----------\nM : int\n    Number of points in the output window. If zero or less, an\n    empty array is returned.\n\nReturns\n-------\nout : ndarray, shape(M,)\n    The window, with the maximum value normalized to one (the value\n    one appears only if `M` is odd).\n\nSee Also\n--------\nbartlett, blackman, hamming, kaiser\n\nNotes\n-----\nThe Hanning window is defined as\n\n.. math::  w(n) = 0.5 - 0.5\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)\n           \\qquad 0 \\leq n \\leq M-1\n\nThe Hanning was named for Julius von Hann, an Austrian meteorologist.\nIt is also known as the Cosine Bell. Some authors prefer that it be\ncalled a Hann window, to help avoid confusion with the very similar\nHamming window.\n\nMost references to the Hanning window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  It is also known as an apodization (which means\n\"removing the foot\", i.e. smoothing discontinuities at the beginning\nand end of the sampled signal) or tapering function.\n\nReferences\n----------\n.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power\n       spectra, Dover Publications, New York.\n.. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\",\n       The University of Alberta Press, 1975, pp. 106-108.\n.. [3] Wikipedia, \"Window function\",\n       https://en.wikipedia.org/wiki/Window_function\n.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n       \"Numerical Recipes\", Cambridge University Press, 1986, page 425.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.hanning(12)\narray([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,\n       0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,\n       0.07937323, 0.        ])\n\nPlot the window and its frequency response.\n\n.. plot::\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from numpy.fft import fft, fftshift\n    window = np.hanning(51)\n    plt.plot(window)\n    plt.title(\"Hann window\")\n    plt.ylabel(\"Amplitude\")\n    plt.xlabel(\"Sample\")\n    plt.show()\n\n    plt.figure()\n    A = fft(window, 2048) / 25.5\n    mag = np.abs(fftshift(A))\n    freq = np.linspace(-0.5, 0.5, len(A))\n    with np.errstate(divide='ignore', invalid='ignore'):\n        response = 20 * np.log10(mag)\n    response = np.clip(response, -100, 100)\n    plt.plot(freq, response)\n    plt.title(\"Frequency response of the Hann window\")\n    plt.ylabel(\"Magnitude [dB]\")\n    plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    plt.axis('tight')\n    plt.show()",
          "signature": "(M)"
        },
        {
          "name": "identity",
          "doc": "Return the identity array.\n\nThe identity array is a square array with ones on\nthe main diagonal.\n\nParameters\n----------\nn : int\n    Number of rows (and columns) in `n` x `n` output.\ndtype : data-type, optional\n    Data-type of the output.  Defaults to ``float``.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not\n    NumPy arrays. If an array-like passed in as ``like`` supports\n    the ``__array_function__`` protocol, the result will be defined\n    by it. In this case, it ensures the creation of an array object\n    compatible with that passed in via this argument.\n\n    .. versionadded:: 1.20.0\n\nReturns\n-------\nout : ndarray\n    `n` x `n` array with its main diagonal set to one,\n    and all other elements 0.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.identity(3)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])",
          "signature": "(n, dtype=None, *, like=None)"
        },
        {
          "name": "indices",
          "doc": "Return an array representing the indices of a grid.\n\nCompute an array where the subarrays contain index values 0, 1, ...\nvarying only along the corresponding axis.\n\nParameters\n----------\ndimensions : sequence of ints\n    The shape of the grid.\ndtype : dtype, optional\n    Data type of the result.\nsparse : boolean, optional\n    Return a sparse representation of the grid instead of a dense\n    representation. Default is False.\n\nReturns\n-------\ngrid : one ndarray or tuple of ndarrays\n    If sparse is False:\n        Returns one array of grid indices,\n        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.\n    If sparse is True:\n        Returns a tuple of arrays, with\n        ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with\n        dimensions[i] in the ith place\n\nSee Also\n--------\nmgrid, ogrid, meshgrid\n\nNotes\n-----\nThe output shape in the dense case is obtained by prepending the number\nof dimensions in front of the tuple of dimensions, i.e. if `dimensions`\nis a tuple ``(r0, ..., rN-1)`` of length ``N``, the output shape is\n``(N, r0, ..., rN-1)``.\n\nThe subarrays ``grid[k]`` contains the N-D array of indices along the\n``k-th`` axis. Explicitly::\n\n    grid[k, i0, i1, ..., iN-1] = ik\n\nExamples\n--------\n>>> import numpy as np\n>>> grid = np.indices((2, 3))\n>>> grid.shape\n(2, 2, 3)\n>>> grid[0]        # row indices\narray([[0, 0, 0],\n       [1, 1, 1]])\n>>> grid[1]        # column indices\narray([[0, 1, 2],\n       [0, 1, 2]])\n\nThe indices can be used as an index into an array.\n\n>>> x = np.arange(20).reshape(5, 4)\n>>> row, col = np.indices((2, 3))\n>>> x[row, col]\narray([[0, 1, 2],\n       [4, 5, 6]])\n\nNote that it would be more straightforward in the above example to\nextract the required elements directly with ``x[:2, :3]``.\n\nIf sparse is set to true, the grid will be returned in a sparse\nrepresentation.\n\n>>> i, j = np.indices((2, 3), sparse=True)\n>>> i.shape\n(2, 1)\n>>> j.shape\n(1, 3)\n>>> i        # row indices\narray([[0],\n       [1]])\n>>> j        # column indices\narray([[0, 1, 2]])",
          "signature": "(dimensions, dtype=<class 'int'>, sparse=False)"
        },
        {
          "name": "info",
          "doc": "Get help information for an array, function, class, or module.\n\nParameters\n----------\nobject : object or str, optional\n    Input object or name to get information about. If `object` is\n    an `ndarray` instance, information about the array is printed.\n    If `object` is a numpy object, its docstring is given. If it is\n    a string, available modules are searched for matching objects.\n    If None, information about `info` itself is returned.\nmaxwidth : int, optional\n    Printing width.\noutput : file like object, optional\n    File like object that the output is written to, default is\n    ``None``, in which case ``sys.stdout`` will be used.\n    The object has to be opened in 'w' or 'a' mode.\ntoplevel : str, optional\n    Start search at this level.\n\nNotes\n-----\nWhen used interactively with an object, ``np.info(obj)`` is equivalent\nto ``help(obj)`` on the Python prompt or ``obj?`` on the IPython\nprompt.\n\nExamples\n--------\n>>> np.info(np.polyval) # doctest: +SKIP\n   polyval(p, x)\n     Evaluate the polynomial p at x.\n     ...\n\nWhen using a string for `object` it is possible to get multiple results.\n\n>>> np.info('fft') # doctest: +SKIP\n     *** Found in numpy ***\nCore FFT routines\n...\n     *** Found in numpy.fft ***\n fft(a, n=None, axis=-1)\n...\n     *** Repeat reference found in numpy.fft.fftpack ***\n     *** Total of 3 references found. ***\n\nWhen the argument is an array, information about the array is printed.\n\n>>> a = np.array([[1 + 2j, 3, -4], [-5j, 6, 0]], dtype=np.complex64)\n>>> np.info(a)\nclass:  ndarray\nshape:  (2, 3)\nstrides:  (24, 8)\nitemsize:  8\naligned:  True\ncontiguous:  True\nfortran:  False\ndata pointer: 0x562b6e0d2860  # may vary\nbyteorder:  little\nbyteswap:  False\ntype: complex64",
          "signature": "(object=None, maxwidth=76, output=None, toplevel='numpy')"
        },
        {
          "name": "isdtype",
          "doc": "Determine if a provided dtype is of a specified data type ``kind``.\n\nThis function only supports built-in NumPy's data types.\nThird-party dtypes are not yet supported.\n\nParameters\n----------\ndtype : dtype\n    The input dtype.\nkind : dtype or str or tuple of dtypes/strs.\n    dtype or dtype kind. Allowed dtype kinds are:\n    * ``'bool'`` : boolean kind\n    * ``'signed integer'`` : signed integer data types\n    * ``'unsigned integer'`` : unsigned integer data types\n    * ``'integral'`` : integer data types\n    * ``'real floating'`` : real-valued floating-point data types\n    * ``'complex floating'`` : complex floating-point data types\n    * ``'numeric'`` : numeric data types\n\nReturns\n-------\nout : bool\n\nSee Also\n--------\nissubdtype\n\nExamples\n--------\n>>> import numpy as np\n>>> np.isdtype(np.float32, np.float64)\nFalse\n>>> np.isdtype(np.float32, \"real floating\")\nTrue\n>>> np.isdtype(np.complex128, (\"real floating\", \"complex floating\"))\nTrue",
          "signature": "(dtype, kind)"
        },
        {
          "name": "isfortran",
          "doc": "Check if the array is Fortran contiguous but *not* C contiguous.\n\nThis function is obsolete. If you only want to check if an array is Fortran\ncontiguous use ``a.flags.f_contiguous`` instead.\n\nParameters\n----------\na : ndarray\n    Input array.\n\nReturns\n-------\nisfortran : bool\n    Returns True if the array is Fortran contiguous but *not* C contiguous.\n\n\nExamples\n--------\n\nnp.array allows to specify whether the array is written in C-contiguous\norder (last index varies the fastest), or FORTRAN-contiguous order in\nmemory (first index varies the fastest).\n\n>>> import numpy as np\n>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n>>> a\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> np.isfortran(a)\nFalse\n\n>>> b = np.array([[1, 2, 3], [4, 5, 6]], order='F')\n>>> b\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> np.isfortran(b)\nTrue\n\n\nThe transpose of a C-ordered array is a FORTRAN-ordered array.\n\n>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n>>> a\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> np.isfortran(a)\nFalse\n>>> b = a.T\n>>> b\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n>>> np.isfortran(b)\nTrue\n\nC-ordered arrays evaluate as False even if they are also FORTRAN-ordered.\n\n>>> np.isfortran(np.array([1, 2], order='F'))\nFalse",
          "signature": "(a)"
        },
        {
          "name": "isscalar",
          "doc": "Returns True if the type of `element` is a scalar type.\n\nParameters\n----------\nelement : any\n    Input argument, can be of any type and shape.\n\nReturns\n-------\nval : bool\n    True if `element` is a scalar type, False if it is not.\n\nSee Also\n--------\nndim : Get the number of dimensions of an array\n\nNotes\n-----\nIf you need a stricter way to identify a *numerical* scalar, use\n``isinstance(x, numbers.Number)``, as that returns ``False`` for most\nnon-numerical elements such as strings.\n\nIn most cases ``np.ndim(x) == 0`` should be used instead of this function,\nas that will also return true for 0d arrays. This is how numpy overloads\nfunctions in the style of the ``dx`` arguments to `gradient` and\nthe ``bins`` argument to `histogram`. Some key differences:\n\n+------------------------------------+---------------+-------------------+\n| x                                  |``isscalar(x)``|``np.ndim(x) == 0``|\n+====================================+===============+===================+\n| PEP 3141 numeric objects           | ``True``      | ``True``          |\n| (including builtins)               |               |                   |\n+------------------------------------+---------------+-------------------+\n| builtin string and buffer objects  | ``True``      | ``True``          |\n+------------------------------------+---------------+-------------------+\n| other builtin objects, like        | ``False``     | ``True``          |\n| `pathlib.Path`, `Exception`,       |               |                   |\n| the result of `re.compile`         |               |                   |\n+------------------------------------+---------------+-------------------+\n| third-party objects like           | ``False``     | ``True``          |\n| `matplotlib.figure.Figure`         |               |                   |\n+------------------------------------+---------------+-------------------+\n| zero-dimensional numpy arrays      | ``False``     | ``True``          |\n+------------------------------------+---------------+-------------------+\n| other numpy arrays                 | ``False``     | ``False``         |\n+------------------------------------+---------------+-------------------+\n| `list`, `tuple`, and other         | ``False``     | ``False``         |\n| sequence objects                   |               |                   |\n+------------------------------------+---------------+-------------------+\n\nExamples\n--------\n>>> import numpy as np\n\n>>> np.isscalar(3.1)\nTrue\n\n>>> np.isscalar(np.array(3.1))\nFalse\n\n>>> np.isscalar([3.1])\nFalse\n\n>>> np.isscalar(False)\nTrue\n\n>>> np.isscalar('numpy')\nTrue\n\nNumPy supports PEP 3141 numbers:\n\n>>> from fractions import Fraction\n>>> np.isscalar(Fraction(5, 17))\nTrue\n>>> from numbers import Number\n>>> np.isscalar(Number())\nTrue",
          "signature": "(element)"
        },
        {
          "name": "issubdtype",
          "doc": "Returns True if first argument is a typecode lower/equal in type hierarchy.\n\nThis is like the builtin :func:`issubclass`, but for `dtype`\\ s.\n\nParameters\n----------\narg1, arg2 : dtype_like\n    `dtype` or object coercible to one\n\nReturns\n-------\nout : bool\n\nSee Also\n--------\n:ref:`arrays.scalars` : Overview of the numpy type hierarchy.\n\nExamples\n--------\n`issubdtype` can be used to check the type of arrays:\n\n>>> ints = np.array([1, 2, 3], dtype=np.int32)\n>>> np.issubdtype(ints.dtype, np.integer)\nTrue\n>>> np.issubdtype(ints.dtype, np.floating)\nFalse\n\n>>> floats = np.array([1, 2, 3], dtype=np.float32)\n>>> np.issubdtype(floats.dtype, np.integer)\nFalse\n>>> np.issubdtype(floats.dtype, np.floating)\nTrue\n\nSimilar types of different sizes are not subdtypes of each other:\n\n>>> np.issubdtype(np.float64, np.float32)\nFalse\n>>> np.issubdtype(np.float32, np.float64)\nFalse\n\nbut both are subtypes of `floating`:\n\n>>> np.issubdtype(np.float64, np.floating)\nTrue\n>>> np.issubdtype(np.float32, np.floating)\nTrue\n\nFor convenience, dtype-like objects are allowed too:\n\n>>> np.issubdtype('S1', np.bytes_)\nTrue\n>>> np.issubdtype('i4', np.signedinteger)\nTrue",
          "signature": "(arg1, arg2)"
        },
        {
          "name": "iterable",
          "doc": "Check whether or not an object can be iterated over.\n\nParameters\n----------\ny : object\n  Input object.\n\nReturns\n-------\nb : bool\n  Return ``True`` if the object has an iterator method or is a\n  sequence and ``False`` otherwise.\n\n\nExamples\n--------\n>>> import numpy as np\n>>> np.iterable([1, 2, 3])\nTrue\n>>> np.iterable(2)\nFalse\n\nNotes\n-----\nIn most cases, the results of ``np.iterable(obj)`` are consistent with\n``isinstance(obj, collections.abc.Iterable)``. One notable exception is\nthe treatment of 0-dimensional arrays::\n\n    >>> from collections.abc import Iterable\n    >>> a = np.array(1.0)  # 0-dimensional numpy array\n    >>> isinstance(a, Iterable)\n    True\n    >>> np.iterable(a)\n    False",
          "signature": "(y)"
        },
        {
          "name": "kaiser",
          "doc": "Return the Kaiser window.\n\nThe Kaiser window is a taper formed by using a Bessel function.\n\nParameters\n----------\nM : int\n    Number of points in the output window. If zero or less, an\n    empty array is returned.\nbeta : float\n    Shape parameter for window.\n\nReturns\n-------\nout : array\n    The window, with the maximum value normalized to one (the value\n    one appears only if the number of samples is odd).\n\nSee Also\n--------\nbartlett, blackman, hamming, hanning\n\nNotes\n-----\nThe Kaiser window is defined as\n\n.. math::  w(n) = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2}{(M-1)^2}}\n           \\right)/I_0(\\beta)\n\nwith\n\n.. math:: \\quad -\\frac{M-1}{2} \\leq n \\leq \\frac{M-1}{2},\n\nwhere :math:`I_0` is the modified zeroth-order Bessel function.\n\nThe Kaiser was named for Jim Kaiser, who discovered a simple\napproximation to the DPSS window based on Bessel functions.  The Kaiser\nwindow is a very good approximation to the Digital Prolate Spheroidal\nSequence, or Slepian window, which is the transform which maximizes the\nenergy in the main lobe of the window relative to total energy.\n\nThe Kaiser can approximate many other windows by varying the beta\nparameter.\n\n====  =======================\nbeta  Window shape\n====  =======================\n0     Rectangular\n5     Similar to a Hamming\n6     Similar to a Hanning\n8.6   Similar to a Blackman\n====  =======================\n\nA beta value of 14 is probably a good starting point. Note that as beta\ngets large, the window narrows, and so the number of samples needs to be\nlarge enough to sample the increasingly narrow spike, otherwise NaNs will\nget returned.\n\nMost references to the Kaiser window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  It is also known as an apodization (which means\n\"removing the foot\", i.e. smoothing discontinuities at the beginning\nand end of the sampled signal) or tapering function.\n\nReferences\n----------\n.. [1] J. F. Kaiser, \"Digital Filters\" - Ch 7 in \"Systems analysis by\n       digital computer\", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.\n       John Wiley and Sons, New York, (1966).\n.. [2] E.R. Kanasewich, \"Time Sequence Analysis in Geophysics\", The\n       University of Alberta Press, 1975, pp. 177-178.\n.. [3] Wikipedia, \"Window function\",\n       https://en.wikipedia.org/wiki/Window_function\n\nExamples\n--------\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> np.kaiser(12, 14)\n array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary\n        2.29737120e-01, 5.99885316e-01, 9.45674898e-01,\n        9.45674898e-01, 5.99885316e-01, 2.29737120e-01,\n        4.65200189e-02, 3.46009194e-03, 7.72686684e-06])\n\n\nPlot the window and the frequency response.\n\n.. plot::\n    :include-source:\n\n    import matplotlib.pyplot as plt\n    from numpy.fft import fft, fftshift\n    window = np.kaiser(51, 14)\n    plt.plot(window)\n    plt.title(\"Kaiser window\")\n    plt.ylabel(\"Amplitude\")\n    plt.xlabel(\"Sample\")\n    plt.show()\n\n    plt.figure()\n    A = fft(window, 2048) / 25.5\n    mag = np.abs(fftshift(A))\n    freq = np.linspace(-0.5, 0.5, len(A))\n    response = 20 * np.log10(mag)\n    response = np.clip(response, -100, 100)\n    plt.plot(freq, response)\n    plt.title(\"Frequency response of Kaiser window\")\n    plt.ylabel(\"Magnitude [dB]\")\n    plt.xlabel(\"Normalized frequency [cycles per sample]\")\n    plt.axis('tight')\n    plt.show()",
          "signature": "(M, beta)"
        },
        {
          "name": "load",
          "doc": "Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.\n\n.. warning:: Loading files that contain object arrays uses the ``pickle``\n             module, which is not secure against erroneous or maliciously\n             constructed data. Consider passing ``allow_pickle=False`` to\n             load data that is known not to contain object arrays for the\n             safer handling of untrusted sources.\n\nParameters\n----------\nfile : file-like object, string, or pathlib.Path\n    The file to read. File-like objects must support the\n    ``seek()`` and ``read()`` methods and must always\n    be opened in binary mode.  Pickled files require that the\n    file-like object support the ``readline()`` method as well.\nmmap_mode : {None, 'r+', 'r', 'w+', 'c'}, optional\n    If not None, then memory-map the file, using the given mode (see\n    `numpy.memmap` for a detailed description of the modes).  A\n    memory-mapped array is kept on disk. However, it can be accessed\n    and sliced like any ndarray.  Memory mapping is especially useful\n    for accessing small fragments of large files without reading the\n    entire file into memory.\nallow_pickle : bool, optional\n    Allow loading pickled object arrays stored in npy files. Reasons for\n    disallowing pickles include security, as loading pickled data can\n    execute arbitrary code. If pickles are disallowed, loading object\n    arrays will fail. Default: False\nfix_imports : bool, optional\n    Only useful when loading Python 2 generated pickled files,\n    which includes npy/npz files containing object arrays. If `fix_imports`\n    is True, pickle will try to map the old Python 2 names to the new names\n    used in Python 3.\nencoding : str, optional\n    What encoding to use when reading Python 2 strings. Only useful when\n    loading Python 2 generated pickled files, which includes\n    npy/npz files containing object arrays. Values other than 'latin1',\n    'ASCII', and 'bytes' are not allowed, as they can corrupt numerical\n    data. Default: 'ASCII'\nmax_header_size : int, optional\n    Maximum allowed size of the header.  Large headers may not be safe\n    to load securely and thus require explicitly passing a larger value.\n    See :py:func:`ast.literal_eval()` for details.\n    This option is ignored when `allow_pickle` is passed.  In that case\n    the file is by definition trusted and the limit is unnecessary.\n\nReturns\n-------\nresult : array, tuple, dict, etc.\n    Data stored in the file. For ``.npz`` files, the returned instance\n    of NpzFile class must be closed to avoid leaking file descriptors.\n\nRaises\n------\nOSError\n    If the input file does not exist or cannot be read.\nUnpicklingError\n    If ``allow_pickle=True``, but the file cannot be loaded as a pickle.\nValueError\n    The file contains an object array, but ``allow_pickle=False`` given.\nEOFError\n    When calling ``np.load`` multiple times on the same file handle,\n    if all data has already been read\n\nSee Also\n--------\nsave, savez, savez_compressed, loadtxt\nmemmap : Create a memory-map to an array stored in a file on disk.\nlib.format.open_memmap : Create or load a memory-mapped ``.npy`` file.\n\nNotes\n-----\n- If the file contains pickle data, then whatever object is stored\n  in the pickle is returned.\n- If the file is a ``.npy`` file, then a single array is returned.\n- If the file is a ``.npz`` file, then a dictionary-like object is\n  returned, containing ``{filename: array}`` key-value pairs, one for\n  each file in the archive.\n- If the file is a ``.npz`` file, the returned value supports the\n  context manager protocol in a similar fashion to the open function::\n\n    with load('foo.npz') as data:\n        a = data['a']\n\n  The underlying file descriptor is closed when exiting the 'with'\n  block.\n\nExamples\n--------\n>>> import numpy as np\n\nStore data to disk, and load it again:\n\n>>> np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))\n>>> np.load('/tmp/123.npy')\narray([[1, 2, 3],\n       [4, 5, 6]])\n\nStore compressed data to disk, and load it again:\n\n>>> a=np.array([[1, 2, 3], [4, 5, 6]])\n>>> b=np.array([1, 2])\n>>> np.savez('/tmp/123.npz', a=a, b=b)\n>>> data = np.load('/tmp/123.npz')\n>>> data['a']\narray([[1, 2, 3],\n       [4, 5, 6]])\n>>> data['b']\narray([1, 2])\n>>> data.close()\n\nMem-map the stored array, and then access the second row\ndirectly from disk:\n\n>>> X = np.load('/tmp/123.npy', mmap_mode='r')\n>>> X[1, :]\nmemmap([4, 5, 6])",
          "signature": "(file, mmap_mode=None, allow_pickle=False, fix_imports=True, encoding='ASCII', *, max_header_size=10000)"
        },
        {
          "name": "loadtxt",
          "doc": "Load data from a text file.\n\nParameters\n----------\nfname : file, str, pathlib.Path, list of str, generator\n    File, filename, list, or generator to read.  If the filename\n    extension is ``.gz`` or ``.bz2``, the file is first decompressed. Note\n    that generators must return bytes or strings. The strings\n    in a list or produced by a generator are treated as lines.\ndtype : data-type, optional\n    Data-type of the resulting array; default: float.  If this is a\n    structured data-type, the resulting array will be 1-dimensional, and\n    each row will be interpreted as an element of the array.  In this\n    case, the number of columns used must match the number of fields in\n    the data-type.\ncomments : str or sequence of str or None, optional\n    The characters or list of characters used to indicate the start of a\n    comment. None implies no comments. For backwards compatibility, byte\n    strings will be decoded as 'latin1'. The default is '#'.\ndelimiter : str, optional\n    The character used to separate the values. For backwards compatibility,\n    byte strings will be decoded as 'latin1'. The default is whitespace.\n\n    .. versionchanged:: 1.23.0\n       Only single character delimiters are supported. Newline characters\n       cannot be used as the delimiter.\n\nconverters : dict or callable, optional\n    Converter functions to customize value parsing. If `converters` is\n    callable, the function is applied to all columns, else it must be a\n    dict that maps column number to a parser function.\n    See examples for further details.\n    Default: None.\n\n    .. versionchanged:: 1.23.0\n       The ability to pass a single callable to be applied to all columns\n       was added.\n\nskiprows : int, optional\n    Skip the first `skiprows` lines, including comments; default: 0.\nusecols : int or sequence, optional\n    Which columns to read, with 0 being the first. For example,\n    ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.\n    The default, None, results in all columns being read.\nunpack : bool, optional\n    If True, the returned array is transposed, so that arguments may be\n    unpacked using ``x, y, z = loadtxt(...)``.  When used with a\n    structured data-type, arrays are returned for each field.\n    Default is False.\nndmin : int, optional\n    The returned array will have at least `ndmin` dimensions.\n    Otherwise mono-dimensional axes will be squeezed.\n    Legal values: 0 (default), 1 or 2.\nencoding : str, optional\n    Encoding used to decode the inputfile. Does not apply to input streams.\n    The special value 'bytes' enables backward compatibility workarounds\n    that ensures you receive byte arrays as results if possible and passes\n    'latin1' encoded strings to converters. Override this value to receive\n    unicode arrays and pass strings as input to converters.  If set to None\n    the system default is used. The default value is None.\n\n    .. versionchanged:: 2.0\n        Before NumPy 2, the default was ``'bytes'`` for Python 2\n        compatibility. The default is now ``None``.\n\nmax_rows : int, optional\n    Read `max_rows` rows of content after `skiprows` lines. The default is\n    to read all the rows. Note that empty rows containing no data such as\n    empty lines and comment lines are not counted towards `max_rows`,\n    while such lines are counted in `skiprows`.\n\n    .. versionchanged:: 1.23.0\n        Lines containing no data, including comment lines (e.g., lines\n        starting with '#' or as specified via `comments`) are not counted\n        towards `max_rows`.\nquotechar : unicode character or None, optional\n    The character used to denote the start and end of a quoted item.\n    Occurrences of the delimiter or comment characters are ignored within\n    a quoted item. The default value is ``quotechar=None``, which means\n    quoting support is disabled.\n\n    If two consecutive instances of `quotechar` are found within a quoted\n    field, the first is treated as an escape character. See examples.\n\n    .. versionadded:: 1.23.0\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not\n    NumPy arrays. If an array-like passed in as ``like`` supports\n    the ``__array_function__`` protocol, the result will be defined\n    by it. In this case, it ensures the creation of an array object\n    compatible with that passed in via this argument.\n\n    .. versionadded:: 1.20.0\n\nReturns\n-------\nout : ndarray\n    Data read from the text file.\n\nSee Also\n--------\nload, fromstring, fromregex\ngenfromtxt : Load data with missing values handled as specified.\nscipy.io.loadmat : reads MATLAB data files\n\nNotes\n-----\nThis function aims to be a fast reader for simply formatted files.  The\n`genfromtxt` function provides more sophisticated handling of, e.g.,\nlines with missing values.\n\nEach row in the input text file must have the same number of values to be\nable to read all values. If all rows do not have same number of values, a\nsubset of up to n columns (where n is the least number of values present\nin all rows) can be read by specifying the columns via `usecols`.\n\nThe strings produced by the Python float.hex method can be used as\ninput for floats.\n\nExamples\n--------\n>>> import numpy as np\n>>> from io import StringIO   # StringIO behaves like a file object\n>>> c = StringIO(\"0 1\\n2 3\")\n>>> np.loadtxt(c)\narray([[0., 1.],\n       [2., 3.]])\n\n>>> d = StringIO(\"M 21 72\\nF 35 58\")\n>>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\n...                      'formats': ('S1', 'i4', 'f4')})\narray([(b'M', 21, 72.), (b'F', 35, 58.)],\n      dtype=[('gender', 'S1'), ('age', '<i4'), ('weight', '<f4')])\n\n>>> c = StringIO(\"1,0,2\\n3,0,4\")\n>>> x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)\n>>> x\narray([1., 3.])\n>>> y\narray([2., 4.])\n\nThe `converters` argument is used to specify functions to preprocess the\ntext prior to parsing. `converters` can be a dictionary that maps\npreprocessing functions to each column:\n\n>>> s = StringIO(\"1.618, 2.296\\n3.141, 4.669\\n\")\n>>> conv = {\n...     0: lambda x: np.floor(float(x)),  # conversion fn for column 0\n...     1: lambda x: np.ceil(float(x)),  # conversion fn for column 1\n... }\n>>> np.loadtxt(s, delimiter=\",\", converters=conv)\narray([[1., 3.],\n       [3., 5.]])\n\n`converters` can be a callable instead of a dictionary, in which case it\nis applied to all columns:\n\n>>> s = StringIO(\"0xDE 0xAD\\n0xC0 0xDE\")\n>>> import functools\n>>> conv = functools.partial(int, base=16)\n>>> np.loadtxt(s, converters=conv)\narray([[222., 173.],\n       [192., 222.]])\n\nThis example shows how `converters` can be used to convert a field\nwith a trailing minus sign into a negative number.\n\n>>> s = StringIO(\"10.01 31.25-\\n19.22 64.31\\n17.57- 63.94\")\n>>> def conv(fld):\n...     return -float(fld[:-1]) if fld.endswith(\"-\") else float(fld)\n...\n>>> np.loadtxt(s, converters=conv)\narray([[ 10.01, -31.25],\n       [ 19.22,  64.31],\n       [-17.57,  63.94]])\n\nUsing a callable as the converter can be particularly useful for handling\nvalues with different formatting, e.g. floats with underscores:\n\n>>> s = StringIO(\"1 2.7 100_000\")\n>>> np.loadtxt(s, converters=float)\narray([1.e+00, 2.7e+00, 1.e+05])\n\nThis idea can be extended to automatically handle values specified in\nmany different formats, such as hex values:\n\n>>> def conv(val):\n...     try:\n...         return float(val)\n...     except ValueError:\n...         return float.fromhex(val)\n>>> s = StringIO(\"1, 2.5, 3_000, 0b4, 0x1.4000000000000p+2\")\n>>> np.loadtxt(s, delimiter=\",\", converters=conv)\narray([1.0e+00, 2.5e+00, 3.0e+03, 1.8e+02, 5.0e+00])\n\nOr a format where the ``-`` sign comes after the number:\n\n>>> s = StringIO(\"10.01 31.25-\\n19.22 64.31\\n17.57- 63.94\")\n>>> conv = lambda x: -float(x[:-1]) if x.endswith(\"-\") else float(x)\n>>> np.loadtxt(s, converters=conv)\narray([[ 10.01, -31.25],\n       [ 19.22,  64.31],\n       [-17.57,  63.94]])\n\nSupport for quoted fields is enabled with the `quotechar` parameter.\nComment and delimiter characters are ignored when they appear within a\nquoted item delineated by `quotechar`:\n\n>>> s = StringIO('\"alpha, #42\", 10.0\\n\"beta, #64\", 2.0\\n')\n>>> dtype = np.dtype([(\"label\", \"U12\"), (\"value\", float)])\n>>> np.loadtxt(s, dtype=dtype, delimiter=\",\", quotechar='\"')\narray([('alpha, #42', 10.), ('beta, #64',  2.)],\n      dtype=[('label', '<U12'), ('value', '<f8')])\n\nQuoted fields can be separated by multiple whitespace characters:\n\n>>> s = StringIO('\"alpha, #42\"       10.0\\n\"beta, #64\" 2.0\\n')\n>>> dtype = np.dtype([(\"label\", \"U12\"), (\"value\", float)])\n>>> np.loadtxt(s, dtype=dtype, delimiter=None, quotechar='\"')\narray([('alpha, #42', 10.), ('beta, #64',  2.)],\n      dtype=[('label', '<U12'), ('value', '<f8')])\n\nTwo consecutive quote characters within a quoted field are treated as a\nsingle escaped character:\n\n>>> s = StringIO('\"Hello, my name is \"\"Monty\"\"!\"')\n>>> np.loadtxt(s, dtype=\"U\", delimiter=\",\", quotechar='\"')\narray('Hello, my name is \"Monty\"!', dtype='<U26')\n\nRead subset of columns when all rows do not contain equal number of values:\n\n>>> d = StringIO(\"1 2\\n2 4\\n3 9 12\\n4 16 20\")\n>>> np.loadtxt(d, usecols=(0, 1))\narray([[ 1.,  2.],\n       [ 2.,  4.],\n       [ 3.,  9.],\n       [ 4., 16.]])",
          "signature": "(fname, dtype=<class 'float'>, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding=None, max_rows=None, *, quotechar=None, like=None)"
        },
        {
          "name": "mask_indices",
          "doc": "Return the indices to access (n, n) arrays, given a masking function.\n\nAssume `mask_func` is a function that, for a square array a of size\n``(n, n)`` with a possible offset argument `k`, when called as\n``mask_func(a, k)`` returns a new array with zeros in certain locations\n(functions like `triu` or `tril` do precisely this). Then this function\nreturns the indices where the non-zero values would be located.\n\nParameters\n----------\nn : int\n    The returned indices will be valid to access arrays of shape (n, n).\nmask_func : callable\n    A function whose call signature is similar to that of `triu`, `tril`.\n    That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.\n    `k` is an optional argument to the function.\nk : scalar\n    An optional argument which is passed through to `mask_func`. Functions\n    like `triu`, `tril` take a second argument that is interpreted as an\n    offset.\n\nReturns\n-------\nindices : tuple of arrays.\n    The `n` arrays of indices corresponding to the locations where\n    ``mask_func(np.ones((n, n)), k)`` is True.\n\nSee Also\n--------\ntriu, tril, triu_indices, tril_indices\n\nExamples\n--------\n>>> import numpy as np\n\nThese are the indices that would allow you to access the upper triangular\npart of any 3x3 array:\n\n>>> iu = np.mask_indices(3, np.triu)\n\nFor example, if `a` is a 3x3 array:\n\n>>> a = np.arange(9).reshape(3, 3)\n>>> a\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n>>> a[iu]\narray([0, 1, 2, 4, 5, 8])\n\nAn offset can be passed also to the masking function.  This gets us the\nindices starting on the first diagonal right of the main one:\n\n>>> iu1 = np.mask_indices(3, np.triu, 1)\n\nwith which we now extract only three elements:\n\n>>> a[iu1]\narray([1, 2, 5])",
          "signature": "(n, mask_func, k=0)"
        },
        {
          "name": "mintypecode",
          "doc": "Return the character for the minimum-size type to which given types can\nbe safely cast.\n\nThe returned type character must represent the smallest size dtype such\nthat an array of the returned type can handle the data from an array of\nall types in `typechars` (or if `typechars` is an array, then its\ndtype.char).\n\nParameters\n----------\ntypechars : list of str or array_like\n    If a list of strings, each string should represent a dtype.\n    If array_like, the character representation of the array dtype is used.\ntypeset : str or list of str, optional\n    The set of characters that the returned character is chosen from.\n    The default set is 'GDFgdf'.\ndefault : str, optional\n    The default character, this is returned if none of the characters in\n    `typechars` matches a character in `typeset`.\n\nReturns\n-------\ntypechar : str\n    The character representing the minimum-size type that was found.\n\nSee Also\n--------\ndtype\n\nExamples\n--------\n>>> import numpy as np\n>>> np.mintypecode(['d', 'f', 'S'])\n'd'\n>>> x = np.array([1.1, 2-3.j])\n>>> np.mintypecode(x)\n'D'\n\n>>> np.mintypecode('abceh', default='G')\n'G'",
          "signature": "(typechars, typeset='GDFgdf', default='d')"
        },
        {
          "name": "ones",
          "doc": "Return a new array of given shape and type, filled with ones.\n\nParameters\n----------\nshape : int or sequence of ints\n    Shape of the new array, e.g., ``(2, 3)`` or ``2``.\ndtype : data-type, optional\n    The desired data-type for the array, e.g., `numpy.int8`.  Default is\n    `numpy.float64`.\norder : {'C', 'F'}, optional, default: C\n    Whether to store multi-dimensional data in row-major\n    (C-style) or column-major (Fortran-style) order in\n    memory.\ndevice : str, optional\n    The device on which to place the created array. Default: None.\n    For Array-API interoperability only, so must be ``\"cpu\"`` if passed.\n\n    .. versionadded:: 2.0.0\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not\n    NumPy arrays. If an array-like passed in as ``like`` supports\n    the ``__array_function__`` protocol, the result will be defined\n    by it. In this case, it ensures the creation of an array object\n    compatible with that passed in via this argument.\n\n    .. versionadded:: 1.20.0\n\nReturns\n-------\nout : ndarray\n    Array of ones with the given shape, dtype, and order.\n\nSee Also\n--------\nones_like : Return an array of ones with shape and type of input.\nempty : Return a new uninitialized array.\nzeros : Return a new array setting values to zero.\nfull : Return a new array of given shape filled with value.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.ones(5)\narray([1., 1., 1., 1., 1.])\n\n>>> np.ones((5,), dtype=int)\narray([1, 1, 1, 1, 1])\n\n>>> np.ones((2, 1))\narray([[1.],\n       [1.]])\n\n>>> s = (2,2)\n>>> np.ones(s)\narray([[1.,  1.],\n       [1.,  1.]])",
          "signature": "(shape, dtype=None, order='C', *, device=None, like=None)"
        },
        {
          "name": "printoptions",
          "doc": "Context manager for setting print options.\n\nSet print options for the scope of the `with` block, and restore the old\noptions at the end. See `set_printoptions` for the full description of\navailable options.\n\nExamples\n--------\n>>> import numpy as np\n\n>>> from numpy.testing import assert_equal\n>>> with np.printoptions(precision=2):\n...     np.array([2.0]) / 3\narray([0.67])\n\nThe `as`-clause of the `with`-statement gives the current print options:\n\n>>> with np.printoptions(precision=2) as opts:\n...      assert_equal(opts, np.get_printoptions())\n\nSee Also\n--------\nset_printoptions, get_printoptions",
          "signature": "(*args, **kwargs)"
        },
        {
          "name": "require",
          "doc": "Return an ndarray of the provided type that satisfies requirements.\n\nThis function is useful to be sure that an array with the correct flags\nis returned for passing to compiled code (perhaps through ctypes).\n\nParameters\n----------\na : array_like\n   The object to be converted to a type-and-requirement-satisfying array.\ndtype : data-type\n   The required data-type. If None preserve the current dtype. If your\n   application requires the data to be in native byteorder, include\n   a byteorder specification as a part of the dtype specification.\nrequirements : str or sequence of str\n   The requirements list can be any of the following\n\n   * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array\n   * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array\n   * 'ALIGNED' ('A')      - ensure a data-type aligned array\n   * 'WRITEABLE' ('W')    - ensure a writable array\n   * 'OWNDATA' ('O')      - ensure an array that owns its own data\n   * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not\n    NumPy arrays. If an array-like passed in as ``like`` supports\n    the ``__array_function__`` protocol, the result will be defined\n    by it. In this case, it ensures the creation of an array object\n    compatible with that passed in via this argument.\n\n    .. versionadded:: 1.20.0\n\nReturns\n-------\nout : ndarray\n    Array with specified requirements and type if given.\n\nSee Also\n--------\nasarray : Convert input to an ndarray.\nasanyarray : Convert to an ndarray, but pass through ndarray subclasses.\nascontiguousarray : Convert input to a contiguous array.\nasfortranarray : Convert input to an ndarray with column-major\n                 memory order.\nndarray.flags : Information about the memory layout of the array.\n\nNotes\n-----\nThe returned array will be guaranteed to have the listed requirements\nby making a copy if needed.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.arange(6).reshape(2,3)\n>>> x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n\n>>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\n>>> y.flags\n  C_CONTIGUOUS : False\n  F_CONTIGUOUS : True\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False",
          "signature": "(a, dtype=None, requirements=None, *, like=None)"
        },
        {
          "name": "row_stack",
          "doc": "Stack arrays in sequence vertically (row wise).\n\nThis is equivalent to concatenation along the first axis after 1-D arrays\nof shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by\n`vsplit`.\n\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions `concatenate`, `stack` and\n`block` provide more general stacking and concatenation operations.\n\nParameters\n----------\ntup : sequence of ndarrays\n    The arrays must have the same shape along all but the first axis.\n    1-D arrays must have the same length. In the case of a single\n    array_like input, it will be treated as a sequence of arrays; i.e.,\n    each element along the zeroth axis is treated as a separate array.\n\ndtype : str or dtype\n    If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\n\n    .. versionadded:: 1.24\n\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n    Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\n    .. versionadded:: 1.24\n\nReturns\n-------\nstacked : ndarray\n    The array formed by stacking the given arrays, will be at least 2-D.\n\nSee Also\n--------\nconcatenate : Join a sequence of arrays along an existing axis.\nstack : Join a sequence of arrays along a new axis.\nblock : Assemble an nd-array from nested lists of blocks.\nhstack : Stack arrays in sequence horizontally (column wise).\ndstack : Stack arrays in sequence depth wise (along third axis).\ncolumn_stack : Stack 1-D arrays as columns into a 2-D array.\nvsplit : Split an array into multiple sub-arrays vertically (row-wise).\nunstack : Split an array into a tuple of sub-arrays along an axis.\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array([1, 2, 3])\n>>> b = np.array([4, 5, 6])\n>>> np.vstack((a,b))\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n>>> a = np.array([[1], [2], [3]])\n>>> b = np.array([[4], [5], [6]])\n>>> np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [4],\n       [5],\n       [6]])",
          "signature": "(tup, *, dtype=None, casting='same_kind')"
        },
        {
          "name": "set_printoptions",
          "doc": "Set printing options.\n\nThese options determine the way floating point numbers, arrays and\nother NumPy objects are displayed.\n\nParameters\n----------\nprecision : int or None, optional\n    Number of digits of precision for floating point output (default 8).\n    May be None if `floatmode` is not `fixed`, to print as many digits as\n    necessary to uniquely specify the value.\nthreshold : int, optional\n    Total number of array elements which trigger summarization\n    rather than full repr (default 1000).\n    To always use the full repr without summarization, pass `sys.maxsize`.\nedgeitems : int, optional\n    Number of array items in summary at beginning and end of\n    each dimension (default 3).\nlinewidth : int, optional\n    The number of characters per line for the purpose of inserting\n    line breaks (default 75).\nsuppress : bool, optional\n    If True, always print floating point numbers using fixed point\n    notation, in which case numbers equal to zero in the current precision\n    will print as zero.  If False, then scientific notation is used when\n    absolute value of the smallest number is < 1e-4 or the ratio of the\n    maximum absolute value to the minimum is > 1e3. The default is False.\nnanstr : str, optional\n    String representation of floating point not-a-number (default nan).\ninfstr : str, optional\n    String representation of floating point infinity (default inf).\nsign : string, either '-', '+', or ' ', optional\n    Controls printing of the sign of floating-point types. If '+', always\n    print the sign of positive values. If ' ', always prints a space\n    (whitespace character) in the sign position of positive values.  If\n    '-', omit the sign character of positive values. (default '-')\n\n    .. versionchanged:: 2.0\n         The sign parameter can now be an integer type, previously\n         types were floating-point types.\n\nformatter : dict of callables, optional\n    If not None, the keys should indicate the type(s) that the respective\n    formatting function applies to.  Callables should return a string.\n    Types that are not specified (by their corresponding keys) are handled\n    by the default formatters.  Individual types for which a formatter\n    can be set are:\n\n    - 'bool'\n    - 'int'\n    - 'timedelta' : a `numpy.timedelta64`\n    - 'datetime' : a `numpy.datetime64`\n    - 'float'\n    - 'longfloat' : 128-bit floats\n    - 'complexfloat'\n    - 'longcomplexfloat' : composed of two 128-bit floats\n    - 'numpystr' : types `numpy.bytes_` and `numpy.str_`\n    - 'object' : `np.object_` arrays\n\n    Other keys that can be used to set a group of types at once are:\n\n    - 'all' : sets all types\n    - 'int_kind' : sets 'int'\n    - 'float_kind' : sets 'float' and 'longfloat'\n    - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'\n    - 'str_kind' : sets 'numpystr'\nfloatmode : str, optional\n    Controls the interpretation of the `precision` option for\n    floating-point types. Can take the following values\n    (default maxprec_equal):\n\n    * 'fixed': Always print exactly `precision` fractional digits,\n            even if this would print more or fewer digits than\n            necessary to specify the value uniquely.\n    * 'unique': Print the minimum number of fractional digits necessary\n            to represent each value uniquely. Different elements may\n            have a different number of digits. The value of the\n            `precision` option is ignored.\n    * 'maxprec': Print at most `precision` fractional digits, but if\n            an element can be uniquely represented with fewer digits\n            only print it with that many.\n    * 'maxprec_equal': Print at most `precision` fractional digits,\n            but if every element in the array can be uniquely\n            represented with an equal number of fewer digits, use that\n            many digits for all elements.\nlegacy : string or `False`, optional\n    If set to the string ``'1.13'`` enables 1.13 legacy printing mode. This\n    approximates numpy 1.13 print output by including a space in the sign\n    position of floats and different behavior for 0d arrays. This also\n    enables 1.21 legacy printing mode (described below).\n\n    If set to the string ``'1.21'`` enables 1.21 legacy printing mode. This\n    approximates numpy 1.21 print output of complex structured dtypes\n    by not inserting spaces after commas that separate fields and after\n    colons.\n\n    If set to ``'1.25'`` approximates printing of 1.25 which mainly means\n    that numeric scalars are printed without their type information, e.g.\n    as ``3.0`` rather than ``np.float64(3.0)``.\n\n    If set to ``'2.1'``, shape information is not given when arrays are\n    summarized (i.e., multiple elements replaced with ``...``).\n\n    If set to ``'2.2'``, the transition to use scientific notation for\n    printing ``np.float16`` and ``np.float32`` types may happen later or\n    not at all for larger values.\n\n    If set to `False`, disables legacy mode.\n\n    Unrecognized strings will be ignored with a warning for forward\n    compatibility.\n\n    .. versionchanged:: 1.22.0\n    .. versionchanged:: 2.2\n\noverride_repr: callable, optional\n    If set a passed function will be used for generating arrays' repr.\n    Other options will be ignored.\n\nSee Also\n--------\nget_printoptions, printoptions, array2string\n\nNotes\n-----\n`formatter` is always reset with a call to `set_printoptions`.\n\nUse `printoptions` as a context manager to set the values temporarily.\n\nExamples\n--------\nFloating point precision can be set:\n\n>>> import numpy as np\n>>> np.set_printoptions(precision=4)\n>>> np.array([1.123456789])\n[1.1235]\n\nLong arrays can be summarised:\n\n>>> np.set_printoptions(threshold=5)\n>>> np.arange(10)\narray([0, 1, 2, ..., 7, 8, 9], shape=(10,))\n\nSmall results can be suppressed:\n\n>>> eps = np.finfo(float).eps\n>>> x = np.arange(4.)\n>>> x**2 - (x + eps)**2\narray([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00])\n>>> np.set_printoptions(suppress=True)\n>>> x**2 - (x + eps)**2\narray([-0., -0.,  0.,  0.])\n\nA custom formatter can be used to display array elements as desired:\n\n>>> np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)})\n>>> x = np.arange(3)\n>>> x\narray([int: 0, int: -1, int: -2])\n>>> np.set_printoptions()  # formatter gets reset\n>>> x\narray([0, 1, 2])\n\nTo put back the default options, you can use:\n\n>>> np.set_printoptions(edgeitems=3, infstr='inf',\n... linewidth=75, nanstr='nan', precision=8,\n... suppress=False, threshold=1000, formatter=None)\n\nAlso to temporarily override options, use `printoptions`\nas a context manager:\n\n>>> with np.printoptions(precision=2, suppress=True, threshold=5):\n...     np.linspace(0, 10, 10)\narray([ 0.  ,  1.11,  2.22, ...,  7.78,  8.89, 10.  ], shape=(10,))",
          "signature": "(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None, formatter=None, sign=None, floatmode=None, *, legacy=None, override_repr=None)"
        },
        {
          "name": "setbufsize",
          "doc": "Set the size of the buffer used in ufuncs.\n\n.. versionchanged:: 2.0\n    The scope of setting the buffer is tied to the `numpy.errstate`\n    context.  Exiting a ``with errstate():`` will also restore the bufsize.\n\nParameters\n----------\nsize : int\n    Size of buffer.\n\nReturns\n-------\nbufsize : int\n    Previous size of ufunc buffer in bytes.\n\nExamples\n--------\nWhen exiting a `numpy.errstate` context manager the bufsize is restored:\n\n>>> import numpy as np\n>>> with np.errstate():\n...     np.setbufsize(4096)\n...     print(np.getbufsize())\n...\n8192\n4096\n>>> np.getbufsize()\n8192",
          "signature": "(size)"
        },
        {
          "name": "seterr",
          "doc": "Set how floating-point errors are handled.\n\nNote that operations on integer scalar types (such as `int16`) are\nhandled like floating point, and are affected by these settings.\n\nParameters\n----------\nall : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n    Set treatment for all types of floating-point errors at once:\n\n    - ignore: Take no action when the exception occurs.\n    - warn: Print a :exc:`RuntimeWarning` (via the Python `warnings`\n      module).\n    - raise: Raise a :exc:`FloatingPointError`.\n    - call: Call a function specified using the `seterrcall` function.\n    - print: Print a warning directly to ``stdout``.\n    - log: Record error in a Log object specified by `seterrcall`.\n\n    The default is not to change the current behavior.\ndivide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n    Treatment for division by zero.\nover : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n    Treatment for floating-point overflow.\nunder : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n    Treatment for floating-point underflow.\ninvalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional\n    Treatment for invalid floating-point operation.\n\nReturns\n-------\nold_settings : dict\n    Dictionary containing the old settings.\n\nSee also\n--------\nseterrcall : Set a callback function for the 'call' mode.\ngeterr, geterrcall, errstate\n\nNotes\n-----\nThe floating-point exceptions are defined in the IEEE 754 standard [1]_:\n\n- Division by zero: infinite result obtained from finite numbers.\n- Overflow: result too large to be expressed.\n- Underflow: result so close to zero that some precision\n  was lost.\n- Invalid operation: result is not an expressible number, typically\n  indicates that a NaN was produced.\n\n.. [1] https://en.wikipedia.org/wiki/IEEE_754\n\nExamples\n--------\n>>> import numpy as np\n>>> orig_settings = np.seterr(all='ignore')  # seterr to known value\n>>> np.int16(32000) * np.int16(3)\nnp.int16(30464)\n>>> np.seterr(over='raise')\n{'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}\n>>> old_settings = np.seterr(all='warn', over='raise')\n>>> np.int16(32000) * np.int16(3)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nFloatingPointError: overflow encountered in scalar multiply\n\n>>> old_settings = np.seterr(all='print')\n>>> np.geterr()\n{'divide': 'print', 'over': 'print', 'under': 'print', 'invalid': 'print'}\n>>> np.int16(32000) * np.int16(3)\nnp.int16(30464)\n>>> np.seterr(**orig_settings)  # restore original\n{'divide': 'print', 'over': 'print', 'under': 'print', 'invalid': 'print'}",
          "signature": "(all=None, divide=None, over=None, under=None, invalid=None)"
        },
        {
          "name": "seterrcall",
          "doc": "Set the floating-point error callback function or log object.\n\nThere are two ways to capture floating-point error messages.  The first\nis to set the error-handler to 'call', using `seterr`.  Then, set\nthe function to call using this function.\n\nThe second is to set the error-handler to 'log', using `seterr`.\nFloating-point errors then trigger a call to the 'write' method of\nthe provided object.\n\nParameters\n----------\nfunc : callable f(err, flag) or object with write method\n    Function to call upon floating-point errors ('call'-mode) or\n    object whose 'write' method is used to log such message ('log'-mode).\n\n    The call function takes two arguments. The first is a string describing\n    the type of error (such as \"divide by zero\", \"overflow\", \"underflow\",\n    or \"invalid value\"), and the second is the status flag.  The flag is a\n    byte, whose four least-significant bits indicate the type of error, one\n    of \"divide\", \"over\", \"under\", \"invalid\"::\n\n      [0 0 0 0 divide over under invalid]\n\n    In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.\n\n    If an object is provided, its write method should take one argument,\n    a string.\n\nReturns\n-------\nh : callable, log instance or None\n    The old error handler.\n\nSee Also\n--------\nseterr, geterr, geterrcall\n\nExamples\n--------\nCallback upon error:\n\n>>> def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n...\n\n>>> import numpy as np\n\n>>> orig_handler = np.seterrcall(err_handler)\n>>> orig_err = np.seterr(all='call')\n\n>>> np.array([1, 2, 3]) / 0.0\nFloating point error (divide by zero), with flag 1\narray([inf, inf, inf])\n\n>>> np.seterrcall(orig_handler)\n<function err_handler at 0x...>\n>>> np.seterr(**orig_err)\n{'divide': 'call', 'over': 'call', 'under': 'call', 'invalid': 'call'}\n\nLog error message:\n\n>>> class Log:\n...     def write(self, msg):\n...         print(\"LOG: %s\" % msg)\n...\n\n>>> log = Log()\n>>> saved_handler = np.seterrcall(log)\n>>> save_err = np.seterr(all='log')\n\n>>> np.array([1, 2, 3]) / 0.0\nLOG: Warning: divide by zero encountered in divide\narray([inf, inf, inf])\n\n>>> np.seterrcall(orig_handler)\n<numpy.Log object at 0x...>\n>>> np.seterr(**orig_err)\n{'divide': 'log', 'over': 'log', 'under': 'log', 'invalid': 'log'}",
          "signature": "(func)"
        },
        {
          "name": "show_config",
          "doc": "Show libraries and system information on which NumPy was built\nand is being used\n\nParameters\n----------\nmode : {`'stdout'`, `'dicts'`}, optional.\n    Indicates how to display the config information.\n    `'stdout'` prints to console, `'dicts'` returns a dictionary\n    of the configuration.\n\nReturns\n-------\nout : {`dict`, `None`}\n    If mode is `'dicts'`, a dict is returned, else None\n\nSee Also\n--------\nget_include : Returns the directory containing NumPy C\n              header files.\n\nNotes\n-----\n1. The `'stdout'` mode will give more readable\n   output if ``pyyaml`` is installed",
          "signature": "(mode='stdout')"
        },
        {
          "name": "show_runtime",
          "doc": "Print information about various resources in the system\nincluding available intrinsic support and BLAS/LAPACK library\nin use\n\n.. versionadded:: 1.24.0\n\nSee Also\n--------\nshow_config : Show libraries in the system on which NumPy was built.\n\nNotes\n-----\n1. Information is derived with the help of `threadpoolctl <https://pypi.org/project/threadpoolctl/>`_\n   library if available.\n2. SIMD related information is derived from ``__cpu_features__``,\n   ``__cpu_baseline__`` and ``__cpu_dispatch__``",
          "signature": "()"
        },
        {
          "name": "trapz",
          "doc": "`trapz` is deprecated in NumPy 2.0.\n\nPlease use `trapezoid` instead, or one of the numerical integration\nfunctions in `scipy.integrate`.",
          "signature": "(y, x=None, dx=1.0, axis=-1)"
        },
        {
          "name": "tri",
          "doc": "An array with ones at and below the given diagonal and zeros elsewhere.\n\nParameters\n----------\nN : int\n    Number of rows in the array.\nM : int, optional\n    Number of columns in the array.\n    By default, `M` is taken equal to `N`.\nk : int, optional\n    The sub-diagonal at and below which the array is filled.\n    `k` = 0 is the main diagonal, while `k` < 0 is below it,\n    and `k` > 0 is above.  The default is 0.\ndtype : dtype, optional\n    Data type of the returned array.  The default is float.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not\n    NumPy arrays. If an array-like passed in as ``like`` supports\n    the ``__array_function__`` protocol, the result will be defined\n    by it. In this case, it ensures the creation of an array object\n    compatible with that passed in via this argument.\n\n    .. versionadded:: 1.20.0\n\nReturns\n-------\ntri : ndarray of shape (N, M)\n    Array with its lower triangle filled with ones and zero elsewhere;\n    in other words ``T[i,j] == 1`` for ``j <= i + k``, 0 otherwise.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.tri(3, 5, 2, dtype=int)\narray([[1, 1, 1, 0, 0],\n       [1, 1, 1, 1, 0],\n       [1, 1, 1, 1, 1]])\n\n>>> np.tri(3, 5, -1)\narray([[0.,  0.,  0.,  0.,  0.],\n       [1.,  0.,  0.,  0.,  0.],\n       [1.,  1.,  0.,  0.,  0.]])",
          "signature": "(N, M=None, k=0, dtype=<class 'float'>, *, like=None)"
        },
        {
          "name": "tril_indices",
          "doc": "Return the indices for the lower-triangle of an (n, m) array.\n\nParameters\n----------\nn : int\n    The row dimension of the arrays for which the returned\n    indices will be valid.\nk : int, optional\n    Diagonal offset (see `tril` for details).\nm : int, optional\n    The column dimension of the arrays for which the returned\n    arrays will be valid.\n    By default `m` is taken equal to `n`.\n\n\nReturns\n-------\ninds : tuple of arrays\n    The row and column indices, respectively. The row indices are sorted\n    in non-decreasing order, and the correspdonding column indices are\n    strictly increasing for each row.\n\nSee also\n--------\ntriu_indices : similar function, for upper-triangular.\nmask_indices : generic function accepting an arbitrary mask function.\ntril, triu\n\nExamples\n--------\n>>> import numpy as np\n\nCompute two different sets of indices to access 4x4 arrays, one for the\nlower triangular part starting at the main diagonal, and one starting two\ndiagonals further right:\n\n>>> il1 = np.tril_indices(4)\n>>> il1\n(array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]), array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))\n\nNote that row indices (first array) are non-decreasing, and the corresponding\ncolumn indices (second array) are strictly increasing for each row.\nHere is how they can be used with a sample array:\n\n>>> a = np.arange(16).reshape(4, 4)\n>>> a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\nBoth for indexing:\n\n>>> a[il1]\narray([ 0,  4,  5, ..., 13, 14, 15])\n\nAnd for assigning values:\n\n>>> a[il1] = -1\n>>> a\narray([[-1,  1,  2,  3],\n       [-1, -1,  6,  7],\n       [-1, -1, -1, 11],\n       [-1, -1, -1, -1]])\n\nThese cover almost the whole array (two diagonals right of the main one):\n\n>>> il2 = np.tril_indices(4, 2)\n>>> a[il2] = -10\n>>> a\narray([[-10, -10, -10,   3],\n       [-10, -10, -10, -10],\n       [-10, -10, -10, -10],\n       [-10, -10, -10, -10]])",
          "signature": "(n, k=0, m=None)"
        },
        {
          "name": "triu_indices",
          "doc": "Return the indices for the upper-triangle of an (n, m) array.\n\nParameters\n----------\nn : int\n    The size of the arrays for which the returned indices will\n    be valid.\nk : int, optional\n    Diagonal offset (see `triu` for details).\nm : int, optional\n    The column dimension of the arrays for which the returned\n    arrays will be valid.\n    By default `m` is taken equal to `n`.\n\n\nReturns\n-------\ninds : tuple, shape(2) of ndarrays, shape(`n`)\n    The row and column indices, respectively. The row indices are sorted\n    in non-decreasing order, and the correspdonding column indices are\n    strictly increasing for each row.\n\nSee also\n--------\ntril_indices : similar function, for lower-triangular.\nmask_indices : generic function accepting an arbitrary mask function.\ntriu, tril\n\nExamples\n--------\n>>> import numpy as np\n\nCompute two different sets of indices to access 4x4 arrays, one for the\nupper triangular part starting at the main diagonal, and one starting two\ndiagonals further right:\n\n>>> iu1 = np.triu_indices(4)\n>>> iu1\n(array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]), array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))\n\nNote that row indices (first array) are non-decreasing, and the corresponding\ncolumn indices (second array) are strictly increasing for each row.\n\nHere is how they can be used with a sample array:\n\n>>> a = np.arange(16).reshape(4, 4)\n>>> a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\nBoth for indexing:\n\n>>> a[iu1]\narray([ 0,  1,  2, ..., 10, 11, 15])\n\nAnd for assigning values:\n\n>>> a[iu1] = -1\n>>> a\narray([[-1, -1, -1, -1],\n       [ 4, -1, -1, -1],\n       [ 8,  9, -1, -1],\n       [12, 13, 14, -1]])\n\nThese cover only a small part of the whole array (two diagonals right\nof the main one):\n\n>>> iu2 = np.triu_indices(4, 2)\n>>> a[iu2] = -10\n>>> a\narray([[ -1,  -1, -10, -10],\n       [  4,  -1,  -1, -10],\n       [  8,   9,  -1,  -1],\n       [ 12,  13,  14,  -1]])",
          "signature": "(n, k=0, m=None)"
        },
        {
          "name": "typename",
          "doc": "Return a description for the given data type code.\n\nParameters\n----------\nchar : str\n    Data type code.\n\nReturns\n-------\nout : str\n    Description of the input data type code.\n\nSee Also\n--------\ndtype\n\nExamples\n--------\n>>> import numpy as np\n>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n>>> for typechar in typechars:\n...     print(typechar, ' : ', np.typename(typechar))\n...\nS1  :  character\n?  :  bool\nB  :  unsigned char\nD  :  complex double precision\nG  :  complex long double precision\nF  :  complex single precision\nI  :  unsigned integer\nH  :  unsigned short\nL  :  unsigned long integer\nO  :  object\nQ  :  unsigned long long integer\nS  :  string\nU  :  unicode\nV  :  void\nb  :  signed char\nd  :  double precision\ng  :  long precision\nf  :  single precision\ni  :  integer\nh  :  short\nl  :  long integer\nq  :  long long integer",
          "signature": "(char)"
        }
      ],
      "classes": [
        {
          "name": "_CopyMode",
          "doc": "An enumeration for the copy modes supported\nby numpy.copy() and numpy.array(). The following three modes are supported,\n\n- ALWAYS: This means that a deep copy of the input\n          array will always be taken.\n- IF_NEEDED: This means that a deep copy of the input\n             array will be taken only if necessary.\n- NEVER: This means that the deep copy will never be taken.\n         If a copy cannot be avoided then a `ValueError` will be\n         raised.\n\nNote that the buffer-protocol could in theory do copies.  NumPy currently\nassumes an object exporting the buffer protocol will never do this.",
          "functions": []
        },
        {
          "name": "__array_namespace_info__",
          "doc": "Get the array API inspection namespace for NumPy.\n\nThe array API inspection namespace defines the following functions:\n\n- capabilities()\n- default_device()\n- default_dtypes()\n- dtypes()\n- devices()\n\nSee\nhttps://data-apis.org/array-api/latest/API_specification/inspection.html\nfor more details.\n\nReturns\n-------\ninfo : ModuleType\n    The array API inspection namespace for NumPy.\n\nExamples\n--------\n>>> info = np.__array_namespace_info__()\n>>> info.default_dtypes()\n{'real floating': numpy.float64,\n 'complex floating': numpy.complex128,\n 'integral': numpy.int64,\n 'indexing': numpy.int64}",
          "functions": [
            {
              "name": "capabilities",
              "doc": "Return a dictionary of array API library capabilities.\n\nThe resulting dictionary has the following keys:\n\n- **\"boolean indexing\"**: boolean indicating whether an array library\n  supports boolean indexing. Always ``True`` for NumPy.\n\n- **\"data-dependent shapes\"**: boolean indicating whether an array\n  library supports data-dependent output shapes. Always ``True`` for\n  NumPy.\n\nSee\nhttps://data-apis.org/array-api/latest/API_specification/generated/array_api.info.capabilities.html\nfor more details.\n\nSee Also\n--------\n__array_namespace_info__.default_device,\n__array_namespace_info__.default_dtypes,\n__array_namespace_info__.dtypes,\n__array_namespace_info__.devices\n\nReturns\n-------\ncapabilities : dict\n    A dictionary of array API library capabilities.\n\nExamples\n--------\n>>> info = np.__array_namespace_info__()\n>>> info.capabilities()\n{'boolean indexing': True,\n 'data-dependent shapes': True,\n 'max dimensions': 64}",
              "signature": "(self)"
            },
            {
              "name": "default_device",
              "doc": "The default device used for new NumPy arrays.\n\nFor NumPy, this always returns ``'cpu'``.\n\nSee Also\n--------\n__array_namespace_info__.capabilities,\n__array_namespace_info__.default_dtypes,\n__array_namespace_info__.dtypes,\n__array_namespace_info__.devices\n\nReturns\n-------\ndevice : str\n    The default device used for new NumPy arrays.\n\nExamples\n--------\n>>> info = np.__array_namespace_info__()\n>>> info.default_device()\n'cpu'",
              "signature": "(self)"
            },
            {
              "name": "default_dtypes",
              "doc": "The default data types used for new NumPy arrays.\n\nFor NumPy, this always returns the following dictionary:\n\n- **\"real floating\"**: ``numpy.float64``\n- **\"complex floating\"**: ``numpy.complex128``\n- **\"integral\"**: ``numpy.intp``\n- **\"indexing\"**: ``numpy.intp``\n\nParameters\n----------\ndevice : str, optional\n    The device to get the default data types for. For NumPy, only\n    ``'cpu'`` is allowed.\n\nReturns\n-------\ndtypes : dict\n    A dictionary describing the default data types used for new NumPy\n    arrays.\n\nSee Also\n--------\n__array_namespace_info__.capabilities,\n__array_namespace_info__.default_device,\n__array_namespace_info__.dtypes,\n__array_namespace_info__.devices\n\nExamples\n--------\n>>> info = np.__array_namespace_info__()\n>>> info.default_dtypes()\n{'real floating': numpy.float64,\n 'complex floating': numpy.complex128,\n 'integral': numpy.int64,\n 'indexing': numpy.int64}",
              "signature": "(self, *, device=None)"
            },
            {
              "name": "devices",
              "doc": "The devices supported by NumPy.\n\nFor NumPy, this always returns ``['cpu']``.\n\nReturns\n-------\ndevices : list of str\n    The devices supported by NumPy.\n\nSee Also\n--------\n__array_namespace_info__.capabilities,\n__array_namespace_info__.default_device,\n__array_namespace_info__.default_dtypes,\n__array_namespace_info__.dtypes\n\nExamples\n--------\n>>> info = np.__array_namespace_info__()\n>>> info.devices()\n['cpu']",
              "signature": "(self)"
            },
            {
              "name": "dtypes",
              "doc": "The array API data types supported by NumPy.\n\nNote that this function only returns data types that are defined by\nthe array API.\n\nParameters\n----------\ndevice : str, optional\n    The device to get the data types for. For NumPy, only ``'cpu'`` is\n    allowed.\nkind : str or tuple of str, optional\n    The kind of data types to return. If ``None``, all data types are\n    returned. If a string, only data types of that kind are returned.\n    If a tuple, a dictionary containing the union of the given kinds\n    is returned. The following kinds are supported:\n\n    - ``'bool'``: boolean data types (i.e., ``bool``).\n    - ``'signed integer'``: signed integer data types (i.e., ``int8``,\n      ``int16``, ``int32``, ``int64``).\n    - ``'unsigned integer'``: unsigned integer data types (i.e.,\n      ``uint8``, ``uint16``, ``uint32``, ``uint64``).\n    - ``'integral'``: integer data types. Shorthand for ``('signed\n      integer', 'unsigned integer')``.\n    - ``'real floating'``: real-valued floating-point data types\n      (i.e., ``float32``, ``float64``).\n    - ``'complex floating'``: complex floating-point data types (i.e.,\n      ``complex64``, ``complex128``).\n    - ``'numeric'``: numeric data types. Shorthand for ``('integral',\n      'real floating', 'complex floating')``.\n\nReturns\n-------\ndtypes : dict\n    A dictionary mapping the names of data types to the corresponding\n    NumPy data types.\n\nSee Also\n--------\n__array_namespace_info__.capabilities,\n__array_namespace_info__.default_device,\n__array_namespace_info__.default_dtypes,\n__array_namespace_info__.devices\n\nExamples\n--------\n>>> info = np.__array_namespace_info__()\n>>> info.dtypes(kind='signed integer')\n{'int8': numpy.int8,\n 'int16': numpy.int16,\n 'int32': numpy.int32,\n 'int64': numpy.int64}",
              "signature": "(self, *, device=None, kind=None)"
            }
          ]
        },
        {
          "name": "bool",
          "doc": "Boolean type (True or False), stored as a byte.\n\n.. warning::\n\n   The :class:`bool` type is not a subclass of the :class:`int_` type\n   (the :class:`bool` is not even a number type). This is different\n   than Python's default implementation of :class:`bool` as a\n   sub-class of :class:`int`.\n\n:Character code: ``'?'``",
          "functions": []
        },
        {
          "name": "bool",
          "doc": "Boolean type (True or False), stored as a byte.\n\n.. warning::\n\n   The :class:`bool` type is not a subclass of the :class:`int_` type\n   (the :class:`bool` is not even a number type). This is different\n   than Python's default implementation of :class:`bool` as a\n   sub-class of :class:`int`.\n\n:Character code: ``'?'``",
          "functions": []
        },
        {
          "name": "broadcast",
          "doc": "Produce an object that mimics broadcasting.\n\nParameters\n----------\nin1, in2, ... : array_like\n    Input parameters.\n\nReturns\n-------\nb : broadcast object\n    Broadcast the input parameters against one another, and\n    return an object that encapsulates the result.\n    Amongst others, it has ``shape`` and ``nd`` properties, and\n    may be used as an iterator.\n\nSee Also\n--------\nbroadcast_arrays\nbroadcast_to\nbroadcast_shapes\n\nExamples\n--------\n\nManually adding two vectors, using broadcasting:\n\n>>> import numpy as np\n>>> x = np.array([[1], [2], [3]])\n>>> y = np.array([4, 5, 6])\n>>> b = np.broadcast(x, y)\n\n>>> out = np.empty(b.shape)\n>>> out.flat = [u+v for (u,v) in b]\n>>> out\narray([[5.,  6.,  7.],\n       [6.,  7.,  8.],\n       [7.,  8.,  9.]])\n\nCompare against built-in broadcasting:\n\n>>> x + y\narray([[5, 6, 7],\n       [6, 7, 8],\n       [7, 8, 9]])",
          "functions": []
        },
        {
          "name": "busdaycalendar",
          "doc": "busdaycalendar(weekmask='1111100', holidays=None)\n\nA business day calendar object that efficiently stores information\ndefining valid days for the busday family of functions.\n\nThe default valid days are Monday through Friday (\"business days\").\nA busdaycalendar object can be specified with any set of weekly\nvalid days, plus an optional \"holiday\" dates that always will be invalid.\n\nOnce a busdaycalendar object is created, the weekmask and holidays\ncannot be modified.\n\nParameters\n----------\nweekmask : str or array_like of bool, optional\n    A seven-element array indicating which of Monday through Sunday are\n    valid days. May be specified as a length-seven list or array, like\n    [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string\n    like \"Mon Tue Wed Thu Fri\", made up of 3-character abbreviations for\n    weekdays, optionally separated by white space. Valid abbreviations\n    are: Mon Tue Wed Thu Fri Sat Sun\nholidays : array_like of datetime64[D], optional\n    An array of dates to consider as invalid dates, no matter which\n    weekday they fall upon.  Holiday dates may be specified in any\n    order, and NaT (not-a-time) dates are ignored.  This list is\n    saved in a normalized form that is suited for fast calculations\n    of valid days.\n\nReturns\n-------\nout : busdaycalendar\n    A business day calendar object containing the specified\n    weekmask and holidays values.\n\nSee Also\n--------\nis_busday : Returns a boolean array indicating valid days.\nbusday_offset : Applies an offset counted in valid days.\nbusday_count : Counts how many valid days are in a half-open date range.\n\nAttributes\n----------\nweekmask : (copy) seven-element array of bool\nholidays : (copy) sorted array of datetime64[D]\n\nNotes\n-----\nOnce a busdaycalendar object is created, you cannot modify the\nweekmask or holidays.  The attributes return copies of internal data.\n\nExamples\n--------\n>>> import numpy as np\n>>> # Some important days in July\n... bdd = np.busdaycalendar(\n...             holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\n>>> # Default is Monday to Friday weekdays\n... bdd.weekmask\narray([ True,  True,  True,  True,  True, False, False])\n>>> # Any holidays already on the weekend are removed\n... bdd.holidays\narray(['2011-07-01', '2011-07-04'], dtype='datetime64[D]')",
          "functions": []
        },
        {
          "name": "int8",
          "doc": "Signed integer type, compatible with C ``char``.\n\n:Character code: ``'b'``\n:Canonical name: `numpy.byte`\n:Alias on this platform (win32 AMD64): `numpy.int8`: 8-bit signed integer (``-128`` to ``127``).",
          "functions": []
        },
        {
          "name": "bytes_",
          "doc": "A byte string.\n\nWhen used in arrays, this type strips trailing null bytes.\n\n:Character code: ``'S'``",
          "functions": []
        },
        {
          "name": "complex128",
          "doc": "Complex number type composed of two double-precision floating-point\nnumbers, compatible with Python :class:`complex`.\n\n:Character code: ``'D'``\n:Canonical name: `numpy.cdouble`\n:Alias on this platform (win32 AMD64): `numpy.complex128`: Complex number type composed of 2 64-bit-precision floating-point numbers.",
          "functions": []
        },
        {
          "name": "character",
          "doc": "Abstract base class of all character string scalar types.",
          "functions": []
        },
        {
          "name": "clongdouble",
          "doc": "Complex number type composed of two extended-precision floating-point\nnumbers.\n\n:Character code: ``'G'``",
          "functions": []
        },
        {
          "name": "complex128",
          "doc": "Complex number type composed of two double-precision floating-point\nnumbers, compatible with Python :class:`complex`.\n\n:Character code: ``'D'``\n:Canonical name: `numpy.cdouble`\n:Alias on this platform (win32 AMD64): `numpy.complex128`: Complex number type composed of 2 64-bit-precision floating-point numbers.",
          "functions": []
        },
        {
          "name": "complex64",
          "doc": "Complex number type composed of two single-precision floating-point\nnumbers.\n\n:Character code: ``'F'``\n:Canonical name: `numpy.csingle`\n:Alias on this platform (win32 AMD64): `numpy.complex64`: Complex number type composed of 2 32-bit-precision floating-point numbers.",
          "functions": []
        },
        {
          "name": "complexfloating",
          "doc": "Abstract base class of all complex number scalar types that are made up of\nfloating-point numbers.",
          "functions": []
        },
        {
          "name": "complex64",
          "doc": "Complex number type composed of two single-precision floating-point\nnumbers.\n\n:Character code: ``'F'``\n:Canonical name: `numpy.csingle`\n:Alias on this platform (win32 AMD64): `numpy.complex64`: Complex number type composed of 2 32-bit-precision floating-point numbers.",
          "functions": []
        },
        {
          "name": "datetime64",
          "doc": "If created from a 64-bit integer, it represents an offset from\n``1970-01-01T00:00:00``.\nIf created from string, the string can be in ISO 8601 date\nor datetime format.\n\nWhen parsing a string to create a datetime object, if the string contains\na trailing timezone (A 'Z' or a timezone offset), the timezone will be\ndropped and a User Warning is given.\n\nDatetime64 objects should be considered to be UTC and therefore have an\noffset of +0000.\n\n>>> np.datetime64(10, 'Y')\nnp.datetime64('1980')\n>>> np.datetime64('1980', 'Y')\nnp.datetime64('1980')\n>>> np.datetime64(10, 'D')\nnp.datetime64('1970-01-11')\n\nSee :ref:`arrays.datetime` for more information.\n\n:Character code: ``'M'``",
          "functions": []
        },
        {
          "name": "float64",
          "doc": "Double-precision floating-point number type, compatible with Python\n:class:`float` and C ``double``.\n\n:Character code: ``'d'``\n:Canonical name: `numpy.double`\n:Alias on this platform (win32 AMD64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.",
          "functions": []
        },
        {
          "name": "dtype",
          "doc": "dtype(dtype, align=False, copy=False, [metadata])\n\nCreate a data type object.\n\nA numpy array is homogeneous, and contains elements described by a\ndtype object. A dtype object can be constructed from different\ncombinations of fundamental numeric types.\n\nParameters\n----------\ndtype\n    Object to be converted to a data type object.\nalign : bool, optional\n    Add padding to the fields to match what a C compiler would output\n    for a similar C-struct. Can be ``True`` only if `obj` is a dictionary\n    or a comma-separated string. If a struct dtype is being created,\n    this also sets a sticky alignment flag ``isalignedstruct``.\ncopy : bool, optional\n    Make a new copy of the data-type object. If ``False``, the result\n    may just be a reference to a built-in data-type object.\nmetadata : dict, optional\n    An optional dictionary with dtype metadata.\n\nSee also\n--------\nresult_type\n\nExamples\n--------\nUsing array-scalar type:\n\n>>> import numpy as np\n>>> np.dtype(np.int16)\ndtype('int16')\n\nStructured type, one field name 'f1', containing int16:\n\n>>> np.dtype([('f1', np.int16)])\ndtype([('f1', '<i2')])\n\nStructured type, one field named 'f1', in itself containing a structured\ntype with one field:\n\n>>> np.dtype([('f1', [('f1', np.int16)])])\ndtype([('f1', [('f1', '<i2')])])\n\nStructured type, two fields: the first field contains an unsigned int, the\nsecond an int32:\n\n>>> np.dtype([('f1', np.uint64), ('f2', np.int32)])\ndtype([('f1', '<u8'), ('f2', '<i4')])\n\nUsing array-protocol type strings:\n\n>>> np.dtype([('a','f8'),('b','S10')])\ndtype([('a', '<f8'), ('b', 'S10')])\n\nUsing comma-separated field formats.  The shape is (2,3):\n\n>>> np.dtype(\"i4, (2,3)f8\")\ndtype([('f0', '<i4'), ('f1', '<f8', (2, 3))])\n\nUsing tuples.  ``int`` is a fixed type, 3 the field's shape.  ``void``\nis a flexible type, here of size 10:\n\n>>> np.dtype([('hello',(np.int64,3)),('world',np.void,10)])\ndtype([('hello', '<i8', (3,)), ('world', 'V10')])\n\nSubdivide ``int16`` into 2 ``int8``'s, called x and y.  0 and 1 are\nthe offsets in bytes:\n\n>>> np.dtype((np.int16, {'x':(np.int8,0), 'y':(np.int8,1)}))\ndtype((numpy.int16, [('x', 'i1'), ('y', 'i1')]))\n\nUsing dictionaries.  Two fields named 'gender' and 'age':\n\n>>> np.dtype({'names':['gender','age'], 'formats':['S1',np.uint8]})\ndtype([('gender', 'S1'), ('age', 'u1')])\n\nOffsets in bytes, here 0 and 25:\n\n>>> np.dtype({'surname':('S25',0),'age':(np.uint8,25)})\ndtype([('surname', 'S25'), ('age', 'u1')])",
          "functions": []
        },
        {
          "name": "errstate",
          "doc": "errstate(**kwargs)\n\nContext manager for floating-point error handling.\n\nUsing an instance of `errstate` as a context manager allows statements in\nthat context to execute with a known error handling behavior. Upon entering\nthe context the error handling is set with `seterr` and `seterrcall`, and\nupon exiting it is reset to what it was before.\n\n..  versionchanged:: 1.17.0\n    `errstate` is also usable as a function decorator, saving\n    a level of indentation if an entire function is wrapped.\n\n.. versionchanged:: 2.0\n    `errstate` is now fully thread and asyncio safe, but may not be\n    entered more than once.\n    It is not safe to decorate async functions using ``errstate``.\n\nParameters\n----------\nkwargs : {divide, over, under, invalid}\n    Keyword arguments. The valid keywords are the possible floating-point\n    exceptions. Each keyword should have a string value that defines the\n    treatment for the particular error. Possible values are\n    {'ignore', 'warn', 'raise', 'call', 'print', 'log'}.\n\nSee Also\n--------\nseterr, geterr, seterrcall, geterrcall\n\nNotes\n-----\nFor complete documentation of the types of floating-point exceptions and\ntreatment options, see `seterr`.\n\nExamples\n--------\n>>> import numpy as np\n>>> olderr = np.seterr(all='ignore')  # Set error handling to known state.\n\n>>> np.arange(3) / 0.\narray([nan, inf, inf])\n>>> with np.errstate(divide='ignore'):\n...     np.arange(3) / 0.\narray([nan, inf, inf])\n\n>>> np.sqrt(-1)\nnp.float64(nan)\n>>> with np.errstate(invalid='raise'):\n...     np.sqrt(-1)\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\nFloatingPointError: invalid value encountered in sqrt\n\nOutside the context the error handling behavior has not changed:\n\n>>> np.geterr()\n{'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}\n>>> olderr = np.seterr(**olderr)  # restore original state",
          "functions": [
            {
              "name": "__call__",
              "doc": "Call self as a function.",
              "signature": "(self, func)"
            },
            {
              "name": "__enter__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__exit__",
              "doc": null,
              "signature": "(self, *exc_info)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, *, call=<numpy._core._ufunc_config._unspecified object at 0x0000023EF8C03350>, all=None, divide=None, over=None, under=None, invalid=None)"
            }
          ]
        },
        {
          "name": "finfo",
          "doc": "finfo(dtype)\n\nMachine limits for floating point types.\n\nAttributes\n----------\nbits : int\n    The number of bits occupied by the type.\ndtype : dtype\n    Returns the dtype for which `finfo` returns information. For complex\n    input, the returned dtype is the associated ``float*`` dtype for its\n    real and complex components.\neps : float\n    The difference between 1.0 and the next smallest representable float\n    larger than 1.0. For example, for 64-bit binary floats in the IEEE-754\n    standard, ``eps = 2**-52``, approximately 2.22e-16.\nepsneg : float\n    The difference between 1.0 and the next smallest representable float\n    less than 1.0. For example, for 64-bit binary floats in the IEEE-754\n    standard, ``epsneg = 2**-53``, approximately 1.11e-16.\niexp : int\n    The number of bits in the exponent portion of the floating point\n    representation.\nmachep : int\n    The exponent that yields `eps`.\nmax : floating point number of the appropriate type\n    The largest representable number.\nmaxexp : int\n    The smallest positive power of the base (2) that causes overflow.\nmin : floating point number of the appropriate type\n    The smallest representable number, typically ``-max``.\nminexp : int\n    The most negative power of the base (2) consistent with there\n    being no leading 0's in the mantissa.\nnegep : int\n    The exponent that yields `epsneg`.\nnexp : int\n    The number of bits in the exponent including its sign and bias.\nnmant : int\n    The number of bits in the mantissa.\nprecision : int\n    The approximate number of decimal digits to which this kind of\n    float is precise.\nresolution : floating point number of the appropriate type\n    The approximate decimal resolution of this type, i.e.,\n    ``10**-precision``.\ntiny : float\n    An alias for `smallest_normal`, kept for backwards compatibility.\nsmallest_normal : float\n    The smallest positive floating point number with 1 as leading bit in\n    the mantissa following IEEE-754 (see Notes).\nsmallest_subnormal : float\n    The smallest positive floating point number with 0 as leading bit in\n    the mantissa following IEEE-754.\n\nParameters\n----------\ndtype : float, dtype, or instance\n    Kind of floating point or complex floating point\n    data-type about which to get information.\n\nSee Also\n--------\niinfo : The equivalent for integer data types.\nspacing : The distance between a value and the nearest adjacent number\nnextafter : The next floating point value after x1 towards x2\n\nNotes\n-----\nFor developers of NumPy: do not instantiate this at the module level.\nThe initial calculation of these parameters is expensive and negatively\nimpacts import times.  These objects are cached, so calling ``finfo()``\nrepeatedly inside your functions is not a problem.\n\nNote that ``smallest_normal`` is not actually the smallest positive\nrepresentable value in a NumPy floating point type. As in the IEEE-754\nstandard [1]_, NumPy floating point types make use of subnormal numbers to\nfill the gap between 0 and ``smallest_normal``. However, subnormal numbers\nmay have significantly reduced precision [2]_.\n\nThis function can also be used for complex data types as well. If used,\nthe output will be the same as the corresponding real float type\n(e.g. numpy.finfo(numpy.csingle) is the same as numpy.finfo(numpy.single)).\nHowever, the output is true for the real and imaginary components.\n\nReferences\n----------\n.. [1] IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,\n       pp.1-70, 2008, https://doi.org/10.1109/IEEESTD.2008.4610935\n.. [2] Wikipedia, \"Denormal Numbers\",\n       https://en.wikipedia.org/wiki/Denormal_number\n\nExamples\n--------\n>>> import numpy as np\n>>> np.finfo(np.float64).dtype\ndtype('float64')\n>>> np.finfo(np.complex64).dtype\ndtype('float32')",
          "functions": [
            {
              "name": "__new__",
              "doc": "Create and return a new object.  See help(type) for accurate signature.",
              "signature": "(cls, dtype)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self)"
            },
            {
              "name": "_init",
              "doc": null,
              "signature": "(self, dtype)"
            }
          ]
        },
        {
          "name": "flatiter",
          "doc": "Flat iterator object to iterate over arrays.\n\nA `flatiter` iterator is returned by ``x.flat`` for any array `x`.\nIt allows iterating over the array as if it were a 1-D array,\neither in a for-loop or by calling its `next` method.\n\nIteration is done in row-major, C-style order (the last\nindex varying the fastest). The iterator can also be indexed using\nbasic slicing or advanced indexing.\n\nSee Also\n--------\nndarray.flat : Return a flat iterator over an array.\nndarray.flatten : Returns a flattened copy of an array.\n\nNotes\n-----\nA `flatiter` iterator can not be constructed directly from Python code\nby calling the `flatiter` constructor.\n\nExamples\n--------\n>>> import numpy as np\n>>> x = np.arange(6).reshape(2, 3)\n>>> fl = x.flat\n>>> type(fl)\n<class 'numpy.flatiter'>\n>>> for item in fl:\n...     print(item)\n...\n0\n1\n2\n3\n4\n5\n\n>>> fl[2:4]\narray([2, 3])",
          "functions": []
        },
        {
          "name": "flexible",
          "doc": "Abstract base class of all scalar types without predefined length.\nThe actual size of these types depends on the specific `numpy.dtype`\ninstantiation.",
          "functions": []
        },
        {
          "name": "float16",
          "doc": "Half-precision floating-point number type.\n\n:Character code: ``'e'``\n:Canonical name: `numpy.half`\n:Alias on this platform (win32 AMD64): `numpy.float16`: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.",
          "functions": []
        },
        {
          "name": "float32",
          "doc": "Single-precision floating-point number type, compatible with C ``float``.\n\n:Character code: ``'f'``\n:Canonical name: `numpy.single`\n:Alias on this platform (win32 AMD64): `numpy.float32`: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.",
          "functions": []
        },
        {
          "name": "float64",
          "doc": "Double-precision floating-point number type, compatible with Python\n:class:`float` and C ``double``.\n\n:Character code: ``'d'``\n:Canonical name: `numpy.double`\n:Alias on this platform (win32 AMD64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.",
          "functions": []
        },
        {
          "name": "floating",
          "doc": "Abstract base class of all floating-point scalar types.",
          "functions": []
        },
        {
          "name": "generic",
          "doc": "Base class for numpy scalar types.\n\nClass from which most (all?) numpy scalar types are derived.  For\nconsistency, exposes the same API as `ndarray`, despite many\nconsequent attributes being either \"get-only,\" or completely irrelevant.\nThis is the class from which it is strongly suggested users should derive\ncustom scalar types.",
          "functions": []
        },
        {
          "name": "float16",
          "doc": "Half-precision floating-point number type.\n\n:Character code: ``'e'``\n:Canonical name: `numpy.half`\n:Alias on this platform (win32 AMD64): `numpy.float16`: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.",
          "functions": []
        },
        {
          "name": "iinfo",
          "doc": "iinfo(type)\n\nMachine limits for integer types.\n\nAttributes\n----------\nbits : int\n    The number of bits occupied by the type.\ndtype : dtype\n    Returns the dtype for which `iinfo` returns information.\nmin : int\n    The smallest integer expressible by the type.\nmax : int\n    The largest integer expressible by the type.\n\nParameters\n----------\nint_type : integer type, dtype, or instance\n    The kind of integer data type to get information about.\n\nSee Also\n--------\nfinfo : The equivalent for floating point data types.\n\nExamples\n--------\nWith types:\n\n>>> import numpy as np\n>>> ii16 = np.iinfo(np.int16)\n>>> ii16.min\n-32768\n>>> ii16.max\n32767\n>>> ii32 = np.iinfo(np.int32)\n>>> ii32.min\n-2147483648\n>>> ii32.max\n2147483647\n\nWith instances:\n\n>>> ii32 = np.iinfo(np.int32(10))\n>>> ii32.min\n-2147483648\n>>> ii32.max\n2147483647",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, int_type)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__str__",
              "doc": "String representation.",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "inexact",
          "doc": "Abstract base class of all numeric scalar types with a (potentially)\ninexact representation of the values in its range, such as\nfloating-point numbers.",
          "functions": []
        },
        {
          "name": "int16",
          "doc": "Signed integer type, compatible with C ``short``.\n\n:Character code: ``'h'``\n:Canonical name: `numpy.short`\n:Alias on this platform (win32 AMD64): `numpy.int16`: 16-bit signed integer (``-32_768`` to ``32_767``).",
          "functions": []
        },
        {
          "name": "int32",
          "doc": "Abstract base class of all signed integer scalar types.",
          "functions": []
        },
        {
          "name": "int64",
          "doc": "Default signed integer type, 64bit on 64bit systems and 32bit on 32bit\nsystems.\n\n:Character code: ``'q'``\n:Canonical name: `numpy.int_`\n:Alias on this platform (win32 AMD64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).\n:Alias on this platform (win32 AMD64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.",
          "functions": []
        },
        {
          "name": "int8",
          "doc": "Signed integer type, compatible with C ``char``.\n\n:Character code: ``'b'``\n:Canonical name: `numpy.byte`\n:Alias on this platform (win32 AMD64): `numpy.int8`: 8-bit signed integer (``-128`` to ``127``).",
          "functions": []
        },
        {
          "name": "int64",
          "doc": "Default signed integer type, 64bit on 64bit systems and 32bit on 32bit\nsystems.\n\n:Character code: ``'q'``\n:Canonical name: `numpy.int_`\n:Alias on this platform (win32 AMD64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).\n:Alias on this platform (win32 AMD64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.",
          "functions": []
        },
        {
          "name": "intc",
          "doc": "Signed integer type, compatible with C ``int``.\n\n:Character code: ``'i'``",
          "functions": []
        },
        {
          "name": "integer",
          "doc": "Abstract base class of all integer scalar types.",
          "functions": []
        },
        {
          "name": "int64",
          "doc": "Default signed integer type, 64bit on 64bit systems and 32bit on 32bit\nsystems.\n\n:Character code: ``'q'``\n:Canonical name: `numpy.int_`\n:Alias on this platform (win32 AMD64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).\n:Alias on this platform (win32 AMD64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.",
          "functions": []
        },
        {
          "name": "int32",
          "doc": "Abstract base class of all signed integer scalar types.",
          "functions": []
        },
        {
          "name": "longdouble",
          "doc": "Extended-precision floating-point number type, compatible with C\n``long double`` but not necessarily with IEEE 754 quadruple-precision.\n\n:Character code: ``'g'``",
          "functions": []
        },
        {
          "name": "int64",
          "doc": "Default signed integer type, 64bit on 64bit systems and 32bit on 32bit\nsystems.\n\n:Character code: ``'q'``\n:Canonical name: `numpy.int_`\n:Alias on this platform (win32 AMD64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).\n:Alias on this platform (win32 AMD64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.",
          "functions": []
        },
        {
          "name": "matrix",
          "doc": "matrix(data, dtype=None, copy=True)\n\nReturns a matrix from an array-like object, or from a string of data.\n\nA matrix is a specialized 2-D array that retains its 2-D nature\nthrough operations.  It has certain special operators, such as ``*``\n(matrix multiplication) and ``**`` (matrix power).\n\n.. note:: It is no longer recommended to use this class, even for linear\n          algebra. Instead use regular arrays. The class may be removed\n          in the future.\n\nParameters\n----------\ndata : array_like or string\n   If `data` is a string, it is interpreted as a matrix with commas\n   or spaces separating columns, and semicolons separating rows.\ndtype : data-type\n   Data-type of the output matrix.\ncopy : bool\n   If `data` is already an `ndarray`, then this flag determines\n   whether the data is copied (the default), or whether a view is\n   constructed.\n\nSee Also\n--------\narray\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.matrix('1 2; 3 4')\n>>> a\nmatrix([[1, 2],\n        [3, 4]])\n\n>>> np.matrix([[1, 2], [3, 4]])\nmatrix([[1, 2],\n        [3, 4]])",
          "functions": [
            {
              "name": "__array_finalize__",
              "doc": "a.__array_finalize__(obj, /)\n\nPresent so subclasses can call super. Does nothing.",
              "signature": "(self, obj)"
            },
            {
              "name": "__getitem__",
              "doc": "Return self[key].",
              "signature": "(self, index)"
            },
            {
              "name": "__imul__",
              "doc": "Return self*=value.",
              "signature": "(self, other)"
            },
            {
              "name": "__ipow__",
              "doc": "Return self**=value.",
              "signature": "(self, other)"
            },
            {
              "name": "__mul__",
              "doc": "Return self*value.",
              "signature": "(self, other)"
            },
            {
              "name": "__new__",
              "doc": "Create and return a new object.  See help(type) for accurate signature.",
              "signature": "(subtype, data, dtype=None, copy=True)"
            },
            {
              "name": "__pow__",
              "doc": "Return pow(self, value, mod).",
              "signature": "(self, other)"
            },
            {
              "name": "__rmul__",
              "doc": "Return value*self.",
              "signature": "(self, other)"
            },
            {
              "name": "__rpow__",
              "doc": "Return pow(value, self, mod).",
              "signature": "(self, other)"
            },
            {
              "name": "_align",
              "doc": "A convenience function for operations that need to preserve axis\norientation.",
              "signature": "(self, axis)"
            },
            {
              "name": "_collapse",
              "doc": "A convenience function for operations that want to collapse\nto a scalar like _align, but are using keepdims=True",
              "signature": "(self, axis)"
            },
            {
              "name": "all",
              "doc": "Test whether all matrix elements along a given axis evaluate to True.\n\nParameters\n----------\nSee `numpy.all` for complete descriptions\n\nSee Also\n--------\nnumpy.all\n\nNotes\n-----\nThis is the same as `ndarray.all`, but it returns a `matrix` object.\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> y = x[0]; y\nmatrix([[0, 1, 2, 3]])\n>>> (x == y)\nmatrix([[ True,  True,  True,  True],\n        [False, False, False, False],\n        [False, False, False, False]])\n>>> (x == y).all()\nFalse\n>>> (x == y).all(0)\nmatrix([[False, False, False, False]])\n>>> (x == y).all(1)\nmatrix([[ True],\n        [False],\n        [False]])",
              "signature": "(self, axis=None, out=None)"
            },
            {
              "name": "any",
              "doc": "Test whether any array element along a given axis evaluates to True.\n\nRefer to `numpy.any` for full documentation.\n\nParameters\n----------\naxis : int, optional\n    Axis along which logical OR is performed\nout : ndarray, optional\n    Output to existing array instead of creating new one, must have\n    same shape as expected output\n\nReturns\n-------\n    any : bool, ndarray\n        Returns a single bool if `axis` is ``None``; otherwise,\n        returns `ndarray`",
              "signature": "(self, axis=None, out=None)"
            },
            {
              "name": "argmax",
              "doc": "Indexes of the maximum values along an axis.\n\nReturn the indexes of the first occurrences of the maximum values\nalong the specified axis.  If axis is None, the index is for the\nflattened matrix.\n\nParameters\n----------\nSee `numpy.argmax` for complete descriptions\n\nSee Also\n--------\nnumpy.argmax\n\nNotes\n-----\nThis is the same as `ndarray.argmax`, but returns a `matrix` object\nwhere `ndarray.argmax` would return an `ndarray`.\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.argmax()\n11\n>>> x.argmax(0)\nmatrix([[2, 2, 2, 2]])\n>>> x.argmax(1)\nmatrix([[3],\n        [3],\n        [3]])",
              "signature": "(self, axis=None, out=None)"
            },
            {
              "name": "argmin",
              "doc": "Indexes of the minimum values along an axis.\n\nReturn the indexes of the first occurrences of the minimum values\nalong the specified axis.  If axis is None, the index is for the\nflattened matrix.\n\nParameters\n----------\nSee `numpy.argmin` for complete descriptions.\n\nSee Also\n--------\nnumpy.argmin\n\nNotes\n-----\nThis is the same as `ndarray.argmin`, but returns a `matrix` object\nwhere `ndarray.argmin` would return an `ndarray`.\n\nExamples\n--------\n>>> x = -np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]])\n>>> x.argmin()\n11\n>>> x.argmin(0)\nmatrix([[2, 2, 2, 2]])\n>>> x.argmin(1)\nmatrix([[3],\n        [3],\n        [3]])",
              "signature": "(self, axis=None, out=None)"
            },
            {
              "name": "flatten",
              "doc": "Return a flattened copy of the matrix.\n\nAll `N` elements of the matrix are placed into a single row.\n\nParameters\n----------\norder : {'C', 'F', 'A', 'K'}, optional\n    'C' means to flatten in row-major (C-style) order. 'F' means to\n    flatten in column-major (Fortran-style) order. 'A' means to\n    flatten in column-major order if `m` is Fortran *contiguous* in\n    memory, row-major order otherwise. 'K' means to flatten `m` in\n    the order the elements occur in memory. The default is 'C'.\n\nReturns\n-------\ny : matrix\n    A copy of the matrix, flattened to a `(1, N)` matrix where `N`\n    is the number of elements in the original matrix.\n\nSee Also\n--------\nravel : Return a flattened array.\nflat : A 1-D flat iterator over the matrix.\n\nExamples\n--------\n>>> m = np.matrix([[1,2], [3,4]])\n>>> m.flatten()\nmatrix([[1, 2, 3, 4]])\n>>> m.flatten('F')\nmatrix([[1, 3, 2, 4]])",
              "signature": "(self, order='C')"
            },
            {
              "name": "getA",
              "doc": "Return `self` as an `ndarray` object.\n\nEquivalent to ``np.asarray(self)``.\n\nParameters\n----------\nNone\n\nReturns\n-------\nret : ndarray\n    `self` as an `ndarray`\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.getA()\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])",
              "signature": "(self)"
            },
            {
              "name": "getA1",
              "doc": "Return `self` as a flattened `ndarray`.\n\nEquivalent to ``np.asarray(x).ravel()``\n\nParameters\n----------\nNone\n\nReturns\n-------\nret : ndarray\n    `self`, 1-D, as an `ndarray`\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.getA1()\narray([ 0,  1,  2, ...,  9, 10, 11])",
              "signature": "(self)"
            },
            {
              "name": "getH",
              "doc": "Returns the (complex) conjugate transpose of `self`.\n\nEquivalent to ``np.transpose(self)`` if `self` is real-valued.\n\nParameters\n----------\nNone\n\nReturns\n-------\nret : matrix object\n    complex conjugate transpose of `self`\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3,4)))\n>>> z = x - 1j*x; z\nmatrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],\n        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],\n        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])\n>>> z.getH()\nmatrix([[ 0. -0.j,  4. +4.j,  8. +8.j],\n        [ 1. +1.j,  5. +5.j,  9. +9.j],\n        [ 2. +2.j,  6. +6.j, 10.+10.j],\n        [ 3. +3.j,  7. +7.j, 11.+11.j]])",
              "signature": "(self)"
            },
            {
              "name": "getI",
              "doc": "Returns the (multiplicative) inverse of invertible `self`.\n\nParameters\n----------\nNone\n\nReturns\n-------\nret : matrix object\n    If `self` is non-singular, `ret` is such that ``ret * self`` ==\n    ``self * ret`` == ``np.matrix(np.eye(self[0,:].size))`` all return\n    ``True``.\n\nRaises\n------\nnumpy.linalg.LinAlgError: Singular matrix\n    If `self` is singular.\n\nSee Also\n--------\nlinalg.inv\n\nExamples\n--------\n>>> m = np.matrix('[1, 2; 3, 4]'); m\nmatrix([[1, 2],\n        [3, 4]])\n>>> m.getI()\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n>>> m.getI() * m\nmatrix([[ 1.,  0.], # may vary\n        [ 0.,  1.]])",
              "signature": "(self)"
            },
            {
              "name": "getT",
              "doc": "Returns the transpose of the matrix.\n\nDoes *not* conjugate!  For the complex conjugate transpose, use ``.H``.\n\nParameters\n----------\nNone\n\nReturns\n-------\nret : matrix object\n    The (non-conjugated) transpose of the matrix.\n\nSee Also\n--------\ntranspose, getH\n\nExamples\n--------\n>>> m = np.matrix('[1, 2; 3, 4]')\n>>> m\nmatrix([[1, 2],\n        [3, 4]])\n>>> m.getT()\nmatrix([[1, 3],\n        [2, 4]])",
              "signature": "(self)"
            },
            {
              "name": "max",
              "doc": "Return the maximum value along an axis.\n\nParameters\n----------\nSee `amax` for complete descriptions\n\nSee Also\n--------\namax, ndarray.max\n\nNotes\n-----\nThis is the same as `ndarray.max`, but returns a `matrix` object\nwhere `ndarray.max` would return an ndarray.\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.max()\n11\n>>> x.max(0)\nmatrix([[ 8,  9, 10, 11]])\n>>> x.max(1)\nmatrix([[ 3],\n        [ 7],\n        [11]])",
              "signature": "(self, axis=None, out=None)"
            },
            {
              "name": "mean",
              "doc": "Returns the average of the matrix elements along the given axis.\n\nRefer to `numpy.mean` for full documentation.\n\nSee Also\n--------\nnumpy.mean\n\nNotes\n-----\nSame as `ndarray.mean` except that, where that returns an `ndarray`,\nthis returns a `matrix` object.\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3, 4)))\n>>> x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.mean()\n5.5\n>>> x.mean(0)\nmatrix([[4., 5., 6., 7.]])\n>>> x.mean(1)\nmatrix([[ 1.5],\n        [ 5.5],\n        [ 9.5]])",
              "signature": "(self, axis=None, dtype=None, out=None)"
            },
            {
              "name": "min",
              "doc": "Return the minimum value along an axis.\n\nParameters\n----------\nSee `amin` for complete descriptions.\n\nSee Also\n--------\namin, ndarray.min\n\nNotes\n-----\nThis is the same as `ndarray.min`, but returns a `matrix` object\nwhere `ndarray.min` would return an ndarray.\n\nExamples\n--------\n>>> x = -np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]])\n>>> x.min()\n-11\n>>> x.min(0)\nmatrix([[ -8,  -9, -10, -11]])\n>>> x.min(1)\nmatrix([[ -3],\n        [ -7],\n        [-11]])",
              "signature": "(self, axis=None, out=None)"
            },
            {
              "name": "prod",
              "doc": "Return the product of the array elements over the given axis.\n\nRefer to `prod` for full documentation.\n\nSee Also\n--------\nprod, ndarray.prod\n\nNotes\n-----\nSame as `ndarray.prod`, except, where that returns an `ndarray`, this\nreturns a `matrix` object instead.\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.prod()\n0\n>>> x.prod(0)\nmatrix([[  0,  45, 120, 231]])\n>>> x.prod(1)\nmatrix([[   0],\n        [ 840],\n        [7920]])",
              "signature": "(self, axis=None, dtype=None, out=None)"
            },
            {
              "name": "ptp",
              "doc": "Peak-to-peak (maximum - minimum) value along the given axis.\n\nRefer to `numpy.ptp` for full documentation.\n\nSee Also\n--------\nnumpy.ptp\n\nNotes\n-----\nSame as `ndarray.ptp`, except, where that would return an `ndarray` object,\nthis returns a `matrix` object.\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.ptp()\n11\n>>> x.ptp(0)\nmatrix([[8, 8, 8, 8]])\n>>> x.ptp(1)\nmatrix([[3],\n        [3],\n        [3]])",
              "signature": "(self, axis=None, out=None)"
            },
            {
              "name": "ravel",
              "doc": "Return a flattened matrix.\n\nRefer to `numpy.ravel` for more documentation.\n\nParameters\n----------\norder : {'C', 'F', 'A', 'K'}, optional\n    The elements of `m` are read using this index order. 'C' means to\n    index the elements in C-like order, with the last axis index\n    changing fastest, back to the first axis index changing slowest.\n    'F' means to index the elements in Fortran-like index order, with\n    the first index changing fastest, and the last index changing\n    slowest. Note that the 'C' and 'F' options take no account of the\n    memory layout of the underlying array, and only refer to the order\n    of axis indexing.  'A' means to read the elements in Fortran-like\n    index order if `m` is Fortran *contiguous* in memory, C-like order\n    otherwise.  'K' means to read the elements in the order they occur\n    in memory, except for reversing the data when strides are negative.\n    By default, 'C' index order is used.\n\nReturns\n-------\nret : matrix\n    Return the matrix flattened to shape `(1, N)` where `N`\n    is the number of elements in the original matrix.\n    A copy is made only if necessary.\n\nSee Also\n--------\nmatrix.flatten : returns a similar output matrix but always a copy\nmatrix.flat : a flat iterator on the array.\nnumpy.ravel : related function which returns an ndarray",
              "signature": "(self, order='C')"
            },
            {
              "name": "squeeze",
              "doc": "Return a possibly reshaped matrix.\n\nRefer to `numpy.squeeze` for more documentation.\n\nParameters\n----------\naxis : None or int or tuple of ints, optional\n    Selects a subset of the axes of length one in the shape.\n    If an axis is selected with shape entry greater than one,\n    an error is raised.\n\nReturns\n-------\nsqueezed : matrix\n    The matrix, but as a (1, N) matrix if it had shape (N, 1).\n\nSee Also\n--------\nnumpy.squeeze : related function\n\nNotes\n-----\nIf `m` has a single column then that column is returned\nas the single row of a matrix.  Otherwise `m` is returned.\nThe returned matrix is always either `m` itself or a view into `m`.\nSupplying an axis keyword argument will not affect the returned matrix\nbut it may cause an error to be raised.\n\nExamples\n--------\n>>> c = np.matrix([[1], [2]])\n>>> c\nmatrix([[1],\n        [2]])\n>>> c.squeeze()\nmatrix([[1, 2]])\n>>> r = c.T\n>>> r\nmatrix([[1, 2]])\n>>> r.squeeze()\nmatrix([[1, 2]])\n>>> m = np.matrix([[1, 2], [3, 4]])\n>>> m.squeeze()\nmatrix([[1, 2],\n        [3, 4]])",
              "signature": "(self, axis=None)"
            },
            {
              "name": "std",
              "doc": "Return the standard deviation of the array elements along the given axis.\n\nRefer to `numpy.std` for full documentation.\n\nSee Also\n--------\nnumpy.std\n\nNotes\n-----\nThis is the same as `ndarray.std`, except that where an `ndarray` would\nbe returned, a `matrix` object is returned instead.\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3, 4)))\n>>> x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.std()\n3.4520525295346629 # may vary\n>>> x.std(0)\nmatrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]]) # may vary\n>>> x.std(1)\nmatrix([[ 1.11803399],\n        [ 1.11803399],\n        [ 1.11803399]])",
              "signature": "(self, axis=None, dtype=None, out=None, ddof=0)"
            },
            {
              "name": "sum",
              "doc": "Returns the sum of the matrix elements, along the given axis.\n\nRefer to `numpy.sum` for full documentation.\n\nSee Also\n--------\nnumpy.sum\n\nNotes\n-----\nThis is the same as `ndarray.sum`, except that where an `ndarray` would\nbe returned, a `matrix` object is returned instead.\n\nExamples\n--------\n>>> x = np.matrix([[1, 2], [4, 3]])\n>>> x.sum()\n10\n>>> x.sum(axis=1)\nmatrix([[3],\n        [7]])\n>>> x.sum(axis=1, dtype='float')\nmatrix([[3.],\n        [7.]])\n>>> out = np.zeros((2, 1), dtype='float')\n>>> x.sum(axis=1, dtype='float', out=np.asmatrix(out))\nmatrix([[3.],\n        [7.]])",
              "signature": "(self, axis=None, dtype=None, out=None)"
            },
            {
              "name": "tolist",
              "doc": "Return the matrix as a (possibly nested) list.\n\nSee `ndarray.tolist` for full documentation.\n\nSee Also\n--------\nndarray.tolist\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.tolist()\n[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]",
              "signature": "(self)"
            },
            {
              "name": "var",
              "doc": "Returns the variance of the matrix elements, along the given axis.\n\nRefer to `numpy.var` for full documentation.\n\nSee Also\n--------\nnumpy.var\n\nNotes\n-----\nThis is the same as `ndarray.var`, except that where an `ndarray` would\nbe returned, a `matrix` object is returned instead.\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3, 4)))\n>>> x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.var()\n11.916666666666666\n>>> x.var(0)\nmatrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]]) # may vary\n>>> x.var(1)\nmatrix([[1.25],\n        [1.25],\n        [1.25]])",
              "signature": "(self, axis=None, dtype=None, out=None, ddof=0)"
            }
          ]
        },
        {
          "name": "memmap",
          "doc": "Create a memory-map to an array stored in a *binary* file on disk.\n\nMemory-mapped files are used for accessing small segments of large files\non disk, without reading the entire file into memory.  NumPy's\nmemmap's are array-like objects.  This differs from Python's ``mmap``\nmodule, which uses file-like objects.\n\nThis subclass of ndarray has some unpleasant interactions with\nsome operations, because it doesn't quite fit properly as a subclass.\nAn alternative to using this subclass is to create the ``mmap``\nobject yourself, then create an ndarray with ndarray.__new__ directly,\npassing the object created in its 'buffer=' parameter.\n\nThis class may at some point be turned into a factory function\nwhich returns a view into an mmap buffer.\n\nFlush the memmap instance to write the changes to the file. Currently there\nis no API to close the underlying ``mmap``. It is tricky to ensure the\nresource is actually closed, since it may be shared between different\nmemmap instances.\n\n\nParameters\n----------\nfilename : str, file-like object, or pathlib.Path instance\n    The file name or file object to be used as the array data buffer.\ndtype : data-type, optional\n    The data-type used to interpret the file contents.\n    Default is `uint8`.\nmode : {'r+', 'r', 'w+', 'c'}, optional\n    The file is opened in this mode:\n\n    +------+-------------------------------------------------------------+\n    | 'r'  | Open existing file for reading only.                        |\n    +------+-------------------------------------------------------------+\n    | 'r+' | Open existing file for reading and writing.                 |\n    +------+-------------------------------------------------------------+\n    | 'w+' | Create or overwrite existing file for reading and writing.  |\n    |      | If ``mode == 'w+'`` then `shape` must also be specified.    |\n    +------+-------------------------------------------------------------+\n    | 'c'  | Copy-on-write: assignments affect data in memory, but       |\n    |      | changes are not saved to disk.  The file on disk is         |\n    |      | read-only.                                                  |\n    +------+-------------------------------------------------------------+\n\n    Default is 'r+'.\noffset : int, optional\n    In the file, array data starts at this offset. Since `offset` is\n    measured in bytes, it should normally be a multiple of the byte-size\n    of `dtype`. When ``mode != 'r'``, even positive offsets beyond end of\n    file are valid; The file will be extended to accommodate the\n    additional data. By default, ``memmap`` will start at the beginning of\n    the file, even if ``filename`` is a file pointer ``fp`` and\n    ``fp.tell() != 0``.\nshape : int or sequence of ints, optional\n    The desired shape of the array. If ``mode == 'r'`` and the number\n    of remaining bytes after `offset` is not a multiple of the byte-size\n    of `dtype`, you must specify `shape`. By default, the returned array\n    will be 1-D with the number of elements determined by file size\n    and data-type.\n\n    .. versionchanged:: 2.0\n     The shape parameter can now be any integer sequence type, previously\n     types were limited to tuple and int.\n\norder : {'C', 'F'}, optional\n    Specify the order of the ndarray memory layout:\n    :term:`row-major`, C-style or :term:`column-major`,\n    Fortran-style.  This only has an effect if the shape is\n    greater than 1-D.  The default order is 'C'.\n\nAttributes\n----------\nfilename : str or pathlib.Path instance\n    Path to the mapped file.\noffset : int\n    Offset position in the file.\nmode : str\n    File mode.\n\nMethods\n-------\nflush\n    Flush any changes in memory to file on disk.\n    When you delete a memmap object, flush is called first to write\n    changes to disk.\n\n\nSee also\n--------\nlib.format.open_memmap : Create or load a memory-mapped ``.npy`` file.\n\nNotes\n-----\nThe memmap object can be used anywhere an ndarray is accepted.\nGiven a memmap ``fp``, ``isinstance(fp, numpy.ndarray)`` returns\n``True``.\n\nMemory-mapped files cannot be larger than 2GB on 32-bit systems.\n\nWhen a memmap causes a file to be created or extended beyond its\ncurrent size in the filesystem, the contents of the new part are\nunspecified. On systems with POSIX filesystem semantics, the extended\npart will be filled with zero bytes.\n\nExamples\n--------\n>>> import numpy as np\n>>> data = np.arange(12, dtype='float32')\n>>> data.resize((3,4))\n\nThis example uses a temporary file so that doctest doesn't write\nfiles to your directory. You would use a 'normal' filename.\n\n>>> from tempfile import mkdtemp\n>>> import os.path as path\n>>> filename = path.join(mkdtemp(), 'newfile.dat')\n\nCreate a memmap with dtype and shape that matches our data:\n\n>>> fp = np.memmap(filename, dtype='float32', mode='w+', shape=(3,4))\n>>> fp\nmemmap([[0., 0., 0., 0.],\n        [0., 0., 0., 0.],\n        [0., 0., 0., 0.]], dtype=float32)\n\nWrite data to memmap array:\n\n>>> fp[:] = data[:]\n>>> fp\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n\n>>> fp.filename == path.abspath(filename)\nTrue\n\nFlushes memory changes to disk in order to read them back\n\n>>> fp.flush()\n\nLoad the memmap and verify data was stored:\n\n>>> newfp = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n>>> newfp\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n\nRead-only memmap:\n\n>>> fpr = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n>>> fpr.flags.writeable\nFalse\n\nCopy-on-write memmap:\n\n>>> fpc = np.memmap(filename, dtype='float32', mode='c', shape=(3,4))\n>>> fpc.flags.writeable\nTrue\n\nIt's possible to assign to copy-on-write array, but values are only\nwritten into the memory copy of the array, and not written to disk:\n\n>>> fpc\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n>>> fpc[0,:] = 0\n>>> fpc\nmemmap([[  0.,   0.,   0.,   0.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n\nFile on disk is unchanged:\n\n>>> fpr\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n\nOffset into a memmap:\n\n>>> fpo = np.memmap(filename, dtype='float32', mode='r', offset=16)\n>>> fpo\nmemmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)",
          "functions": [
            {
              "name": "__array_finalize__",
              "doc": "a.__array_finalize__(obj, /)\n\nPresent so subclasses can call super. Does nothing.",
              "signature": "(self, obj)"
            },
            {
              "name": "__array_wrap__",
              "doc": "a.__array_wrap__(array[, context], /)\n\nReturns a view of `array` with the same type as self.",
              "signature": "(self, arr, context=None, return_scalar=False)"
            },
            {
              "name": "__getitem__",
              "doc": "Return self[key].",
              "signature": "(self, index)"
            },
            {
              "name": "__new__",
              "doc": "Create and return a new object.  See help(type) for accurate signature.",
              "signature": "(subtype, filename, dtype=<class 'numpy.uint8'>, mode='r+', offset=0, shape=None, order='C')"
            },
            {
              "name": "flush",
              "doc": "Write any changes in the array to the file on disk.\n\nFor further information, see `memmap`.\n\nParameters\n----------\nNone\n\nSee Also\n--------\nmemmap",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "ndarray",
          "doc": "ndarray(shape, dtype=float, buffer=None, offset=0,\n        strides=None, order=None)\n\nAn array object represents a multidimensional, homogeneous array\nof fixed-size items.  An associated data-type object describes the\nformat of each element in the array (its byte-order, how many bytes it\noccupies in memory, whether it is an integer, a floating point number,\nor something else, etc.)\n\nArrays should be constructed using `array`, `zeros` or `empty` (refer\nto the See Also section below).  The parameters given here refer to\na low-level method (`ndarray(...)`) for instantiating an array.\n\nFor more information, refer to the `numpy` module and examine the\nmethods and attributes of an array.\n\nParameters\n----------\n(for the __new__ method; see Notes below)\n\nshape : tuple of ints\n    Shape of created array.\ndtype : data-type, optional\n    Any object that can be interpreted as a numpy data type.\nbuffer : object exposing buffer interface, optional\n    Used to fill the array with data.\noffset : int, optional\n    Offset of array data in buffer.\nstrides : tuple of ints, optional\n    Strides of data in memory.\norder : {'C', 'F'}, optional\n    Row-major (C-style) or column-major (Fortran-style) order.\n\nAttributes\n----------\nT : ndarray\n    Transpose of the array.\ndata : buffer\n    The array's elements, in memory.\ndtype : dtype object\n    Describes the format of the elements in the array.\nflags : dict\n    Dictionary containing information related to memory use, e.g.,\n    'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc.\nflat : numpy.flatiter object\n    Flattened version of the array as an iterator.  The iterator\n    allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for\n    assignment examples; TODO).\nimag : ndarray\n    Imaginary part of the array.\nreal : ndarray\n    Real part of the array.\nsize : int\n    Number of elements in the array.\nitemsize : int\n    The memory use of each array element in bytes.\nnbytes : int\n    The total number of bytes required to store the array data,\n    i.e., ``itemsize * size``.\nndim : int\n    The array's number of dimensions.\nshape : tuple of ints\n    Shape of the array.\nstrides : tuple of ints\n    The step-size required to move from one element to the next in\n    memory. For example, a contiguous ``(3, 4)`` array of type\n    ``int16`` in C-order has strides ``(8, 2)``.  This implies that\n    to move from element to element in memory requires jumps of 2 bytes.\n    To move from row-to-row, one needs to jump 8 bytes at a time\n    (``2 * 4``).\nctypes : ctypes object\n    Class containing properties of the array needed for interaction\n    with ctypes.\nbase : ndarray\n    If the array is a view into another array, that array is its `base`\n    (unless that array is also a view).  The `base` array is where the\n    array data is actually stored.\n\nSee Also\n--------\narray : Construct an array.\nzeros : Create an array, each element of which is zero.\nempty : Create an array, but leave its allocated memory unchanged (i.e.,\n        it contains \"garbage\").\ndtype : Create a data-type.\nnumpy.typing.NDArray : An ndarray alias :term:`generic <generic type>`\n                       w.r.t. its `dtype.type <numpy.dtype.type>`.\n\nNotes\n-----\nThere are two modes of creating an array using ``__new__``:\n\n1. If `buffer` is None, then only `shape`, `dtype`, and `order`\n   are used.\n2. If `buffer` is an object exposing the buffer interface, then\n   all keywords are interpreted.\n\nNo ``__init__`` method is needed because the array is fully initialized\nafter the ``__new__`` method.\n\nExamples\n--------\nThese examples illustrate the low-level `ndarray` constructor.  Refer\nto the `See Also` section above for easier ways of constructing an\nndarray.\n\nFirst mode, `buffer` is None:\n\n>>> import numpy as np\n>>> np.ndarray(shape=(2,2), dtype=float, order='F')\narray([[0.0e+000, 0.0e+000], # random\n       [     nan, 2.5e-323]])\n\nSecond mode:\n\n>>> np.ndarray((2,), buffer=np.array([1,2,3]),\n...            offset=np.int_().itemsize,\n...            dtype=int) # offset = 1*itemsize, i.e. skip first element\narray([2, 3])",
          "functions": []
        },
        {
          "name": "ndenumerate",
          "doc": "Multidimensional index iterator.\n\nReturn an iterator yielding pairs of array coordinates and values.\n\nParameters\n----------\narr : ndarray\n  Input array.\n\nSee Also\n--------\nndindex, flatiter\n\nExamples\n--------\n>>> import numpy as np\n>>> a = np.array([[1, 2], [3, 4]])\n>>> for index, x in np.ndenumerate(a):\n...     print(index, x)\n(0, 0) 1\n(0, 1) 2\n(1, 0) 3\n(1, 1) 4",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, arr)"
            },
            {
              "name": "__iter__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__next__",
              "doc": "Standard iterator method, returns the index tuple and array value.\n\nReturns\n-------\ncoords : tuple of ints\n    The indices of the current iteration.\nval : scalar\n    The array element of the current iteration.",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "ndindex",
          "doc": "An N-dimensional iterator object to index arrays.\n\nGiven the shape of an array, an `ndindex` instance iterates over\nthe N-dimensional index of the array. At each iteration a tuple\nof indices is returned, the last dimension is iterated over first.\n\nParameters\n----------\nshape : ints, or a single tuple of ints\n    The size of each dimension of the array can be passed as\n    individual parameters or as the elements of a tuple.\n\nSee Also\n--------\nndenumerate, flatiter\n\nExamples\n--------\n>>> import numpy as np\n\nDimensions as individual arguments\n\n>>> for index in np.ndindex(3, 2, 1):\n...     print(index)\n(0, 0, 0)\n(0, 1, 0)\n(1, 0, 0)\n(1, 1, 0)\n(2, 0, 0)\n(2, 1, 0)\n\nSame dimensions - but in a tuple ``(3, 2, 1)``\n\n>>> for index in np.ndindex((3, 2, 1)):\n...     print(index)\n(0, 0, 0)\n(0, 1, 0)\n(1, 0, 0)\n(1, 1, 0)\n(2, 0, 0)\n(2, 1, 0)",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, *shape)"
            },
            {
              "name": "__iter__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__next__",
              "doc": "Standard iterator method, updates the index and returns the index\ntuple.\n\nReturns\n-------\nval : tuple of ints\n    Returns a tuple containing the indices of the current\n    iteration.",
              "signature": "(self)"
            },
            {
              "name": "ndincr",
              "doc": "Increment the multi-dimensional index by one.\n\nThis method is for backward compatibility only: do not use.\n\n.. deprecated:: 1.20.0\n    This method has been advised against since numpy 1.8.0, but only\n    started emitting DeprecationWarning as of this version.",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "nditer",
          "doc": "nditer(op, flags=None, op_flags=None, op_dtypes=None, order='K',\n    casting='safe', op_axes=None, itershape=None, buffersize=0)\n\nEfficient multi-dimensional iterator object to iterate over arrays.\nTo get started using this object, see the\n:ref:`introductory guide to array iteration <arrays.nditer>`.\n\nParameters\n----------\nop : ndarray or sequence of array_like\n    The array(s) to iterate over.\n\nflags : sequence of str, optional\n      Flags to control the behavior of the iterator.\n\n      * ``buffered`` enables buffering when required.\n      * ``c_index`` causes a C-order index to be tracked.\n      * ``f_index`` causes a Fortran-order index to be tracked.\n      * ``multi_index`` causes a multi-index, or a tuple of indices\n        with one per iteration dimension, to be tracked.\n      * ``common_dtype`` causes all the operands to be converted to\n        a common data type, with copying or buffering as necessary.\n      * ``copy_if_overlap`` causes the iterator to determine if read\n        operands have overlap with write operands, and make temporary\n        copies as necessary to avoid overlap. False positives (needless\n        copying) are possible in some cases.\n      * ``delay_bufalloc`` delays allocation of the buffers until\n        a reset() call is made. Allows ``allocate`` operands to\n        be initialized before their values are copied into the buffers.\n      * ``external_loop`` causes the ``values`` given to be\n        one-dimensional arrays with multiple values instead of\n        zero-dimensional arrays.\n      * ``grow_inner`` allows the ``value`` array sizes to be made\n        larger than the buffer size when both ``buffered`` and\n        ``external_loop`` is used.\n      * ``ranged`` allows the iterator to be restricted to a sub-range\n        of the iterindex values.\n      * ``refs_ok`` enables iteration of reference types, such as\n        object arrays.\n      * ``reduce_ok`` enables iteration of ``readwrite`` operands\n        which are broadcasted, also known as reduction operands.\n      * ``zerosize_ok`` allows `itersize` to be zero.\nop_flags : list of list of str, optional\n      This is a list of flags for each operand. At minimum, one of\n      ``readonly``, ``readwrite``, or ``writeonly`` must be specified.\n\n      * ``readonly`` indicates the operand will only be read from.\n      * ``readwrite`` indicates the operand will be read from and written to.\n      * ``writeonly`` indicates the operand will only be written to.\n      * ``no_broadcast`` prevents the operand from being broadcasted.\n      * ``contig`` forces the operand data to be contiguous.\n      * ``aligned`` forces the operand data to be aligned.\n      * ``nbo`` forces the operand data to be in native byte order.\n      * ``copy`` allows a temporary read-only copy if required.\n      * ``updateifcopy`` allows a temporary read-write copy if required.\n      * ``allocate`` causes the array to be allocated if it is None\n        in the ``op`` parameter.\n      * ``no_subtype`` prevents an ``allocate`` operand from using a subtype.\n      * ``arraymask`` indicates that this operand is the mask to use\n        for selecting elements when writing to operands with the\n        'writemasked' flag set. The iterator does not enforce this,\n        but when writing from a buffer back to the array, it only\n        copies those elements indicated by this mask.\n      * ``writemasked`` indicates that only elements where the chosen\n        ``arraymask`` operand is True will be written to.\n      * ``overlap_assume_elementwise`` can be used to mark operands that are\n        accessed only in the iterator order, to allow less conservative\n        copying when ``copy_if_overlap`` is present.\nop_dtypes : dtype or tuple of dtype(s), optional\n    The required data type(s) of the operands. If copying or buffering\n    is enabled, the data will be converted to/from their original types.\norder : {'C', 'F', 'A', 'K'}, optional\n    Controls the iteration order. 'C' means C order, 'F' means\n    Fortran order, 'A' means 'F' order if all the arrays are Fortran\n    contiguous, 'C' order otherwise, and 'K' means as close to the\n    order the array elements appear in memory as possible. This also\n    affects the element memory order of ``allocate`` operands, as they\n    are allocated to be compatible with iteration order.\n    Default is 'K'.\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n    Controls what kind of data casting may occur when making a copy\n    or buffering.  Setting this to 'unsafe' is not recommended,\n    as it can adversely affect accumulations.\n\n    * 'no' means the data types should not be cast at all.\n    * 'equiv' means only byte-order changes are allowed.\n    * 'safe' means only casts which can preserve values are allowed.\n    * 'same_kind' means only safe casts or casts within a kind,\n      like float64 to float32, are allowed.\n    * 'unsafe' means any data conversions may be done.\nop_axes : list of list of ints, optional\n    If provided, is a list of ints or None for each operands.\n    The list of axes for an operand is a mapping from the dimensions\n    of the iterator to the dimensions of the operand. A value of\n    -1 can be placed for entries, causing that dimension to be\n    treated as `newaxis`.\nitershape : tuple of ints, optional\n    The desired shape of the iterator. This allows ``allocate`` operands\n    with a dimension mapped by op_axes not corresponding to a dimension\n    of a different operand to get a value not equal to 1 for that\n    dimension.\nbuffersize : int, optional\n    When buffering is enabled, controls the size of the temporary\n    buffers. Set to 0 for the default value.\n\nAttributes\n----------\ndtypes : tuple of dtype(s)\n    The data types of the values provided in `value`. This may be\n    different from the operand data types if buffering is enabled.\n    Valid only before the iterator is closed.\nfinished : bool\n    Whether the iteration over the operands is finished or not.\nhas_delayed_bufalloc : bool\n    If True, the iterator was created with the ``delay_bufalloc`` flag,\n    and no reset() function was called on it yet.\nhas_index : bool\n    If True, the iterator was created with either the ``c_index`` or\n    the ``f_index`` flag, and the property `index` can be used to\n    retrieve it.\nhas_multi_index : bool\n    If True, the iterator was created with the ``multi_index`` flag,\n    and the property `multi_index` can be used to retrieve it.\nindex\n    When the ``c_index`` or ``f_index`` flag was used, this property\n    provides access to the index. Raises a ValueError if accessed\n    and ``has_index`` is False.\niterationneedsapi : bool\n    Whether iteration requires access to the Python API, for example\n    if one of the operands is an object array.\niterindex : int\n    An index which matches the order of iteration.\nitersize : int\n    Size of the iterator.\nitviews\n    Structured view(s) of `operands` in memory, matching the reordered\n    and optimized iterator access pattern. Valid only before the iterator\n    is closed.\nmulti_index\n    When the ``multi_index`` flag was used, this property\n    provides access to the index. Raises a ValueError if accessed\n    accessed and ``has_multi_index`` is False.\nndim : int\n    The dimensions of the iterator.\nnop : int\n    The number of iterator operands.\noperands : tuple of operand(s)\n    The array(s) to be iterated over. Valid only before the iterator is\n    closed.\nshape : tuple of ints\n    Shape tuple, the shape of the iterator.\nvalue\n    Value of ``operands`` at current iteration. Normally, this is a\n    tuple of array scalars, but if the flag ``external_loop`` is used,\n    it is a tuple of one dimensional arrays.\n\nNotes\n-----\n`nditer` supersedes `flatiter`.  The iterator implementation behind\n`nditer` is also exposed by the NumPy C API.\n\nThe Python exposure supplies two iteration interfaces, one which follows\nthe Python iterator protocol, and another which mirrors the C-style\ndo-while pattern.  The native Python approach is better in most cases, but\nif you need the coordinates or index of an iterator, use the C-style pattern.\n\nExamples\n--------\nHere is how we might write an ``iter_add`` function, using the\nPython iterator protocol:\n\n>>> import numpy as np\n\n>>> def iter_add_py(x, y, out=None):\n...     addop = np.add\n...     it = np.nditer([x, y, out], [],\n...                 [['readonly'], ['readonly'], ['writeonly','allocate']])\n...     with it:\n...         for (a, b, c) in it:\n...             addop(a, b, out=c)\n...         return it.operands[2]\n\nHere is the same function, but following the C-style pattern:\n\n>>> def iter_add(x, y, out=None):\n...    addop = np.add\n...    it = np.nditer([x, y, out], [],\n...                [['readonly'], ['readonly'], ['writeonly','allocate']])\n...    with it:\n...        while not it.finished:\n...            addop(it[0], it[1], out=it[2])\n...            it.iternext()\n...        return it.operands[2]\n\nHere is an example outer product function:\n\n>>> def outer_it(x, y, out=None):\n...     mulop = np.multiply\n...     it = np.nditer([x, y, out], ['external_loop'],\n...             [['readonly'], ['readonly'], ['writeonly', 'allocate']],\n...             op_axes=[list(range(x.ndim)) + [-1] * y.ndim,\n...                      [-1] * x.ndim + list(range(y.ndim)),\n...                      None])\n...     with it:\n...         for (a, b, c) in it:\n...             mulop(a, b, out=c)\n...         return it.operands[2]\n\n>>> a = np.arange(2)+1\n>>> b = np.arange(3)+1\n>>> outer_it(a,b)\narray([[1, 2, 3],\n       [2, 4, 6]])\n\nHere is an example function which operates like a \"lambda\" ufunc:\n\n>>> def luf(lamdaexpr, *args, **kwargs):\n...    '''luf(lambdaexpr, op1, ..., opn, out=None, order='K', casting='safe', buffersize=0)'''\n...    nargs = len(args)\n...    op = (kwargs.get('out',None),) + args\n...    it = np.nditer(op, ['buffered','external_loop'],\n...            [['writeonly','allocate','no_broadcast']] +\n...                            [['readonly','nbo','aligned']]*nargs,\n...            order=kwargs.get('order','K'),\n...            casting=kwargs.get('casting','safe'),\n...            buffersize=kwargs.get('buffersize',0))\n...    while not it.finished:\n...        it[0] = lamdaexpr(*it[1:])\n...        it.iternext()\n...    return it.operands[0]\n\n>>> a = np.arange(5)\n>>> b = np.ones(5)\n>>> luf(lambda i,j:i*i + j/2, a, b)\narray([  0.5,   1.5,   4.5,   9.5,  16.5])\n\nIf operand flags ``\"writeonly\"`` or ``\"readwrite\"`` are used the\noperands may be views into the original data with the\n`WRITEBACKIFCOPY` flag. In this case `nditer` must be used as a\ncontext manager or the `nditer.close` method must be called before\nusing the result. The temporary data will be written back to the\noriginal data when the :meth:`~object.__exit__` function is called\nbut not before:\n\n>>> a = np.arange(6, dtype='i4')[::-2]\n>>> with np.nditer(a, [],\n...        [['writeonly', 'updateifcopy']],\n...        casting='unsafe',\n...        op_dtypes=[np.dtype('f4')]) as i:\n...    x = i.operands[0]\n...    x[:] = [-1, -2, -3]\n...    # a still unchanged here\n>>> a, x\n(array([-1, -2, -3], dtype=int32), array([-1., -2., -3.], dtype=float32))\n\nIt is important to note that once the iterator is exited, dangling\nreferences (like `x` in the example) may or may not share data with\nthe original data `a`. If writeback semantics were active, i.e. if\n`x.base.flags.writebackifcopy` is `True`, then exiting the iterator\nwill sever the connection between `x` and `a`, writing to `x` will\nno longer write to `a`. If writeback semantics are not active, then\n`x.data` will still point at some part of `a.data`, and writing to\none will affect the other.\n\nContext management and the `close` method appeared in version 1.15.0.",
          "functions": []
        },
        {
          "name": "number",
          "doc": "Abstract base class of all numeric scalar types.",
          "functions": []
        },
        {
          "name": "object_",
          "doc": "Any Python object.\n\n:Character code: ``'O'``",
          "functions": []
        },
        {
          "name": "poly1d",
          "doc": "A one-dimensional polynomial class.\n\n.. note::\n   This forms part of the old polynomial API. Since version 1.4, the\n   new polynomial API defined in `numpy.polynomial` is preferred.\n   A summary of the differences can be found in the\n   :doc:`transition guide </reference/routines.polynomials>`.\n\nA convenience class, used to encapsulate \"natural\" operations on\npolynomials so that said operations may take on their customary\nform in code (see Examples).\n\nParameters\n----------\nc_or_r : array_like\n    The polynomial's coefficients, in decreasing powers, or if\n    the value of the second parameter is True, the polynomial's\n    roots (values where the polynomial evaluates to 0).  For example,\n    ``poly1d([1, 2, 3])`` returns an object that represents\n    :math:`x^2 + 2x + 3`, whereas ``poly1d([1, 2, 3], True)`` returns\n    one that represents :math:`(x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x -6`.\nr : bool, optional\n    If True, `c_or_r` specifies the polynomial's roots; the default\n    is False.\nvariable : str, optional\n    Changes the variable used when printing `p` from `x` to `variable`\n    (see Examples).\n\nExamples\n--------\n>>> import numpy as np\n\nConstruct the polynomial :math:`x^2 + 2x + 3`:\n\n>>> import numpy as np\n\n>>> p = np.poly1d([1, 2, 3])\n>>> print(np.poly1d(p))\n   2\n1 x + 2 x + 3\n\nEvaluate the polynomial at :math:`x = 0.5`:\n\n>>> p(0.5)\n4.25\n\nFind the roots:\n\n>>> p.r\narray([-1.+1.41421356j, -1.-1.41421356j])\n>>> p(p.r)\narray([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j]) # may vary\n\nThese numbers in the previous line represent (0, 0) to machine precision\n\nShow the coefficients:\n\n>>> p.c\narray([1, 2, 3])\n\nDisplay the order (the leading zero-coefficients are removed):\n\n>>> p.order\n2\n\nShow the coefficient of the k-th power in the polynomial\n(which is equivalent to ``p.c[-(i+1)]``):\n\n>>> p[1]\n2\n\nPolynomials can be added, subtracted, multiplied, and divided\n(returns quotient and remainder):\n\n>>> p * p\npoly1d([ 1,  4, 10, 12,  9])\n\n>>> (p**3 + 4) / p\n(poly1d([ 1.,  4., 10., 12.,  9.]), poly1d([4.]))\n\n``asarray(p)`` gives the coefficient array, so polynomials can be\nused in all functions that accept arrays:\n\n>>> p**2 # square of polynomial\npoly1d([ 1,  4, 10, 12,  9])\n\n>>> np.square(p) # square of individual coefficients\narray([1, 4, 9])\n\nThe variable used in the string representation of `p` can be modified,\nusing the `variable` parameter:\n\n>>> p = np.poly1d([1,2,3], variable='z')\n>>> print(p)\n   2\n1 z + 2 z + 3\n\nConstruct a polynomial from its roots:\n\n>>> np.poly1d([1, 2], True)\npoly1d([ 1., -3.,  2.])\n\nThis is the same polynomial as obtained by:\n\n>>> np.poly1d([1, -1]) * np.poly1d([1, -2])\npoly1d([ 1, -3,  2])",
          "functions": [
            {
              "name": "__add__",
              "doc": null,
              "signature": "(self, other)"
            },
            {
              "name": "__array__",
              "doc": null,
              "signature": "(self, t=None, copy=None)"
            },
            {
              "name": "__call__",
              "doc": "Call self as a function.",
              "signature": "(self, val)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__getitem__",
              "doc": null,
              "signature": "(self, val)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, c_or_r, r=False, variable=None)"
            },
            {
              "name": "__iter__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__mul__",
              "doc": null,
              "signature": "(self, other)"
            },
            {
              "name": "__ne__",
              "doc": "Return self!=value.",
              "signature": "(self, other)"
            },
            {
              "name": "__neg__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__pos__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "__pow__",
              "doc": null,
              "signature": "(self, val)"
            },
            {
              "name": "__radd__",
              "doc": null,
              "signature": "(self, other)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__rmul__",
              "doc": null,
              "signature": "(self, other)"
            },
            {
              "name": "__rsub__",
              "doc": null,
              "signature": "(self, other)"
            },
            {
              "name": "__rtruediv__",
              "doc": null,
              "signature": "(self, other)"
            },
            {
              "name": "__setitem__",
              "doc": null,
              "signature": "(self, key, val)"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self)"
            },
            {
              "name": "__sub__",
              "doc": null,
              "signature": "(self, other)"
            },
            {
              "name": "__truediv__",
              "doc": null,
              "signature": "(self, other)"
            },
            {
              "name": "deriv",
              "doc": "Return a derivative of this polynomial.\n\nRefer to `polyder` for full documentation.\n\nSee Also\n--------\npolyder : equivalent function",
              "signature": "(self, m=1)"
            },
            {
              "name": "integ",
              "doc": "Return an antiderivative (indefinite integral) of this polynomial.\n\nRefer to `polyint` for full documentation.\n\nSee Also\n--------\npolyint : equivalent function",
              "signature": "(self, m=1, k=0)"
            }
          ]
        },
        {
          "name": "recarray",
          "doc": "Construct an ndarray that allows field access using attributes.\n\nArrays may have a data-types containing fields, analogous\nto columns in a spread sheet.  An example is ``[(x, int), (y, float)]``,\nwhere each entry in the array is a pair of ``(int, float)``.  Normally,\nthese attributes are accessed using dictionary lookups such as ``arr['x']``\nand ``arr['y']``.  Record arrays allow the fields to be accessed as members\nof the array, using ``arr.x`` and ``arr.y``.\n\nParameters\n----------\nshape : tuple\n    Shape of output array.\ndtype : data-type, optional\n    The desired data-type.  By default, the data-type is determined\n    from `formats`, `names`, `titles`, `aligned` and `byteorder`.\nformats : list of data-types, optional\n    A list containing the data-types for the different columns, e.g.\n    ``['i4', 'f8', 'i4']``.  `formats` does *not* support the new\n    convention of using types directly, i.e. ``(int, float, int)``.\n    Note that `formats` must be a list, not a tuple.\n    Given that `formats` is somewhat limited, we recommend specifying\n    `dtype` instead.\nnames : tuple of str, optional\n    The name of each column, e.g. ``('x', 'y', 'z')``.\nbuf : buffer, optional\n    By default, a new array is created of the given shape and data-type.\n    If `buf` is specified and is an object exposing the buffer interface,\n    the array will use the memory from the existing buffer.  In this case,\n    the `offset` and `strides` keywords are available.\n\nOther Parameters\n----------------\ntitles : tuple of str, optional\n    Aliases for column names.  For example, if `names` were\n    ``('x', 'y', 'z')`` and `titles` is\n    ``('x_coordinate', 'y_coordinate', 'z_coordinate')``, then\n    ``arr['x']`` is equivalent to both ``arr.x`` and ``arr.x_coordinate``.\nbyteorder : {'<', '>', '='}, optional\n    Byte-order for all fields.\naligned : bool, optional\n    Align the fields in memory as the C-compiler would.\nstrides : tuple of ints, optional\n    Buffer (`buf`) is interpreted according to these strides (strides\n    define how many bytes each array element, row, column, etc.\n    occupy in memory).\noffset : int, optional\n    Start reading buffer (`buf`) from this offset onwards.\norder : {'C', 'F'}, optional\n    Row-major (C-style) or column-major (Fortran-style) order.\n\nReturns\n-------\nrec : recarray\n    Empty array of the given shape and type.\n\nSee Also\n--------\nnumpy.rec.fromrecords : Construct a record array from data.\nnumpy.record : fundamental data-type for `recarray`.\nnumpy.rec.format_parser : determine data-type from formats, names, titles.\n\nNotes\n-----\nThis constructor can be compared to ``empty``: it creates a new record\narray but does not fill it with data.  To create a record array from data,\nuse one of the following methods:\n\n1. Create a standard ndarray and convert it to a record array,\n   using ``arr.view(np.recarray)``\n2. Use the `buf` keyword.\n3. Use `np.rec.fromrecords`.\n\nExamples\n--------\nCreate an array with two fields, ``x`` and ``y``:\n\n>>> import numpy as np\n>>> x = np.array([(1.0, 2), (3.0, 4)], dtype=[('x', '<f8'), ('y', '<i8')])\n>>> x\narray([(1., 2), (3., 4)], dtype=[('x', '<f8'), ('y', '<i8')])\n\n>>> x['x']\narray([1., 3.])\n\nView the array as a record array:\n\n>>> x = x.view(np.recarray)\n\n>>> x.x\narray([1., 3.])\n\n>>> x.y\narray([2, 4])\n\nCreate a new, empty record array:\n\n>>> np.recarray((2,),\n... dtype=[('x', int), ('y', float), ('z', int)]) #doctest: +SKIP\nrec.array([(-1073741821, 1.2249118382103472e-301, 24547520),\n       (3471280, 1.2134086255804012e-316, 0)],\n      dtype=[('x', '<i4'), ('y', '<f8'), ('z', '<i4')])",
          "functions": [
            {
              "name": "__array_finalize__",
              "doc": "a.__array_finalize__(obj, /)\n\nPresent so subclasses can call super. Does nothing.",
              "signature": "(self, obj)"
            },
            {
              "name": "__getattribute__",
              "doc": "Return getattr(self, name).",
              "signature": "(self, attr)"
            },
            {
              "name": "__getitem__",
              "doc": "Return self[key].",
              "signature": "(self, indx)"
            },
            {
              "name": "__new__",
              "doc": "Create and return a new object.  See help(type) for accurate signature.",
              "signature": "(subtype, shape, dtype=None, buf=None, offset=0, strides=None, formats=None, names=None, titles=None, byteorder=None, aligned=False, order='C')"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, attr, val)"
            },
            {
              "name": "field",
              "doc": null,
              "signature": "(self, attr, val=None)"
            }
          ]
        },
        {
          "name": "record",
          "doc": "A data-type scalar that allows field access as attribute lookup.\n    ",
          "functions": [
            {
              "name": "__getattribute__",
              "doc": "Return getattr(self, name).",
              "signature": "(self, attr)"
            },
            {
              "name": "__getitem__",
              "doc": "Return self[key].",
              "signature": "(self, indx)"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, attr, val)"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self)"
            },
            {
              "name": "pprint",
              "doc": "Pretty-print all fields.",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "int16",
          "doc": "Signed integer type, compatible with C ``short``.\n\n:Character code: ``'h'``\n:Canonical name: `numpy.short`\n:Alias on this platform (win32 AMD64): `numpy.int16`: 16-bit signed integer (``-32_768`` to ``32_767``).",
          "functions": []
        },
        {
          "name": "signedinteger",
          "doc": "Abstract base class of all signed integer scalar types.",
          "functions": []
        },
        {
          "name": "float32",
          "doc": "Single-precision floating-point number type, compatible with C ``float``.\n\n:Character code: ``'f'``\n:Canonical name: `numpy.single`\n:Alias on this platform (win32 AMD64): `numpy.float32`: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.",
          "functions": []
        },
        {
          "name": "str_",
          "doc": "A unicode string.\n\nThis type strips trailing null codepoints.\n\n>>> s = np.str_(\"abc\\x00\")\n>>> s\n'abc'\n\nUnlike the builtin :class:`str`, this supports the\n:ref:`python:bufferobjects`, exposing its contents as UCS4:\n\n>>> m = memoryview(np.str_(\"abc\"))\n>>> m.format\n'3w'\n>>> m.tobytes()\nb'a\\x00\\x00\\x00b\\x00\\x00\\x00c\\x00\\x00\\x00'\n\n:Character code: ``'U'``",
          "functions": []
        },
        {
          "name": "timedelta64",
          "doc": "A timedelta stored as a 64-bit integer.\n\nSee :ref:`arrays.datetime` for more information.\n\n:Character code: ``'m'``",
          "functions": []
        },
        {
          "name": "uint8",
          "doc": "Unsigned integer type, compatible with C ``unsigned char``.\n\n:Character code: ``'B'``\n:Canonical name: `numpy.ubyte`\n:Alias on this platform (win32 AMD64): `numpy.uint8`: 8-bit unsigned integer (``0`` to ``255``).",
          "functions": []
        },
        {
          "name": "ufunc",
          "doc": "Functions that operate element by element on whole arrays.\n\nTo see the documentation for a specific ufunc, use `info`.  For\nexample, ``np.info(np.sin)``.  Because ufuncs are written in C\n(for speed) and linked into Python with NumPy's ufunc facility,\nPython's help() function finds this page whenever help() is called\non a ufunc.\n\nA detailed explanation of ufuncs can be found in the docs for :ref:`ufuncs`.\n\n**Calling ufuncs:** ``op(*x[, out], where=True, **kwargs)``\n\nApply `op` to the arguments `*x` elementwise, broadcasting the arguments.\n\nThe broadcasting rules are:\n\n* Dimensions of length 1 may be prepended to either array.\n* Arrays may be repeated along dimensions of length 1.\n\nParameters\n----------\n*x : array_like\n    Input arrays.\nout : ndarray, None, ..., or tuple of ndarray and None, optional\n    Location(s) into which the result(s) are stored.\n    If not provided or None, new array(s) are created by the ufunc.\n    If passed as a keyword argument, can be Ellipses (``out=...``) to\n    ensure an array is returned even if the result is 0-dimensional,\n    or a tuple with length equal to the number of outputs (where None\n    can be used for allocation by the ufunc).\n\n    .. versionadded:: 2.3\n        Support for ``out=...`` was added.\n\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nr : ndarray or tuple of ndarray\n    `r` will have the shape that the arrays in `x` broadcast to; if `out` is\n    provided, it will be returned. If not, `r` will be allocated and\n    may contain uninitialized values. If the function has more than one\n    output, then the result will be a tuple of arrays.",
          "functions": []
        },
        {
          "name": "uint64",
          "doc": "Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit\nsystems.\n\n:Character code: ``'Q'``\n:Canonical name: `numpy.uint`\n:Alias on this platform (win32 AMD64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).\n:Alias on this platform (win32 AMD64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.",
          "functions": []
        },
        {
          "name": "uint16",
          "doc": "Unsigned integer type, compatible with C ``unsigned short``.\n\n:Character code: ``'H'``\n:Canonical name: `numpy.ushort`\n:Alias on this platform (win32 AMD64): `numpy.uint16`: 16-bit unsigned integer (``0`` to ``65_535``).",
          "functions": []
        },
        {
          "name": "uint32",
          "doc": "Abstract base class of all unsigned integer scalar types.",
          "functions": []
        },
        {
          "name": "uint64",
          "doc": "Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit\nsystems.\n\n:Character code: ``'Q'``\n:Canonical name: `numpy.uint`\n:Alias on this platform (win32 AMD64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).\n:Alias on this platform (win32 AMD64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.",
          "functions": []
        },
        {
          "name": "uint8",
          "doc": "Unsigned integer type, compatible with C ``unsigned char``.\n\n:Character code: ``'B'``\n:Canonical name: `numpy.ubyte`\n:Alias on this platform (win32 AMD64): `numpy.uint8`: 8-bit unsigned integer (``0`` to ``255``).",
          "functions": []
        },
        {
          "name": "uintc",
          "doc": "Unsigned integer type, compatible with C ``unsigned int``.\n\n:Character code: ``'I'``",
          "functions": []
        },
        {
          "name": "uint64",
          "doc": "Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit\nsystems.\n\n:Character code: ``'Q'``\n:Canonical name: `numpy.uint`\n:Alias on this platform (win32 AMD64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).\n:Alias on this platform (win32 AMD64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.",
          "functions": []
        },
        {
          "name": "uint32",
          "doc": "Abstract base class of all unsigned integer scalar types.",
          "functions": []
        },
        {
          "name": "uint64",
          "doc": "Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit\nsystems.\n\n:Character code: ``'Q'``\n:Canonical name: `numpy.uint`\n:Alias on this platform (win32 AMD64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).\n:Alias on this platform (win32 AMD64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.",
          "functions": []
        },
        {
          "name": "unsignedinteger",
          "doc": "Abstract base class of all unsigned integer scalar types.",
          "functions": []
        },
        {
          "name": "uint16",
          "doc": "Unsigned integer type, compatible with C ``unsigned short``.\n\n:Character code: ``'H'``\n:Canonical name: `numpy.ushort`\n:Alias on this platform (win32 AMD64): `numpy.uint16`: 16-bit unsigned integer (``0`` to ``65_535``).",
          "functions": []
        },
        {
          "name": "vectorize",
          "doc": "vectorize(pyfunc=np._NoValue, otypes=None, doc=None, excluded=None,\ncache=False, signature=None)\n\nReturns an object that acts like pyfunc, but takes arrays as input.\n\nDefine a vectorized function which takes a nested sequence of objects or\nnumpy arrays as inputs and returns a single numpy array or a tuple of numpy\narrays. The vectorized function evaluates `pyfunc` over successive tuples\nof the input arrays like the python map function, except it uses the\nbroadcasting rules of numpy.\n\nThe data type of the output of `vectorized` is determined by calling\nthe function with the first element of the input.  This can be avoided\nby specifying the `otypes` argument.\n\nParameters\n----------\npyfunc : callable, optional\n    A python function or method.\n    Can be omitted to produce a decorator with keyword arguments.\notypes : str or list of dtypes, optional\n    The output data type. It must be specified as either a string of\n    typecode characters or a list of data type specifiers. There should\n    be one data type specifier for each output.\ndoc : str, optional\n    The docstring for the function. If None, the docstring will be the\n    ``pyfunc.__doc__``.\nexcluded : set, optional\n    Set of strings or integers representing the positional or keyword\n    arguments for which the function will not be vectorized. These will be\n    passed directly to `pyfunc` unmodified.\n\ncache : bool, optional\n    If `True`, then cache the first function call that determines the number\n    of outputs if `otypes` is not provided.\n\nsignature : string, optional\n    Generalized universal function signature, e.g., ``(m,n),(n)->(m)`` for\n    vectorized matrix-vector multiplication. If provided, ``pyfunc`` will\n    be called with (and expected to return) arrays with shapes given by the\n    size of corresponding core dimensions. By default, ``pyfunc`` is\n    assumed to take scalars as input and output.\n\nReturns\n-------\nout : callable\n    A vectorized function if ``pyfunc`` was provided,\n    a decorator otherwise.\n\nSee Also\n--------\nfrompyfunc : Takes an arbitrary Python function and returns a ufunc\n\nNotes\n-----\nThe `vectorize` function is provided primarily for convenience, not for\nperformance. The implementation is essentially a for loop.\n\nIf `otypes` is not specified, then a call to the function with the\nfirst argument will be used to determine the number of outputs.  The\nresults of this call will be cached if `cache` is `True` to prevent\ncalling the function twice.  However, to implement the cache, the\noriginal function must be wrapped which will slow down subsequent\ncalls, so only do this if your function is expensive.\n\nThe new keyword argument interface and `excluded` argument support\nfurther degrades performance.\n\nReferences\n----------\n.. [1] :doc:`/reference/c-api/generalized-ufuncs`\n\nExamples\n--------\n>>> import numpy as np\n>>> def myfunc(a, b):\n...     \"Return a-b if a>b, otherwise return a+b\"\n...     if a > b:\n...         return a - b\n...     else:\n...         return a + b\n\n>>> vfunc = np.vectorize(myfunc)\n>>> vfunc([1, 2, 3, 4], 2)\narray([3, 4, 1, 2])\n\nThe docstring is taken from the input function to `vectorize` unless it\nis specified:\n\n>>> vfunc.__doc__\n'Return a-b if a>b, otherwise return a+b'\n>>> vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`')\n>>> vfunc.__doc__\n'Vectorized `myfunc`'\n\nThe output type is determined by evaluating the first element of the input,\nunless it is specified:\n\n>>> out = vfunc([1, 2, 3, 4], 2)\n>>> type(out[0])\n<class 'numpy.int64'>\n>>> vfunc = np.vectorize(myfunc, otypes=[float])\n>>> out = vfunc([1, 2, 3, 4], 2)\n>>> type(out[0])\n<class 'numpy.float64'>\n\nThe `excluded` argument can be used to prevent vectorizing over certain\narguments.  This can be useful for array-like arguments of a fixed length\nsuch as the coefficients for a polynomial as in `polyval`:\n\n>>> def mypolyval(p, x):\n...     _p = list(p)\n...     res = _p.pop(0)\n...     while _p:\n...         res = res*x + _p.pop(0)\n...     return res\n\nHere, we exclude the zeroth argument from vectorization whether it is\npassed by position or keyword.\n\n>>> vpolyval = np.vectorize(mypolyval, excluded={0, 'p'})\n>>> vpolyval([1, 2, 3], x=[0, 1])\narray([3, 6])\n>>> vpolyval(p=[1, 2, 3], x=[0, 1])\narray([3, 6])\n\nThe `signature` argument allows for vectorizing functions that act on\nnon-scalar arrays of fixed length. For example, you can use it for a\nvectorized calculation of Pearson correlation coefficient and its p-value:\n\n>>> import scipy.stats\n>>> pearsonr = np.vectorize(scipy.stats.pearsonr,\n...                 signature='(n),(n)->(),()')\n>>> pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])\n(array([ 1., -1.]), array([ 0.,  0.]))\n\nOr for a vectorized convolution:\n\n>>> convolve = np.vectorize(np.convolve, signature='(n),(m)->(k)')\n>>> convolve(np.eye(4), [1, 2, 1])\narray([[1., 2., 1., 0., 0., 0.],\n       [0., 1., 2., 1., 0., 0.],\n       [0., 0., 1., 2., 1., 0.],\n       [0., 0., 0., 1., 2., 1.]])\n\nDecorator syntax is supported.  The decorator can be called as\na function to provide keyword arguments:\n\n>>> @np.vectorize\n... def identity(x):\n...     return x\n...\n>>> identity([0, 1, 2])\narray([0, 1, 2])\n>>> @np.vectorize(otypes=[float])\n... def as_float(x):\n...     return x\n...\n>>> as_float([0, 1, 2])\narray([0., 1., 2.])",
          "functions": [
            {
              "name": "__call__",
              "doc": "Call self as a function.",
              "signature": "(self, *args, **kwargs)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, pyfunc=<no value>, otypes=None, doc=None, excluded=None, cache=False, signature=None)"
            },
            {
              "name": "_call_as_normal",
              "doc": "Return arrays with the results of `pyfunc` broadcast (vectorized) over\n`args` and `kwargs` not in `excluded`.",
              "signature": "(self, *args, **kwargs)"
            },
            {
              "name": "_get_ufunc_and_otypes",
              "doc": "Return (ufunc, otypes).",
              "signature": "(self, func, args)"
            },
            {
              "name": "_init_stage_2",
              "doc": null,
              "signature": "(self, pyfunc, *args, **kwargs)"
            },
            {
              "name": "_vectorize_call",
              "doc": "Vectorized call to `func` over positional `args`.",
              "signature": "(self, func, args)"
            },
            {
              "name": "_vectorize_call_with_signature",
              "doc": "Vectorized call over positional arguments with a signature.",
              "signature": "(self, func, args)"
            }
          ]
        },
        {
          "name": "void",
          "doc": "np.void(length_or_data, /, dtype=None)\n\nCreate a new structured or unstructured void scalar.\n\nParameters\n----------\nlength_or_data : int, array-like, bytes-like, object\n   One of multiple meanings (see notes).  The length or\n   bytes data of an unstructured void.  Or alternatively,\n   the data to be stored in the new scalar when `dtype`\n   is provided.\n   This can be an array-like, in which case an array may\n   be returned.\ndtype : dtype, optional\n   If provided the dtype of the new scalar.  This dtype must\n   be \"void\" dtype (i.e. a structured or unstructured void,\n   see also :ref:`defining-structured-types`).\n\n   .. versionadded:: 1.24\n\nNotes\n-----\nFor historical reasons and because void scalars can represent both\narbitrary byte data and structured dtypes, the void constructor\nhas three calling conventions:\n\n1. ``np.void(5)`` creates a ``dtype=\"V5\"`` scalar filled with five\n   ``\\0`` bytes.  The 5 can be a Python or NumPy integer.\n2. ``np.void(b\"bytes-like\")`` creates a void scalar from the byte string.\n   The dtype itemsize will match the byte string length, here ``\"V10\"``.\n3. When a ``dtype=`` is passed the call is roughly the same as an\n   array creation.  However, a void scalar rather than array is returned.\n\nPlease see the examples which show all three different conventions.\n\nExamples\n--------\n>>> np.void(5)\nnp.void(b'\\x00\\x00\\x00\\x00\\x00')\n>>> np.void(b'abcd')\nnp.void(b'\\x61\\x62\\x63\\x64')\n>>> np.void((3.2, b'eggs'), dtype=\"d,S5\")\nnp.void((3.2, b'eggs'), dtype=[('f0', '<f8'), ('f1', 'S5')])\n>>> np.void(3, dtype=[('x', np.int8), ('y', np.int8)])\nnp.void((3, 3), dtype=[('x', 'i1'), ('y', 'i1')])\n\n:Character code: ``'V'``",
          "functions": []
        }
      ]
    }
  },
  {
    "package": "urllib3",
    "base": {
      "functions": [
        {
          "name": "add_stderr_logger",
          "doc": "Helper for quickly adding a StreamHandler to the logger. Useful for\ndebugging.\n\nReturns the handler after adding it.",
          "signature": "(level: 'int' = 10) -> 'logging.StreamHandler[typing.TextIO]'"
        },
        {
          "name": "connection_from_url",
          "doc": "Given a url, return an :class:`.ConnectionPool` instance of its host.\n\nThis is a shortcut for not having to parse out the scheme, host, and port\nof the url before creating an :class:`.ConnectionPool` instance.\n\n:param url:\n    Absolute URL string that must include the scheme. Port is optional.\n\n:param \\**kw:\n    Passes additional parameters to the constructor of the appropriate\n    :class:`.ConnectionPool`. Useful for specifying things like\n    timeout, maxsize, headers, etc.\n\nExample::\n\n    >>> conn = connection_from_url('http://google.com/')\n    >>> r = conn.request('GET', '/')",
          "signature": "(url: 'str', **kw: 'typing.Any') -> 'HTTPConnectionPool'"
        },
        {
          "name": "disable_warnings",
          "doc": "Helper for quickly disabling all urllib3 warnings.",
          "signature": "(category: 'type[Warning]' = <class 'urllib3.exceptions.HTTPWarning'>) -> 'None'"
        },
        {
          "name": "encode_multipart_formdata",
          "doc": "Encode a dictionary of ``fields`` using the multipart/form-data MIME format.\n\n:param fields:\n    Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).\n    Values are processed by :func:`urllib3.fields.RequestField.from_tuples`.\n\n:param boundary:\n    If not specified, then a random boundary will be generated using\n    :func:`urllib3.filepost.choose_boundary`.",
          "signature": "(fields: '_TYPE_FIELDS', boundary: 'str | None' = None) -> 'tuple[bytes, str]'"
        },
        {
          "name": "make_headers",
          "doc": "Shortcuts for generating request headers.\n\n:param keep_alive:\n    If ``True``, adds 'connection: keep-alive' header.\n\n:param accept_encoding:\n    Can be a boolean, list, or string.\n    ``True`` translates to 'gzip,deflate'.  If the dependencies for\n    Brotli (either the ``brotli`` or ``brotlicffi`` package) and/or Zstandard\n    (the ``zstandard`` package) algorithms are installed, then their encodings are\n    included in the string ('br' and 'zstd', respectively).\n    List will get joined by comma.\n    String will be used as provided.\n\n:param user_agent:\n    String representing the user-agent you want, such as\n    \"python-urllib3/0.6\"\n\n:param basic_auth:\n    Colon-separated username:password string for 'authorization: basic ...'\n    auth header.\n\n:param proxy_basic_auth:\n    Colon-separated username:password string for 'proxy-authorization: basic ...'\n    auth header.\n\n:param disable_cache:\n    If ``True``, adds 'cache-control: no-cache' header.\n\nExample:\n\n.. code-block:: python\n\n    import urllib3\n\n    print(urllib3.util.make_headers(keep_alive=True, user_agent=\"Batman/1.0\"))\n    # {'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}\n    print(urllib3.util.make_headers(accept_encoding=True))\n    # {'accept-encoding': 'gzip,deflate'}",
          "signature": "(keep_alive: 'bool | None' = None, accept_encoding: 'bool | list[str] | str | None' = None, user_agent: 'str | None' = None, basic_auth: 'str | None' = None, proxy_basic_auth: 'str | None' = None, disable_cache: 'bool | None' = None) -> 'dict[str, str]'"
        },
        {
          "name": "proxy_from_url",
          "doc": null,
          "signature": "(url: 'str', **kw: 'typing.Any') -> 'ProxyManager'"
        },
        {
          "name": "request",
          "doc": "A convenience, top-level request method. It uses a module-global ``PoolManager`` instance.\nTherefore, its side effects could be shared across dependencies relying on it.\nTo avoid side effects create a new ``PoolManager`` instance and use it instead.\nThe method does not accept low-level ``**urlopen_kw`` keyword arguments.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param body:\n    Data to send in the request body, either :class:`str`, :class:`bytes`,\n    an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n:param fields:\n    Data to encode and send in the request body.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc.\n\n:param bool preload_content:\n    If True, the response's body will be preloaded into memory.\n\n:param bool decode_content:\n    If True, will attempt to decode the body based on the\n    'content-encoding' header.\n\n:param redirect:\n    If True, automatically handle redirects (status codes 301, 302,\n    303, 307, 308). Each redirect counts as a retry. Disabling retries\n    will disable redirect, too.\n\n:param retries:\n    Configure the number of retries to allow before raising a\n    :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n    If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a\n    :class:`~urllib3.util.retry.Retry` object for fine-grained control\n    over different types of retries.\n    Pass an integer number to retry connection errors that many times,\n    but no other types of errors. Pass zero to never retry.\n\n    If ``False``, then retries are disabled and any exception is raised\n    immediately. Also, instead of raising a MaxRetryError on redirects,\n    the redirect response will be returned.\n\n:type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n:param timeout:\n    If specified, overrides the default timeout for this one\n    request. It may be a float (in seconds) or an instance of\n    :class:`urllib3.util.Timeout`.\n\n:param json:\n    Data to encode and send as JSON with UTF-encoded in the request body.\n    The ``\"Content-Type\"`` header will be set to ``\"application/json\"``\n    unless specified otherwise.",
          "signature": "(method: 'str', url: 'str', *, body: '_TYPE_BODY | None' = None, fields: '_TYPE_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, preload_content: 'bool | None' = True, decode_content: 'bool | None' = True, redirect: 'bool | None' = True, retries: 'Retry | bool | int | None' = None, timeout: 'Timeout | float | int | None' = 3, json: 'typing.Any | None' = None) -> 'BaseHTTPResponse'"
        }
      ],
      "classes": [
        {
          "name": "BaseHTTPResponse",
          "doc": "The abstract base class for all I/O classes.\n\nThis class provides dummy implementations for many methods that\nderived classes can override selectively; the default implementations\nrepresent a file that cannot be read, written or seeked.\n\nEven though IOBase does not declare read, readinto, or write because\ntheir signatures will vary, implementations and clients should\nconsider those methods part of the interface. Also, implementations\nmay raise UnsupportedOperation when operations they do not support are\ncalled.\n\nThe basic type used for binary data read from or written to a file is\nbytes. Other bytes-like objects are accepted as method arguments too.\nIn some cases (such as readinto), a writable object is required. Text\nI/O classes work with str data.\n\nNote that calling any method (except additional calls to close(),\nwhich are ignored) on a closed stream should raise a ValueError.\n\nIOBase (and its subclasses) support the iterator protocol, meaning\nthat an IOBase object can be iterated over yielding the lines in a\nstream.\n\nIOBase also supports the :keyword:`with` statement. In this example,\nfp is closed after the suite of the with statement is complete:\n\nwith open('spam.txt', 'r') as fp:\n    fp.write('Spam and eggs!')",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, *, headers: 'typing.Mapping[str, str] | typing.Mapping[bytes, bytes] | None' = None, status: 'int', version: 'int', version_string: 'str', reason: 'str | None', decode_content: 'bool', request_url: 'str | None', retries: 'Retry | None' = None) -> 'None'"
            },
            {
              "name": "_decode",
              "doc": "Decode the data passed in and potentially flush the decoder.",
              "signature": "(self, data: 'bytes', decode_content: 'bool | None', flush_decoder: 'bool') -> 'bytes'"
            },
            {
              "name": "_flush_decoder",
              "doc": "Flushes the decoder. Should only be called if the decoder is actually\nbeing used.",
              "signature": "(self) -> 'bytes'"
            },
            {
              "name": "_init_decoder",
              "doc": "Set-up the _decoder attribute if necessary.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "close",
              "doc": "Flush and close the IO object.\n\nThis method has no effect if the file is already closed.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "drain_conn",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "get_redirect_location",
              "doc": "Should we redirect and where to?\n\n:returns: Truthy redirect location string if we got a redirect status\n    code and valid location. ``None`` if redirect status and no\n    location. ``False`` if not a redirect status code.",
              "signature": "(self) -> 'str | None | typing.Literal[False]'"
            },
            {
              "name": "getheader",
              "doc": null,
              "signature": "(self, name: 'str', default: 'str | None' = None) -> 'str | None'"
            },
            {
              "name": "getheaders",
              "doc": null,
              "signature": "(self) -> 'HTTPHeaderDict'"
            },
            {
              "name": "geturl",
              "doc": null,
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "info",
              "doc": null,
              "signature": "(self) -> 'HTTPHeaderDict'"
            },
            {
              "name": "json",
              "doc": "Deserializes the body of the HTTP response as a Python object.\n\nThe body of the HTTP response must be encoded using UTF-8, as per\n`RFC 8529 Section 8.1 <https://www.rfc-editor.org/rfc/rfc8259#section-8.1>`_.\n\nTo use a custom JSON decoder pass the result of :attr:`HTTPResponse.data` to\nyour custom decoder instead.\n\nIf the body of the HTTP response is not decodable to UTF-8, a\n`UnicodeDecodeError` will be raised. If the body of the HTTP response is not a\nvalid JSON document, a `json.JSONDecodeError` will be raised.\n\nRead more :ref:`here <json_content>`.\n\n:returns: The body of the HTTP response as a Python object.",
              "signature": "(self) -> 'typing.Any'"
            },
            {
              "name": "read",
              "doc": null,
              "signature": "(self, amt: 'int | None' = None, decode_content: 'bool | None' = None, cache_content: 'bool' = False) -> 'bytes'"
            },
            {
              "name": "read1",
              "doc": null,
              "signature": "(self, amt: 'int | None' = None, decode_content: 'bool | None' = None) -> 'bytes'"
            },
            {
              "name": "read_chunked",
              "doc": null,
              "signature": "(self, amt: 'int | None' = None, decode_content: 'bool | None' = None) -> 'typing.Iterator[bytes]'"
            },
            {
              "name": "readinto",
              "doc": null,
              "signature": "(self, b: 'bytearray') -> 'int'"
            },
            {
              "name": "release_conn",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "shutdown",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "stream",
              "doc": null,
              "signature": "(self, amt: 'int | None' = 65536, decode_content: 'bool | None' = None) -> 'typing.Iterator[bytes]'"
            }
          ]
        },
        {
          "name": "HTTPConnectionPool",
          "doc": "Thread-safe connection pool for one host.\n\n:param host:\n    Host used for this HTTP Connection (e.g. \"localhost\"), passed into\n    :class:`http.client.HTTPConnection`.\n\n:param port:\n    Port used for this HTTP Connection (None is equivalent to 80), passed\n    into :class:`http.client.HTTPConnection`.\n\n:param timeout:\n    Socket timeout in seconds for each individual connection. This can\n    be a float or integer, which sets the timeout for the HTTP request,\n    or an instance of :class:`urllib3.util.Timeout` which gives you more\n    fine-grained control over request timeouts. After the constructor has\n    been parsed, this is always a `urllib3.util.Timeout` object.\n\n:param maxsize:\n    Number of connections to save that can be reused. More than 1 is useful\n    in multithreaded situations. If ``block`` is set to False, more\n    connections will be created but they will not be saved once they've\n    been used.\n\n:param block:\n    If set to True, no more than ``maxsize`` connections will be used at\n    a time. When no free connections are available, the call will block\n    until a connection has been released. This is a useful side effect for\n    particular multithreaded situations where one does not want to use more\n    than maxsize connections per host to prevent flooding.\n\n:param headers:\n    Headers to include with all requests, unless other headers are given\n    explicitly.\n\n:param retries:\n    Retry configuration to use by default with requests in this pool.\n\n:param _proxy:\n    Parsed proxy URL, should not be used directly, instead, see\n    :class:`urllib3.ProxyManager`\n\n:param _proxy_headers:\n    A dictionary with proxy headers, should not be used directly,\n    instead, see :class:`urllib3.ProxyManager`\n\n:param \\**conn_kw:\n    Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`,\n    :class:`urllib3.connection.HTTPSConnection` instances.",
          "functions": [
            {
              "name": "__enter__",
              "doc": null,
              "signature": "(self) -> 'Self'"
            },
            {
              "name": "__exit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'typing.Literal[False]'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, host: 'str', port: 'int | None' = None, timeout: '_TYPE_TIMEOUT | None' = <_TYPE_DEFAULT.token: -1>, maxsize: 'int' = 1, block: 'bool' = False, headers: 'typing.Mapping[str, str] | None' = None, retries: 'Retry | bool | int | None' = None, _proxy: 'Url | None' = None, _proxy_headers: 'typing.Mapping[str, str] | None' = None, _proxy_config: 'ProxyConfig | None' = None, **conn_kw: 'typing.Any')"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "_get_conn",
              "doc": "Get a connection. Will return a pooled connection if one is available.\n\nIf no connections are available and :prop:`.block` is ``False``, then a\nfresh connection is returned.\n\n:param timeout:\n    Seconds to wait before giving up and raising\n    :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and\n    :prop:`.block` is ``True``.",
              "signature": "(self, timeout: 'float | None' = None) -> 'BaseHTTPConnection'"
            },
            {
              "name": "_get_timeout",
              "doc": "Helper that always returns a :class:`urllib3.util.Timeout`",
              "signature": "(self, timeout: '_TYPE_TIMEOUT') -> 'Timeout'"
            },
            {
              "name": "_make_request",
              "doc": "Perform a request on a given urllib connection object taken from our\npool.\n\n:param conn:\n    a connection from one of our connection pools\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param body:\n    Data to send in the request body, either :class:`str`, :class:`bytes`,\n    an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param retries:\n    Configure the number of retries to allow before raising a\n    :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n    Pass ``None`` to retry until you receive a response. Pass a\n    :class:`~urllib3.util.retry.Retry` object for fine-grained control\n    over different types of retries.\n    Pass an integer number to retry connection errors that many times,\n    but no other types of errors. Pass zero to never retry.\n\n    If ``False``, then retries are disabled and any exception is raised\n    immediately. Also, instead of raising a MaxRetryError on redirects,\n    the redirect response will be returned.\n\n:type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n:param timeout:\n    If specified, overrides the default timeout for this one\n    request. It may be a float (in seconds) or an instance of\n    :class:`urllib3.util.Timeout`.\n\n:param chunked:\n    If True, urllib3 will send the body using chunked transfer\n    encoding. Otherwise, urllib3 will send the body using the standard\n    content-length form. Defaults to False.\n\n:param response_conn:\n    Set this to ``None`` if you will handle releasing the connection or\n    set the connection to have the response release it.\n\n:param preload_content:\n  If True, the response's body will be preloaded during construction.\n\n:param decode_content:\n    If True, will attempt to decode the body based on the\n    'content-encoding' header.\n\n:param enforce_content_length:\n    Enforce content length checking. Body returned by server must match\n    value of Content-Length header, if present. Otherwise, raise error.",
              "signature": "(self, conn: 'BaseHTTPConnection', method: 'str', url: 'str', body: '_TYPE_BODY | None' = None, headers: 'typing.Mapping[str, str] | None' = None, retries: 'Retry | None' = None, timeout: '_TYPE_TIMEOUT' = <_TYPE_DEFAULT.token: -1>, chunked: 'bool' = False, response_conn: 'BaseHTTPConnection | None' = None, preload_content: 'bool' = True, decode_content: 'bool' = True, enforce_content_length: 'bool' = True) -> 'BaseHTTPResponse'"
            },
            {
              "name": "_new_conn",
              "doc": "Return a fresh :class:`HTTPConnection`.",
              "signature": "(self) -> 'BaseHTTPConnection'"
            },
            {
              "name": "_prepare_proxy",
              "doc": null,
              "signature": "(self, conn: 'BaseHTTPConnection') -> 'None'"
            },
            {
              "name": "_put_conn",
              "doc": "Put a connection back into the pool.\n\n:param conn:\n    Connection object for the current host and port as returned by\n    :meth:`._new_conn` or :meth:`._get_conn`.\n\nIf the pool is already full, the connection is closed and discarded\nbecause we exceeded maxsize. If connections are discarded frequently,\nthen maxsize should be increased.\n\nIf the pool is closed, then the connection will be closed and discarded.",
              "signature": "(self, conn: 'BaseHTTPConnection | None') -> 'None'"
            },
            {
              "name": "_raise_timeout",
              "doc": "Is the error actually a timeout? Will raise a ReadTimeout or pass",
              "signature": "(self, err: 'BaseSSLError | OSError | SocketTimeout', url: 'str', timeout_value: '_TYPE_TIMEOUT | None') -> 'None'"
            },
            {
              "name": "_validate_conn",
              "doc": "Called right before a request is made, after the socket is created.",
              "signature": "(self, conn: 'BaseHTTPConnection') -> 'None'"
            },
            {
              "name": "close",
              "doc": "Close all pooled connections and disable the pool.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "is_same_host",
              "doc": "Check if the given ``url`` is a member of the same host as this\nconnection pool.",
              "signature": "(self, url: 'str') -> 'bool'"
            },
            {
              "name": "request",
              "doc": "Make a request using :meth:`urlopen` with the appropriate encoding of\n``fields`` based on the ``method`` used.\n\nThis is a convenience method that requires the least amount of manual\neffort. It can be used in most situations, while still having the\noption to drop down to more specific methods when necessary, such as\n:meth:`request_encode_url`, :meth:`request_encode_body`,\nor even the lowest level :meth:`urlopen`.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param body:\n    Data to send in the request body, either :class:`str`, :class:`bytes`,\n    an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n:param fields:\n    Data to encode and send in the URL or request body, depending on ``method``.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param json:\n    Data to encode and send as JSON with UTF-encoded in the request body.\n    The ``\"Content-Type\"`` header will be set to ``\"application/json\"``\n    unless specified otherwise.",
              "signature": "(self, method: 'str', url: 'str', body: '_TYPE_BODY | None' = None, fields: '_TYPE_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, json: 'typing.Any | None' = None, **urlopen_kw: 'typing.Any') -> 'BaseHTTPResponse'"
            },
            {
              "name": "request_encode_body",
              "doc": "Make a request using :meth:`urlopen` with the ``fields`` encoded in\nthe body. This is useful for request methods like POST, PUT, PATCH, etc.\n\nWhen ``encode_multipart=True`` (default), then\n:func:`urllib3.encode_multipart_formdata` is used to encode\nthe payload with the appropriate content type. Otherwise\n:func:`urllib.parse.urlencode` is used with the\n'application/x-www-form-urlencoded' content type.\n\nMultipart encoding must be used when posting files, and it's reasonably\nsafe to use it in other times too. However, it may break request\nsigning, such as with OAuth.\n\nSupports an optional ``fields`` parameter of key/value strings AND\nkey/filetuple. A filetuple is a (filename, data, MIME type) tuple where\nthe MIME type is optional. For example::\n\n    fields = {\n        'foo': 'bar',\n        'fakefile': ('foofile.txt', 'contents of foofile'),\n        'realfile': ('barfile.txt', open('realfile').read()),\n        'typedfile': ('bazfile.bin', open('bazfile').read(),\n                      'image/jpeg'),\n        'nonamefile': 'contents of nonamefile field',\n    }\n\nWhen uploading a file, providing a filename (the first parameter of the\ntuple) is optional but recommended to best mimic behavior of browsers.\n\nNote that if ``headers`` are supplied, the 'Content-Type' header will\nbe overwritten because it depends on the dynamic random boundary string\nwhich is used to compose the body of the request. The random boundary\nstring can be explicitly set with the ``multipart_boundary`` parameter.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param fields:\n    Data to encode and send in the request body.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param encode_multipart:\n    If True, encode the ``fields`` using the multipart/form-data MIME\n    format.\n\n:param multipart_boundary:\n    If not specified, then a random boundary will be generated using\n    :func:`urllib3.filepost.choose_boundary`.",
              "signature": "(self, method: 'str', url: 'str', fields: '_TYPE_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, encode_multipart: 'bool' = True, multipart_boundary: 'str | None' = None, **urlopen_kw: 'str') -> 'BaseHTTPResponse'"
            },
            {
              "name": "request_encode_url",
              "doc": "Make a request using :meth:`urlopen` with the ``fields`` encoded in\nthe url. This is useful for request methods like GET, HEAD, DELETE, etc.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param fields:\n    Data to encode and send in the URL.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.",
              "signature": "(self, method: 'str', url: 'str', fields: '_TYPE_ENCODE_URL_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, **urlopen_kw: 'str') -> 'BaseHTTPResponse'"
            },
            {
              "name": "urlopen",
              "doc": "Get a connection from the pool and perform an HTTP request. This is the\nlowest level call for making a request, so you'll need to specify all\nthe raw details.\n\n.. note::\n\n   More commonly, it's appropriate to use a convenience method\n   such as :meth:`request`.\n\n.. note::\n\n   `release_conn` will only behave as expected if\n   `preload_content=False` because we want to make\n   `preload_content=False` the default behaviour someday soon without\n   breaking backwards compatibility.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param body:\n    Data to send in the request body, either :class:`str`, :class:`bytes`,\n    an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param retries:\n    Configure the number of retries to allow before raising a\n    :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n    If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a\n    :class:`~urllib3.util.retry.Retry` object for fine-grained control\n    over different types of retries.\n    Pass an integer number to retry connection errors that many times,\n    but no other types of errors. Pass zero to never retry.\n\n    If ``False``, then retries are disabled and any exception is raised\n    immediately. Also, instead of raising a MaxRetryError on redirects,\n    the redirect response will be returned.\n\n:type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n:param redirect:\n    If True, automatically handle redirects (status codes 301, 302,\n    303, 307, 308). Each redirect counts as a retry. Disabling retries\n    will disable redirect, too.\n\n:param assert_same_host:\n    If ``True``, will make sure that the host of the pool requests is\n    consistent else will raise HostChangedError. When ``False``, you can\n    use the pool on an HTTP proxy and request foreign hosts.\n\n:param timeout:\n    If specified, overrides the default timeout for this one\n    request. It may be a float (in seconds) or an instance of\n    :class:`urllib3.util.Timeout`.\n\n:param pool_timeout:\n    If set and the pool is set to block=True, then this method will\n    block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n    connection is available within the time period.\n\n:param bool preload_content:\n    If True, the response's body will be preloaded into memory.\n\n:param bool decode_content:\n    If True, will attempt to decode the body based on the\n    'content-encoding' header.\n\n:param release_conn:\n    If False, then the urlopen call will not release the connection\n    back into the pool once a response is received (but will release if\n    you read the entire contents of the response such as when\n    `preload_content=True`). This is useful if you're not preloading\n    the response's content immediately. You will need to call\n    ``r.release_conn()`` on the response ``r`` to return the connection\n    back into the pool. If None, it takes the value of ``preload_content``\n    which defaults to ``True``.\n\n:param bool chunked:\n    If True, urllib3 will send the body using chunked transfer\n    encoding. Otherwise, urllib3 will send the body using the standard\n    content-length form. Defaults to False.\n\n:param int body_pos:\n    Position to seek to in file-like body in the event of a retry or\n    redirect. Typically this won't need to be set because urllib3 will\n    auto-populate the value when needed.",
              "signature": "(self, method: 'str', url: 'str', body: '_TYPE_BODY | None' = None, headers: 'typing.Mapping[str, str] | None' = None, retries: 'Retry | bool | int | None' = None, redirect: 'bool' = True, assert_same_host: 'bool' = True, timeout: '_TYPE_TIMEOUT' = <_TYPE_DEFAULT.token: -1>, pool_timeout: 'int | None' = None, release_conn: 'bool | None' = None, chunked: 'bool' = False, body_pos: '_TYPE_BODY_POSITION | None' = None, preload_content: 'bool' = True, decode_content: 'bool' = True, **response_kw: 'typing.Any') -> 'BaseHTTPResponse'"
            }
          ]
        },
        {
          "name": "HTTPHeaderDict",
          "doc": ":param headers:\n    An iterable of field-value pairs. Must not contain multiple field names\n    when compared case-insensitively.\n\n:param kwargs:\n    Additional field-value pairs to pass in to ``dict.update``.\n\nA ``dict`` like container for storing HTTP Headers.\n\nField names are stored and compared case-insensitively in compliance with\nRFC 7230. Iteration provides the first case-sensitive key seen for each\ncase-insensitive pair.\n\nUsing ``__setitem__`` syntax overwrites fields that compare equal\ncase-insensitively in order to maintain ``dict``'s api. For fields that\ncompare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``\nin a loop.\n\nIf multiple fields that are equal case-insensitively are passed to the\nconstructor or ``.update``, the behavior is undefined and some will be\nlost.\n\n>>> headers = HTTPHeaderDict()\n>>> headers.add('Set-Cookie', 'foo=bar')\n>>> headers.add('set-cookie', 'baz=quxx')\n>>> headers['content-length'] = '7'\n>>> headers['SET-cookie']\n'foo=bar, baz=quxx'\n>>> headers['Content-Length']\n'7'",
          "functions": [
            {
              "name": "__contains__",
              "doc": null,
              "signature": "(self, key: 'object') -> 'bool'"
            },
            {
              "name": "__delitem__",
              "doc": null,
              "signature": "(self, key: 'str') -> 'None'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'object') -> 'bool'"
            },
            {
              "name": "__getitem__",
              "doc": null,
              "signature": "(self, key: 'str') -> 'str'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, headers: 'ValidHTTPHeaderSource | None' = None, **kwargs: 'str')"
            },
            {
              "name": "__ior__",
              "doc": null,
              "signature": "(self, other: 'object') -> 'HTTPHeaderDict'"
            },
            {
              "name": "__iter__",
              "doc": null,
              "signature": "(self) -> 'typing.Iterator[str]'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "__ne__",
              "doc": "Return self!=value.",
              "signature": "(self, other: 'object') -> 'bool'"
            },
            {
              "name": "__or__",
              "doc": "Return self|value.",
              "signature": "(self, other: 'object') -> 'Self'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__ror__",
              "doc": "Return value|self.",
              "signature": "(self, other: 'object') -> 'Self'"
            },
            {
              "name": "__setitem__",
              "doc": null,
              "signature": "(self, key: 'str', val: 'str') -> 'None'"
            },
            {
              "name": "_copy_from",
              "doc": null,
              "signature": "(self, other: 'HTTPHeaderDict') -> 'None'"
            },
            {
              "name": "_has_value_for_header",
              "doc": null,
              "signature": "(self, header_name: 'str', potential_value: 'str') -> 'bool'"
            },
            {
              "name": "_prepare_for_method_change",
              "doc": "Remove content-specific header fields before changing the request\nmethod to GET or HEAD according to RFC 9110, Section 15.4.",
              "signature": "(self) -> 'Self'"
            },
            {
              "name": "add",
              "doc": "Adds a (name, value) pair, doesn't overwrite the value if it already\nexists.\n\nIf this is called with combine=True, instead of adding a new header value\nas a distinct item during iteration, this will instead append the value to\nany existing header value with a comma. If no existing header value exists\nfor the key, then the value will simply be added, ignoring the combine parameter.\n\n>>> headers = HTTPHeaderDict(foo='bar')\n>>> headers.add('Foo', 'baz')\n>>> headers['foo']\n'bar, baz'\n>>> list(headers.items())\n[('foo', 'bar'), ('foo', 'baz')]\n>>> headers.add('foo', 'quz', combine=True)\n>>> list(headers.items())\n[('foo', 'bar, baz, quz')]",
              "signature": "(self, key: 'str', val: 'str', *, combine: 'bool' = False) -> 'None'"
            },
            {
              "name": "clear",
              "doc": "D.clear() -> None.  Remove all items from D.",
              "signature": "(self)"
            },
            {
              "name": "copy",
              "doc": null,
              "signature": "(self) -> 'Self'"
            },
            {
              "name": "discard",
              "doc": null,
              "signature": "(self, key: 'str') -> 'None'"
            },
            {
              "name": "extend",
              "doc": "Generic import function for any type of header-like object.\nAdapted version of MutableMapping.update in order to insert items\nwith self.add instead of self.__setitem__",
              "signature": "(self, *args: 'ValidHTTPHeaderSource', **kwargs: 'str') -> 'None'"
            },
            {
              "name": "get",
              "doc": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.",
              "signature": "(self, key, default=None)"
            },
            {
              "name": "get_all",
              "doc": "Returns a list of all the values for the named field. Returns an\nempty list if the key doesn't exist.",
              "signature": "(self, key: 'str', default: '_Sentinel | _DT' = <_Sentinel.not_passed: 1>) -> 'list[str] | _DT'"
            },
            {
              "name": "getallmatchingheaders",
              "doc": "Returns a list of all the values for the named field. Returns an\nempty list if the key doesn't exist.",
              "signature": "(self, key: 'str', default: '_Sentinel | _DT' = <_Sentinel.not_passed: 1>) -> 'list[str] | _DT'"
            },
            {
              "name": "getheaders",
              "doc": "Returns a list of all the values for the named field. Returns an\nempty list if the key doesn't exist.",
              "signature": "(self, key: 'str', default: '_Sentinel | _DT' = <_Sentinel.not_passed: 1>) -> 'list[str] | _DT'"
            },
            {
              "name": "getlist",
              "doc": "Returns a list of all the values for the named field. Returns an\nempty list if the key doesn't exist.",
              "signature": "(self, key: 'str', default: '_Sentinel | _DT' = <_Sentinel.not_passed: 1>) -> 'list[str] | _DT'"
            },
            {
              "name": "iget",
              "doc": "Returns a list of all the values for the named field. Returns an\nempty list if the key doesn't exist.",
              "signature": "(self, key: 'str', default: '_Sentinel | _DT' = <_Sentinel.not_passed: 1>) -> 'list[str] | _DT'"
            },
            {
              "name": "items",
              "doc": "D.items() -> a set-like object providing a view on D's items",
              "signature": "(self) -> 'HTTPHeaderDictItemView'"
            },
            {
              "name": "iteritems",
              "doc": "Iterate over all header lines, including duplicate ones.",
              "signature": "(self) -> 'typing.Iterator[tuple[str, str]]'"
            },
            {
              "name": "itermerged",
              "doc": "Iterate over all headers, merging duplicate ones together.",
              "signature": "(self) -> 'typing.Iterator[tuple[str, str]]'"
            },
            {
              "name": "keys",
              "doc": "D.keys() -> a set-like object providing a view on D's keys",
              "signature": "(self)"
            },
            {
              "name": "pop",
              "doc": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\nIf key is not found, d is returned if given, otherwise KeyError is raised.",
              "signature": "(self, key, default=<object object at 0x0000023EF5D14180>)"
            },
            {
              "name": "popitem",
              "doc": "D.popitem() -> (k, v), remove and return some (key, value) pair\nas a 2-tuple; but raise KeyError if D is empty.",
              "signature": "(self)"
            },
            {
              "name": "setdefault",
              "doc": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D",
              "signature": "(self, key: 'str', default: 'str' = '') -> 'str'"
            },
            {
              "name": "update",
              "doc": "D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.\nIf E present and has a .keys() method, does:     for k in E: D[k] = E[k]\nIf E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v\nIn either case, this is followed by: for k, v in F.items(): D[k] = v",
              "signature": "(self, other=(), /, **kwds)"
            },
            {
              "name": "values",
              "doc": "D.values() -> an object providing a view on D's values",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "HTTPResponse",
          "doc": "HTTP Response container.\n\nBackwards-compatible with :class:`http.client.HTTPResponse` but the response ``body`` is\nloaded and decoded on-demand when the ``data`` property is accessed.  This\nclass is also compatible with the Python standard library's :mod:`io`\nmodule, and can hence be treated as a readable object in the context of that\nframework.\n\nExtra parameters for behaviour not present in :class:`http.client.HTTPResponse`:\n\n:param preload_content:\n    If True, the response's body will be preloaded during construction.\n\n:param decode_content:\n    If True, will attempt to decode the body based on the\n    'content-encoding' header.\n\n:param original_response:\n    When this HTTPResponse wrapper is generated from an :class:`http.client.HTTPResponse`\n    object, it's convenient to include the original for debug purposes. It's\n    otherwise unused.\n\n:param retries:\n    The retries contains the last :class:`~urllib3.util.retry.Retry` that\n    was used during the request.\n\n:param enforce_content_length:\n    Enforce content length checking. Body returned by server must match\n    value of Content-Length header, if present. Otherwise, raise error.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, body: '_TYPE_BODY' = '', headers: 'typing.Mapping[str, str] | typing.Mapping[bytes, bytes] | None' = None, status: 'int' = 0, version: 'int' = 0, version_string: 'str' = 'HTTP/?', reason: 'str | None' = None, preload_content: 'bool' = True, decode_content: 'bool' = True, original_response: '_HttplibHTTPResponse | None' = None, pool: 'HTTPConnectionPool | None' = None, connection: 'HTTPConnection | None' = None, msg: '_HttplibHTTPMessage | None' = None, retries: 'Retry | None' = None, enforce_content_length: 'bool' = True, request_method: 'str | None' = None, request_url: 'str | None' = None, auto_close: 'bool' = True, sock_shutdown: 'typing.Callable[[int], None] | None' = None) -> 'None'"
            },
            {
              "name": "__iter__",
              "doc": "Implement iter(self).",
              "signature": "(self) -> 'typing.Iterator[bytes]'"
            },
            {
              "name": "_decode",
              "doc": "Decode the data passed in and potentially flush the decoder.",
              "signature": "(self, data: 'bytes', decode_content: 'bool | None', flush_decoder: 'bool') -> 'bytes'"
            },
            {
              "name": "_error_catcher",
              "doc": "Catch low-level python exceptions, instead re-raising urllib3\nvariants, so that low-level exceptions are not leaked in the\nhigh-level api.\n\nOn exit, release the connection back to the pool.",
              "signature": "(self) -> 'typing.Generator[None]'"
            },
            {
              "name": "_flush_decoder",
              "doc": "Flushes the decoder. Should only be called if the decoder is actually\nbeing used.",
              "signature": "(self) -> 'bytes'"
            },
            {
              "name": "_fp_read",
              "doc": "Read a response with the thought that reading the number of bytes\nlarger than can fit in a 32-bit int at a time via SSL in some\nknown cases leads to an overflow error that has to be prevented\nif `amt` or `self.length_remaining` indicate that a problem may\nhappen.\n\nThe known cases:\n  * CPython < 3.9.7 because of a bug\n    https://github.com/urllib3/urllib3/issues/2513#issuecomment-1152559900.\n  * urllib3 injected with pyOpenSSL-backed SSL-support.\n  * CPython < 3.10 only when `amt` does not fit 32-bit int.",
              "signature": "(self, amt: 'int | None' = None, *, read1: 'bool' = False) -> 'bytes'"
            },
            {
              "name": "_handle_chunk",
              "doc": null,
              "signature": "(self, amt: 'int | None') -> 'bytes'"
            },
            {
              "name": "_init_decoder",
              "doc": "Set-up the _decoder attribute if necessary.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "_init_length",
              "doc": "Set initial length value for Response content if available.",
              "signature": "(self, request_method: 'str | None') -> 'int | None'"
            },
            {
              "name": "_raw_read",
              "doc": "Reads `amt` of bytes from the socket.",
              "signature": "(self, amt: 'int | None' = None, *, read1: 'bool' = False) -> 'bytes'"
            },
            {
              "name": "_update_chunk_length",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "close",
              "doc": "Flush and close the IO object.\n\nThis method has no effect if the file is already closed.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "drain_conn",
              "doc": "Read and discard any remaining HTTP response data in the response connection.\n\nUnread data in the HTTPResponse connection blocks the connection from being released back to the pool.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "fileno",
              "doc": "Returns underlying file descriptor if one exists.\n\nOSError is raised if the IO object does not use a file descriptor.",
              "signature": "(self) -> 'int'"
            },
            {
              "name": "flush",
              "doc": "Flush write buffers, if applicable.\n\nThis is not implemented for read-only and non-blocking streams.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "get_redirect_location",
              "doc": "Should we redirect and where to?\n\n:returns: Truthy redirect location string if we got a redirect status\n    code and valid location. ``None`` if redirect status and no\n    location. ``False`` if not a redirect status code.",
              "signature": "(self) -> 'str | None | typing.Literal[False]'"
            },
            {
              "name": "getheader",
              "doc": null,
              "signature": "(self, name: 'str', default: 'str | None' = None) -> 'str | None'"
            },
            {
              "name": "getheaders",
              "doc": null,
              "signature": "(self) -> 'HTTPHeaderDict'"
            },
            {
              "name": "geturl",
              "doc": null,
              "signature": "(self) -> 'str | None'"
            },
            {
              "name": "info",
              "doc": null,
              "signature": "(self) -> 'HTTPHeaderDict'"
            },
            {
              "name": "isclosed",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "json",
              "doc": "Deserializes the body of the HTTP response as a Python object.\n\nThe body of the HTTP response must be encoded using UTF-8, as per\n`RFC 8529 Section 8.1 <https://www.rfc-editor.org/rfc/rfc8259#section-8.1>`_.\n\nTo use a custom JSON decoder pass the result of :attr:`HTTPResponse.data` to\nyour custom decoder instead.\n\nIf the body of the HTTP response is not decodable to UTF-8, a\n`UnicodeDecodeError` will be raised. If the body of the HTTP response is not a\nvalid JSON document, a `json.JSONDecodeError` will be raised.\n\nRead more :ref:`here <json_content>`.\n\n:returns: The body of the HTTP response as a Python object.",
              "signature": "(self) -> 'typing.Any'"
            },
            {
              "name": "read",
              "doc": "Similar to :meth:`http.client.HTTPResponse.read`, but with two additional\nparameters: ``decode_content`` and ``cache_content``.\n\n:param amt:\n    How much of the content to read. If specified, caching is skipped\n    because it doesn't make sense to cache partial content as the full\n    response.\n\n:param decode_content:\n    If True, will attempt to decode the body based on the\n    'content-encoding' header.\n\n:param cache_content:\n    If True, will save the returned data such that the same result is\n    returned despite of the state of the underlying file object. This\n    is useful if you want the ``.data`` property to continue working\n    after having ``.read()`` the file object. (Overridden if ``amt`` is\n    set.)",
              "signature": "(self, amt: 'int | None' = None, decode_content: 'bool | None' = None, cache_content: 'bool' = False) -> 'bytes'"
            },
            {
              "name": "read1",
              "doc": "Similar to ``http.client.HTTPResponse.read1`` and documented\nin :meth:`io.BufferedReader.read1`, but with an additional parameter:\n``decode_content``.\n\n:param amt:\n    How much of the content to read.\n\n:param decode_content:\n    If True, will attempt to decode the body based on the\n    'content-encoding' header.",
              "signature": "(self, amt: 'int | None' = None, decode_content: 'bool | None' = None) -> 'bytes'"
            },
            {
              "name": "read_chunked",
              "doc": "Similar to :meth:`HTTPResponse.read`, but with an additional\nparameter: ``decode_content``.\n\n:param amt:\n    How much of the content to read. If specified, caching is skipped\n    because it doesn't make sense to cache partial content as the full\n    response.\n\n:param decode_content:\n    If True, will attempt to decode the body based on the\n    'content-encoding' header.",
              "signature": "(self, amt: 'int | None' = None, decode_content: 'bool | None' = None) -> 'typing.Generator[bytes]'"
            },
            {
              "name": "readable",
              "doc": "Return whether object was opened for reading.\n\nIf False, read() will raise OSError.",
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "readinto",
              "doc": null,
              "signature": "(self, b: 'bytearray') -> 'int'"
            },
            {
              "name": "release_conn",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "shutdown",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "stream",
              "doc": "A generator wrapper for the read() method. A call will block until\n``amt`` bytes have been read from the connection or until the\nconnection is closed.\n\n:param amt:\n    How much of the content to read. The generator will return up to\n    much data per iteration, but may return less. This is particularly\n    likely when using compressed data. However, the empty string will\n    never be returned.\n\n:param decode_content:\n    If True, will attempt to decode the body based on the\n    'content-encoding' header.",
              "signature": "(self, amt: 'int | None' = 65536, decode_content: 'bool | None' = None) -> 'typing.Generator[bytes]'"
            },
            {
              "name": "supports_chunked_reads",
              "doc": "Checks if the underlying file-like object looks like a\n:class:`http.client.HTTPResponse` object. We do this by testing for\nthe fp attribute. If it is present we assume it returns raw chunks as\nprocessed by read_chunked().",
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "tell",
              "doc": "Obtain the number of bytes pulled over the wire so far. May differ from\nthe amount of content returned by :meth:``urllib3.response.HTTPResponse.read``\nif bytes are encoded on the wire (e.g, compressed).",
              "signature": "(self) -> 'int'"
            }
          ]
        },
        {
          "name": "HTTPSConnectionPool",
          "doc": "Same as :class:`.HTTPConnectionPool`, but HTTPS.\n\n:class:`.HTTPSConnection` uses one of ``assert_fingerprint``,\n``assert_hostname`` and ``host`` in this order to verify connections.\nIf ``assert_hostname`` is False, no verification is done.\n\nThe ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,\n``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl`\nis available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade\nthe connection socket into an SSL socket.",
          "functions": [
            {
              "name": "__enter__",
              "doc": null,
              "signature": "(self) -> 'Self'"
            },
            {
              "name": "__exit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'typing.Literal[False]'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, host: 'str', port: 'int | None' = None, timeout: '_TYPE_TIMEOUT | None' = <_TYPE_DEFAULT.token: -1>, maxsize: 'int' = 1, block: 'bool' = False, headers: 'typing.Mapping[str, str] | None' = None, retries: 'Retry | bool | int | None' = None, _proxy: 'Url | None' = None, _proxy_headers: 'typing.Mapping[str, str] | None' = None, key_file: 'str | None' = None, cert_file: 'str | None' = None, cert_reqs: 'int | str | None' = None, key_password: 'str | None' = None, ca_certs: 'str | None' = None, ssl_version: 'int | str | None' = None, ssl_minimum_version: 'ssl.TLSVersion | None' = None, ssl_maximum_version: 'ssl.TLSVersion | None' = None, assert_hostname: 'str | typing.Literal[False] | None' = None, assert_fingerprint: 'str | None' = None, ca_cert_dir: 'str | None' = None, **conn_kw: 'typing.Any') -> 'None'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "_get_conn",
              "doc": "Get a connection. Will return a pooled connection if one is available.\n\nIf no connections are available and :prop:`.block` is ``False``, then a\nfresh connection is returned.\n\n:param timeout:\n    Seconds to wait before giving up and raising\n    :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and\n    :prop:`.block` is ``True``.",
              "signature": "(self, timeout: 'float | None' = None) -> 'BaseHTTPConnection'"
            },
            {
              "name": "_get_timeout",
              "doc": "Helper that always returns a :class:`urllib3.util.Timeout`",
              "signature": "(self, timeout: '_TYPE_TIMEOUT') -> 'Timeout'"
            },
            {
              "name": "_make_request",
              "doc": "Perform a request on a given urllib connection object taken from our\npool.\n\n:param conn:\n    a connection from one of our connection pools\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param body:\n    Data to send in the request body, either :class:`str`, :class:`bytes`,\n    an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param retries:\n    Configure the number of retries to allow before raising a\n    :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n    Pass ``None`` to retry until you receive a response. Pass a\n    :class:`~urllib3.util.retry.Retry` object for fine-grained control\n    over different types of retries.\n    Pass an integer number to retry connection errors that many times,\n    but no other types of errors. Pass zero to never retry.\n\n    If ``False``, then retries are disabled and any exception is raised\n    immediately. Also, instead of raising a MaxRetryError on redirects,\n    the redirect response will be returned.\n\n:type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n:param timeout:\n    If specified, overrides the default timeout for this one\n    request. It may be a float (in seconds) or an instance of\n    :class:`urllib3.util.Timeout`.\n\n:param chunked:\n    If True, urllib3 will send the body using chunked transfer\n    encoding. Otherwise, urllib3 will send the body using the standard\n    content-length form. Defaults to False.\n\n:param response_conn:\n    Set this to ``None`` if you will handle releasing the connection or\n    set the connection to have the response release it.\n\n:param preload_content:\n  If True, the response's body will be preloaded during construction.\n\n:param decode_content:\n    If True, will attempt to decode the body based on the\n    'content-encoding' header.\n\n:param enforce_content_length:\n    Enforce content length checking. Body returned by server must match\n    value of Content-Length header, if present. Otherwise, raise error.",
              "signature": "(self, conn: 'BaseHTTPConnection', method: 'str', url: 'str', body: '_TYPE_BODY | None' = None, headers: 'typing.Mapping[str, str] | None' = None, retries: 'Retry | None' = None, timeout: '_TYPE_TIMEOUT' = <_TYPE_DEFAULT.token: -1>, chunked: 'bool' = False, response_conn: 'BaseHTTPConnection | None' = None, preload_content: 'bool' = True, decode_content: 'bool' = True, enforce_content_length: 'bool' = True) -> 'BaseHTTPResponse'"
            },
            {
              "name": "_new_conn",
              "doc": "Return a fresh :class:`urllib3.connection.HTTPConnection`.",
              "signature": "(self) -> 'BaseHTTPSConnection'"
            },
            {
              "name": "_prepare_proxy",
              "doc": "Establishes a tunnel connection through HTTP CONNECT.",
              "signature": "(self, conn: 'HTTPSConnection') -> 'None'"
            },
            {
              "name": "_put_conn",
              "doc": "Put a connection back into the pool.\n\n:param conn:\n    Connection object for the current host and port as returned by\n    :meth:`._new_conn` or :meth:`._get_conn`.\n\nIf the pool is already full, the connection is closed and discarded\nbecause we exceeded maxsize. If connections are discarded frequently,\nthen maxsize should be increased.\n\nIf the pool is closed, then the connection will be closed and discarded.",
              "signature": "(self, conn: 'BaseHTTPConnection | None') -> 'None'"
            },
            {
              "name": "_raise_timeout",
              "doc": "Is the error actually a timeout? Will raise a ReadTimeout or pass",
              "signature": "(self, err: 'BaseSSLError | OSError | SocketTimeout', url: 'str', timeout_value: '_TYPE_TIMEOUT | None') -> 'None'"
            },
            {
              "name": "_validate_conn",
              "doc": "Called right before a request is made, after the socket is created.",
              "signature": "(self, conn: 'BaseHTTPConnection') -> 'None'"
            },
            {
              "name": "close",
              "doc": "Close all pooled connections and disable the pool.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "is_same_host",
              "doc": "Check if the given ``url`` is a member of the same host as this\nconnection pool.",
              "signature": "(self, url: 'str') -> 'bool'"
            },
            {
              "name": "request",
              "doc": "Make a request using :meth:`urlopen` with the appropriate encoding of\n``fields`` based on the ``method`` used.\n\nThis is a convenience method that requires the least amount of manual\neffort. It can be used in most situations, while still having the\noption to drop down to more specific methods when necessary, such as\n:meth:`request_encode_url`, :meth:`request_encode_body`,\nor even the lowest level :meth:`urlopen`.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param body:\n    Data to send in the request body, either :class:`str`, :class:`bytes`,\n    an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n:param fields:\n    Data to encode and send in the URL or request body, depending on ``method``.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param json:\n    Data to encode and send as JSON with UTF-encoded in the request body.\n    The ``\"Content-Type\"`` header will be set to ``\"application/json\"``\n    unless specified otherwise.",
              "signature": "(self, method: 'str', url: 'str', body: '_TYPE_BODY | None' = None, fields: '_TYPE_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, json: 'typing.Any | None' = None, **urlopen_kw: 'typing.Any') -> 'BaseHTTPResponse'"
            },
            {
              "name": "request_encode_body",
              "doc": "Make a request using :meth:`urlopen` with the ``fields`` encoded in\nthe body. This is useful for request methods like POST, PUT, PATCH, etc.\n\nWhen ``encode_multipart=True`` (default), then\n:func:`urllib3.encode_multipart_formdata` is used to encode\nthe payload with the appropriate content type. Otherwise\n:func:`urllib.parse.urlencode` is used with the\n'application/x-www-form-urlencoded' content type.\n\nMultipart encoding must be used when posting files, and it's reasonably\nsafe to use it in other times too. However, it may break request\nsigning, such as with OAuth.\n\nSupports an optional ``fields`` parameter of key/value strings AND\nkey/filetuple. A filetuple is a (filename, data, MIME type) tuple where\nthe MIME type is optional. For example::\n\n    fields = {\n        'foo': 'bar',\n        'fakefile': ('foofile.txt', 'contents of foofile'),\n        'realfile': ('barfile.txt', open('realfile').read()),\n        'typedfile': ('bazfile.bin', open('bazfile').read(),\n                      'image/jpeg'),\n        'nonamefile': 'contents of nonamefile field',\n    }\n\nWhen uploading a file, providing a filename (the first parameter of the\ntuple) is optional but recommended to best mimic behavior of browsers.\n\nNote that if ``headers`` are supplied, the 'Content-Type' header will\nbe overwritten because it depends on the dynamic random boundary string\nwhich is used to compose the body of the request. The random boundary\nstring can be explicitly set with the ``multipart_boundary`` parameter.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param fields:\n    Data to encode and send in the request body.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param encode_multipart:\n    If True, encode the ``fields`` using the multipart/form-data MIME\n    format.\n\n:param multipart_boundary:\n    If not specified, then a random boundary will be generated using\n    :func:`urllib3.filepost.choose_boundary`.",
              "signature": "(self, method: 'str', url: 'str', fields: '_TYPE_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, encode_multipart: 'bool' = True, multipart_boundary: 'str | None' = None, **urlopen_kw: 'str') -> 'BaseHTTPResponse'"
            },
            {
              "name": "request_encode_url",
              "doc": "Make a request using :meth:`urlopen` with the ``fields`` encoded in\nthe url. This is useful for request methods like GET, HEAD, DELETE, etc.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param fields:\n    Data to encode and send in the URL.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.",
              "signature": "(self, method: 'str', url: 'str', fields: '_TYPE_ENCODE_URL_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, **urlopen_kw: 'str') -> 'BaseHTTPResponse'"
            },
            {
              "name": "urlopen",
              "doc": "Get a connection from the pool and perform an HTTP request. This is the\nlowest level call for making a request, so you'll need to specify all\nthe raw details.\n\n.. note::\n\n   More commonly, it's appropriate to use a convenience method\n   such as :meth:`request`.\n\n.. note::\n\n   `release_conn` will only behave as expected if\n   `preload_content=False` because we want to make\n   `preload_content=False` the default behaviour someday soon without\n   breaking backwards compatibility.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param body:\n    Data to send in the request body, either :class:`str`, :class:`bytes`,\n    an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param retries:\n    Configure the number of retries to allow before raising a\n    :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n    If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a\n    :class:`~urllib3.util.retry.Retry` object for fine-grained control\n    over different types of retries.\n    Pass an integer number to retry connection errors that many times,\n    but no other types of errors. Pass zero to never retry.\n\n    If ``False``, then retries are disabled and any exception is raised\n    immediately. Also, instead of raising a MaxRetryError on redirects,\n    the redirect response will be returned.\n\n:type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n:param redirect:\n    If True, automatically handle redirects (status codes 301, 302,\n    303, 307, 308). Each redirect counts as a retry. Disabling retries\n    will disable redirect, too.\n\n:param assert_same_host:\n    If ``True``, will make sure that the host of the pool requests is\n    consistent else will raise HostChangedError. When ``False``, you can\n    use the pool on an HTTP proxy and request foreign hosts.\n\n:param timeout:\n    If specified, overrides the default timeout for this one\n    request. It may be a float (in seconds) or an instance of\n    :class:`urllib3.util.Timeout`.\n\n:param pool_timeout:\n    If set and the pool is set to block=True, then this method will\n    block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n    connection is available within the time period.\n\n:param bool preload_content:\n    If True, the response's body will be preloaded into memory.\n\n:param bool decode_content:\n    If True, will attempt to decode the body based on the\n    'content-encoding' header.\n\n:param release_conn:\n    If False, then the urlopen call will not release the connection\n    back into the pool once a response is received (but will release if\n    you read the entire contents of the response such as when\n    `preload_content=True`). This is useful if you're not preloading\n    the response's content immediately. You will need to call\n    ``r.release_conn()`` on the response ``r`` to return the connection\n    back into the pool. If None, it takes the value of ``preload_content``\n    which defaults to ``True``.\n\n:param bool chunked:\n    If True, urllib3 will send the body using chunked transfer\n    encoding. Otherwise, urllib3 will send the body using the standard\n    content-length form. Defaults to False.\n\n:param int body_pos:\n    Position to seek to in file-like body in the event of a retry or\n    redirect. Typically this won't need to be set because urllib3 will\n    auto-populate the value when needed.",
              "signature": "(self, method: 'str', url: 'str', body: '_TYPE_BODY | None' = None, headers: 'typing.Mapping[str, str] | None' = None, retries: 'Retry | bool | int | None' = None, redirect: 'bool' = True, assert_same_host: 'bool' = True, timeout: '_TYPE_TIMEOUT' = <_TYPE_DEFAULT.token: -1>, pool_timeout: 'int | None' = None, release_conn: 'bool | None' = None, chunked: 'bool' = False, body_pos: '_TYPE_BODY_POSITION | None' = None, preload_content: 'bool' = True, decode_content: 'bool' = True, **response_kw: 'typing.Any') -> 'BaseHTTPResponse'"
            }
          ]
        },
        {
          "name": "PoolManager",
          "doc": "Allows for arbitrary requests while transparently keeping track of\nnecessary connection pools for you.\n\n:param num_pools:\n    Number of connection pools to cache before discarding the least\n    recently used pool.\n\n:param headers:\n    Headers to include with all requests, unless other headers are given\n    explicitly.\n\n:param \\**connection_pool_kw:\n    Additional parameters are used to create fresh\n    :class:`urllib3.connectionpool.ConnectionPool` instances.\n\nExample:\n\n.. code-block:: python\n\n    import urllib3\n\n    http = urllib3.PoolManager(num_pools=2)\n\n    resp1 = http.request(\"GET\", \"https://google.com/\")\n    resp2 = http.request(\"GET\", \"https://google.com/mail\")\n    resp3 = http.request(\"GET\", \"https://yahoo.com/\")\n\n    print(len(http.pools))\n    # 2",
          "functions": [
            {
              "name": "__enter__",
              "doc": null,
              "signature": "(self) -> 'Self'"
            },
            {
              "name": "__exit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'typing.Literal[False]'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, num_pools: 'int' = 10, headers: 'typing.Mapping[str, str] | None' = None, **connection_pool_kw: 'typing.Any') -> 'None'"
            },
            {
              "name": "_merge_pool_kwargs",
              "doc": "Merge a dictionary of override values for self.connection_pool_kw.\n\nThis does not modify self.connection_pool_kw and returns a new dict.\nAny keys in the override dictionary with a value of ``None`` are\nremoved from the merged dictionary.",
              "signature": "(self, override: 'dict[str, typing.Any] | None') -> 'dict[str, typing.Any]'"
            },
            {
              "name": "_new_pool",
              "doc": "Create a new :class:`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and\nany additional pool keyword arguments.\n\nIf ``request_context`` is provided, it is provided as keyword arguments\nto the pool class used. This method is used to actually create the\nconnection pools handed out by :meth:`connection_from_url` and\ncompanion methods. It is intended to be overridden for customization.",
              "signature": "(self, scheme: 'str', host: 'str', port: 'int', request_context: 'dict[str, typing.Any] | None' = None) -> 'HTTPConnectionPool'"
            },
            {
              "name": "_proxy_requires_url_absolute_form",
              "doc": "Indicates if the proxy requires the complete destination URL in the\nrequest.  Normally this is only needed when not using an HTTP CONNECT\ntunnel.",
              "signature": "(self, parsed_url: 'Url') -> 'bool'"
            },
            {
              "name": "clear",
              "doc": "Empty our store of pools and direct them all to close.\n\nThis will not affect in-flight connections, but they will not be\nre-used after completion.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "connection_from_context",
              "doc": "Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.\n\n``request_context`` must at least contain the ``scheme`` key and its\nvalue must be a key in ``key_fn_by_scheme`` instance variable.",
              "signature": "(self, request_context: 'dict[str, typing.Any]') -> 'HTTPConnectionPool'"
            },
            {
              "name": "connection_from_host",
              "doc": "Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.\n\nIf ``port`` isn't given, it will be derived from the ``scheme`` using\n``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is\nprovided, it is merged with the instance's ``connection_pool_kw``\nvariable and used to create the new connection pool, if one is\nneeded.",
              "signature": "(self, host: 'str | None', port: 'int | None' = None, scheme: 'str | None' = 'http', pool_kwargs: 'dict[str, typing.Any] | None' = None) -> 'HTTPConnectionPool'"
            },
            {
              "name": "connection_from_pool_key",
              "doc": "Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.\n\n``pool_key`` should be a namedtuple that only contains immutable\nobjects. At a minimum it must have the ``scheme``, ``host``, and\n``port`` fields.",
              "signature": "(self, pool_key: 'PoolKey', request_context: 'dict[str, typing.Any]') -> 'HTTPConnectionPool'"
            },
            {
              "name": "connection_from_url",
              "doc": "Similar to :func:`urllib3.connectionpool.connection_from_url`.\n\nIf ``pool_kwargs`` is not provided and a new pool needs to be\nconstructed, ``self.connection_pool_kw`` is used to initialize\nthe :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``\nis provided, it is used instead. Note that if a new pool does not\nneed to be created for the request, the provided ``pool_kwargs`` are\nnot used.",
              "signature": "(self, url: 'str', pool_kwargs: 'dict[str, typing.Any] | None' = None) -> 'HTTPConnectionPool'"
            },
            {
              "name": "request",
              "doc": "Make a request using :meth:`urlopen` with the appropriate encoding of\n``fields`` based on the ``method`` used.\n\nThis is a convenience method that requires the least amount of manual\neffort. It can be used in most situations, while still having the\noption to drop down to more specific methods when necessary, such as\n:meth:`request_encode_url`, :meth:`request_encode_body`,\nor even the lowest level :meth:`urlopen`.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param body:\n    Data to send in the request body, either :class:`str`, :class:`bytes`,\n    an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n:param fields:\n    Data to encode and send in the URL or request body, depending on ``method``.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param json:\n    Data to encode and send as JSON with UTF-encoded in the request body.\n    The ``\"Content-Type\"`` header will be set to ``\"application/json\"``\n    unless specified otherwise.",
              "signature": "(self, method: 'str', url: 'str', body: '_TYPE_BODY | None' = None, fields: '_TYPE_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, json: 'typing.Any | None' = None, **urlopen_kw: 'typing.Any') -> 'BaseHTTPResponse'"
            },
            {
              "name": "request_encode_body",
              "doc": "Make a request using :meth:`urlopen` with the ``fields`` encoded in\nthe body. This is useful for request methods like POST, PUT, PATCH, etc.\n\nWhen ``encode_multipart=True`` (default), then\n:func:`urllib3.encode_multipart_formdata` is used to encode\nthe payload with the appropriate content type. Otherwise\n:func:`urllib.parse.urlencode` is used with the\n'application/x-www-form-urlencoded' content type.\n\nMultipart encoding must be used when posting files, and it's reasonably\nsafe to use it in other times too. However, it may break request\nsigning, such as with OAuth.\n\nSupports an optional ``fields`` parameter of key/value strings AND\nkey/filetuple. A filetuple is a (filename, data, MIME type) tuple where\nthe MIME type is optional. For example::\n\n    fields = {\n        'foo': 'bar',\n        'fakefile': ('foofile.txt', 'contents of foofile'),\n        'realfile': ('barfile.txt', open('realfile').read()),\n        'typedfile': ('bazfile.bin', open('bazfile').read(),\n                      'image/jpeg'),\n        'nonamefile': 'contents of nonamefile field',\n    }\n\nWhen uploading a file, providing a filename (the first parameter of the\ntuple) is optional but recommended to best mimic behavior of browsers.\n\nNote that if ``headers`` are supplied, the 'Content-Type' header will\nbe overwritten because it depends on the dynamic random boundary string\nwhich is used to compose the body of the request. The random boundary\nstring can be explicitly set with the ``multipart_boundary`` parameter.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param fields:\n    Data to encode and send in the request body.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param encode_multipart:\n    If True, encode the ``fields`` using the multipart/form-data MIME\n    format.\n\n:param multipart_boundary:\n    If not specified, then a random boundary will be generated using\n    :func:`urllib3.filepost.choose_boundary`.",
              "signature": "(self, method: 'str', url: 'str', fields: '_TYPE_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, encode_multipart: 'bool' = True, multipart_boundary: 'str | None' = None, **urlopen_kw: 'str') -> 'BaseHTTPResponse'"
            },
            {
              "name": "request_encode_url",
              "doc": "Make a request using :meth:`urlopen` with the ``fields`` encoded in\nthe url. This is useful for request methods like GET, HEAD, DELETE, etc.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param fields:\n    Data to encode and send in the URL.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.",
              "signature": "(self, method: 'str', url: 'str', fields: '_TYPE_ENCODE_URL_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, **urlopen_kw: 'str') -> 'BaseHTTPResponse'"
            },
            {
              "name": "urlopen",
              "doc": "Same as :meth:`urllib3.HTTPConnectionPool.urlopen`\nwith custom cross-host redirect logic and only sends the request-uri\nportion of the ``url``.\n\nThe given ``url`` parameter must be absolute, such that an appropriate\n:class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.",
              "signature": "(self, method: 'str', url: 'str', redirect: 'bool' = True, **kw: 'typing.Any') -> 'BaseHTTPResponse'"
            }
          ]
        },
        {
          "name": "ProxyManager",
          "doc": "Behaves just like :class:`PoolManager`, but sends all requests through\nthe defined proxy, using the CONNECT method for HTTPS URLs.\n\n:param proxy_url:\n    The URL of the proxy to be used.\n\n:param proxy_headers:\n    A dictionary containing headers that will be sent to the proxy. In case\n    of HTTP they are being sent with each request, while in the\n    HTTPS/CONNECT case they are sent only once. Could be used for proxy\n    authentication.\n\n:param proxy_ssl_context:\n    The proxy SSL context is used to establish the TLS connection to the\n    proxy when using HTTPS proxies.\n\n:param use_forwarding_for_https:\n    (Defaults to False) If set to True will forward requests to the HTTPS\n    proxy to be made on behalf of the client instead of creating a TLS\n    tunnel via the CONNECT method. **Enabling this flag means that request\n    and response headers and content will be visible from the HTTPS proxy**\n    whereas tunneling keeps request and response headers and content\n    private.  IP address, target hostname, SNI, and port are always visible\n    to an HTTPS proxy even when this flag is disabled.\n\n:param proxy_assert_hostname:\n    The hostname of the certificate to verify against.\n\n:param proxy_assert_fingerprint:\n    The fingerprint of the certificate to verify against.\n\nExample:\n\n.. code-block:: python\n\n    import urllib3\n\n    proxy = urllib3.ProxyManager(\"https://localhost:3128/\")\n\n    resp1 = proxy.request(\"GET\", \"https://google.com/\")\n    resp2 = proxy.request(\"GET\", \"https://httpbin.org/\")\n\n    print(len(proxy.pools))\n    # 1\n\n    resp3 = proxy.request(\"GET\", \"https://httpbin.org/\")\n    resp4 = proxy.request(\"GET\", \"https://twitter.com/\")\n\n    print(len(proxy.pools))\n    # 3",
          "functions": [
            {
              "name": "__enter__",
              "doc": null,
              "signature": "(self) -> 'Self'"
            },
            {
              "name": "__exit__",
              "doc": null,
              "signature": "(self, exc_type: 'type[BaseException] | None', exc_val: 'BaseException | None', exc_tb: 'TracebackType | None') -> 'typing.Literal[False]'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, proxy_url: 'str', num_pools: 'int' = 10, headers: 'typing.Mapping[str, str] | None' = None, proxy_headers: 'typing.Mapping[str, str] | None' = None, proxy_ssl_context: 'ssl.SSLContext | None' = None, use_forwarding_for_https: 'bool' = False, proxy_assert_hostname: 'None | str | typing.Literal[False]' = None, proxy_assert_fingerprint: 'str | None' = None, **connection_pool_kw: 'typing.Any') -> 'None'"
            },
            {
              "name": "_merge_pool_kwargs",
              "doc": "Merge a dictionary of override values for self.connection_pool_kw.\n\nThis does not modify self.connection_pool_kw and returns a new dict.\nAny keys in the override dictionary with a value of ``None`` are\nremoved from the merged dictionary.",
              "signature": "(self, override: 'dict[str, typing.Any] | None') -> 'dict[str, typing.Any]'"
            },
            {
              "name": "_new_pool",
              "doc": "Create a new :class:`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and\nany additional pool keyword arguments.\n\nIf ``request_context`` is provided, it is provided as keyword arguments\nto the pool class used. This method is used to actually create the\nconnection pools handed out by :meth:`connection_from_url` and\ncompanion methods. It is intended to be overridden for customization.",
              "signature": "(self, scheme: 'str', host: 'str', port: 'int', request_context: 'dict[str, typing.Any] | None' = None) -> 'HTTPConnectionPool'"
            },
            {
              "name": "_proxy_requires_url_absolute_form",
              "doc": "Indicates if the proxy requires the complete destination URL in the\nrequest.  Normally this is only needed when not using an HTTP CONNECT\ntunnel.",
              "signature": "(self, parsed_url: 'Url') -> 'bool'"
            },
            {
              "name": "_set_proxy_headers",
              "doc": "Sets headers needed by proxies: specifically, the Accept and Host\nheaders. Only sets headers not provided by the user.",
              "signature": "(self, url: 'str', headers: 'typing.Mapping[str, str] | None' = None) -> 'typing.Mapping[str, str]'"
            },
            {
              "name": "clear",
              "doc": "Empty our store of pools and direct them all to close.\n\nThis will not affect in-flight connections, but they will not be\nre-used after completion.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "connection_from_context",
              "doc": "Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.\n\n``request_context`` must at least contain the ``scheme`` key and its\nvalue must be a key in ``key_fn_by_scheme`` instance variable.",
              "signature": "(self, request_context: 'dict[str, typing.Any]') -> 'HTTPConnectionPool'"
            },
            {
              "name": "connection_from_host",
              "doc": "Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.\n\nIf ``port`` isn't given, it will be derived from the ``scheme`` using\n``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is\nprovided, it is merged with the instance's ``connection_pool_kw``\nvariable and used to create the new connection pool, if one is\nneeded.",
              "signature": "(self, host: 'str | None', port: 'int | None' = None, scheme: 'str | None' = 'http', pool_kwargs: 'dict[str, typing.Any] | None' = None) -> 'HTTPConnectionPool'"
            },
            {
              "name": "connection_from_pool_key",
              "doc": "Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.\n\n``pool_key`` should be a namedtuple that only contains immutable\nobjects. At a minimum it must have the ``scheme``, ``host``, and\n``port`` fields.",
              "signature": "(self, pool_key: 'PoolKey', request_context: 'dict[str, typing.Any]') -> 'HTTPConnectionPool'"
            },
            {
              "name": "connection_from_url",
              "doc": "Similar to :func:`urllib3.connectionpool.connection_from_url`.\n\nIf ``pool_kwargs`` is not provided and a new pool needs to be\nconstructed, ``self.connection_pool_kw`` is used to initialize\nthe :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``\nis provided, it is used instead. Note that if a new pool does not\nneed to be created for the request, the provided ``pool_kwargs`` are\nnot used.",
              "signature": "(self, url: 'str', pool_kwargs: 'dict[str, typing.Any] | None' = None) -> 'HTTPConnectionPool'"
            },
            {
              "name": "request",
              "doc": "Make a request using :meth:`urlopen` with the appropriate encoding of\n``fields`` based on the ``method`` used.\n\nThis is a convenience method that requires the least amount of manual\neffort. It can be used in most situations, while still having the\noption to drop down to more specific methods when necessary, such as\n:meth:`request_encode_url`, :meth:`request_encode_body`,\nor even the lowest level :meth:`urlopen`.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param body:\n    Data to send in the request body, either :class:`str`, :class:`bytes`,\n    an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n:param fields:\n    Data to encode and send in the URL or request body, depending on ``method``.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param json:\n    Data to encode and send as JSON with UTF-encoded in the request body.\n    The ``\"Content-Type\"`` header will be set to ``\"application/json\"``\n    unless specified otherwise.",
              "signature": "(self, method: 'str', url: 'str', body: '_TYPE_BODY | None' = None, fields: '_TYPE_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, json: 'typing.Any | None' = None, **urlopen_kw: 'typing.Any') -> 'BaseHTTPResponse'"
            },
            {
              "name": "request_encode_body",
              "doc": "Make a request using :meth:`urlopen` with the ``fields`` encoded in\nthe body. This is useful for request methods like POST, PUT, PATCH, etc.\n\nWhen ``encode_multipart=True`` (default), then\n:func:`urllib3.encode_multipart_formdata` is used to encode\nthe payload with the appropriate content type. Otherwise\n:func:`urllib.parse.urlencode` is used with the\n'application/x-www-form-urlencoded' content type.\n\nMultipart encoding must be used when posting files, and it's reasonably\nsafe to use it in other times too. However, it may break request\nsigning, such as with OAuth.\n\nSupports an optional ``fields`` parameter of key/value strings AND\nkey/filetuple. A filetuple is a (filename, data, MIME type) tuple where\nthe MIME type is optional. For example::\n\n    fields = {\n        'foo': 'bar',\n        'fakefile': ('foofile.txt', 'contents of foofile'),\n        'realfile': ('barfile.txt', open('realfile').read()),\n        'typedfile': ('bazfile.bin', open('bazfile').read(),\n                      'image/jpeg'),\n        'nonamefile': 'contents of nonamefile field',\n    }\n\nWhen uploading a file, providing a filename (the first parameter of the\ntuple) is optional but recommended to best mimic behavior of browsers.\n\nNote that if ``headers`` are supplied, the 'Content-Type' header will\nbe overwritten because it depends on the dynamic random boundary string\nwhich is used to compose the body of the request. The random boundary\nstring can be explicitly set with the ``multipart_boundary`` parameter.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param fields:\n    Data to encode and send in the request body.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param encode_multipart:\n    If True, encode the ``fields`` using the multipart/form-data MIME\n    format.\n\n:param multipart_boundary:\n    If not specified, then a random boundary will be generated using\n    :func:`urllib3.filepost.choose_boundary`.",
              "signature": "(self, method: 'str', url: 'str', fields: '_TYPE_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, encode_multipart: 'bool' = True, multipart_boundary: 'str | None' = None, **urlopen_kw: 'str') -> 'BaseHTTPResponse'"
            },
            {
              "name": "request_encode_url",
              "doc": "Make a request using :meth:`urlopen` with the ``fields`` encoded in\nthe url. This is useful for request methods like GET, HEAD, DELETE, etc.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param url:\n    The URL to perform the request on.\n\n:param fields:\n    Data to encode and send in the URL.\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.",
              "signature": "(self, method: 'str', url: 'str', fields: '_TYPE_ENCODE_URL_FIELDS | None' = None, headers: 'typing.Mapping[str, str] | None' = None, **urlopen_kw: 'str') -> 'BaseHTTPResponse'"
            },
            {
              "name": "urlopen",
              "doc": "Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.",
              "signature": "(self, method: 'str', url: 'str', redirect: 'bool' = True, **kw: 'typing.Any') -> 'BaseHTTPResponse'"
            }
          ]
        },
        {
          "name": "Retry",
          "doc": "Retry configuration.\n\nEach retry attempt will create a new Retry object with updated values, so\nthey can be safely reused.\n\nRetries can be defined as a default for a pool:\n\n.. code-block:: python\n\n    retries = Retry(connect=5, read=2, redirect=5)\n    http = PoolManager(retries=retries)\n    response = http.request(\"GET\", \"https://example.com/\")\n\nOr per-request (which overrides the default for the pool):\n\n.. code-block:: python\n\n    response = http.request(\"GET\", \"https://example.com/\", retries=Retry(10))\n\nRetries can be disabled by passing ``False``:\n\n.. code-block:: python\n\n    response = http.request(\"GET\", \"https://example.com/\", retries=False)\n\nErrors will be wrapped in :class:`~urllib3.exceptions.MaxRetryError` unless\nretries are disabled, in which case the causing exception will be raised.\n\n:param int total:\n    Total number of retries to allow. Takes precedence over other counts.\n\n    Set to ``None`` to remove this constraint and fall back on other\n    counts.\n\n    Set to ``0`` to fail on the first retry.\n\n    Set to ``False`` to disable and imply ``raise_on_redirect=False``.\n\n:param int connect:\n    How many connection-related errors to retry on.\n\n    These are errors raised before the request is sent to the remote server,\n    which we assume has not triggered the server to process the request.\n\n    Set to ``0`` to fail on the first retry of this type.\n\n:param int read:\n    How many times to retry on read errors.\n\n    These errors are raised after the request was sent to the server, so the\n    request may have side-effects.\n\n    Set to ``0`` to fail on the first retry of this type.\n\n:param int redirect:\n    How many redirects to perform. Limit this to avoid infinite redirect\n    loops.\n\n    A redirect is a HTTP response with a status code 301, 302, 303, 307 or\n    308.\n\n    Set to ``0`` to fail on the first retry of this type.\n\n    Set to ``False`` to disable and imply ``raise_on_redirect=False``.\n\n:param int status:\n    How many times to retry on bad status codes.\n\n    These are retries made on responses, where status code matches\n    ``status_forcelist``.\n\n    Set to ``0`` to fail on the first retry of this type.\n\n:param int other:\n    How many times to retry on other errors.\n\n    Other errors are errors that are not connect, read, redirect or status errors.\n    These errors might be raised after the request was sent to the server, so the\n    request might have side-effects.\n\n    Set to ``0`` to fail on the first retry of this type.\n\n    If ``total`` is not set, it's a good idea to set this to 0 to account\n    for unexpected edge cases and avoid infinite retry loops.\n\n:param Collection allowed_methods:\n    Set of uppercased HTTP method verbs that we should retry on.\n\n    By default, we only retry on methods which are considered to be\n    idempotent (multiple requests with the same parameters end with the\n    same state). See :attr:`Retry.DEFAULT_ALLOWED_METHODS`.\n\n    Set to a ``None`` value to retry on any verb.\n\n:param Collection status_forcelist:\n    A set of integer HTTP status codes that we should force a retry on.\n    A retry is initiated if the request method is in ``allowed_methods``\n    and the response status code is in ``status_forcelist``.\n\n    By default, this is disabled with ``None``.\n\n:param float backoff_factor:\n    A backoff factor to apply between attempts after the second try\n    (most errors are resolved immediately by a second try without a\n    delay). urllib3 will sleep for::\n\n        {backoff factor} * (2 ** ({number of previous retries}))\n\n    seconds. If `backoff_jitter` is non-zero, this sleep is extended by::\n\n        random.uniform(0, {backoff jitter})\n\n    seconds. For example, if the backoff_factor is 0.1, then :func:`Retry.sleep` will\n    sleep for [0.0s, 0.2s, 0.4s, 0.8s, ...] between retries. No backoff will ever\n    be longer than `backoff_max`.\n\n    By default, backoff is disabled (factor set to 0).\n\n:param bool raise_on_redirect: Whether, if the number of redirects is\n    exhausted, to raise a MaxRetryError, or to return a response with a\n    response code in the 3xx range.\n\n:param bool raise_on_status: Similar meaning to ``raise_on_redirect``:\n    whether we should raise an exception, or return a response,\n    if status falls in ``status_forcelist`` range and retries have\n    been exhausted.\n\n:param tuple history: The history of the request encountered during\n    each call to :meth:`~Retry.increment`. The list is in the order\n    the requests occurred. Each list item is of class :class:`RequestHistory`.\n\n:param bool respect_retry_after_header:\n    Whether to respect Retry-After header on status codes defined as\n    :attr:`Retry.RETRY_AFTER_STATUS_CODES` or not.\n\n:param Collection remove_headers_on_redirect:\n    Sequence of headers to remove from the request when a response\n    indicating a redirect is returned before firing off the redirected\n    request.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, total: 'bool | int | None' = 10, connect: 'int | None' = None, read: 'int | None' = None, redirect: 'bool | int | None' = None, status: 'int | None' = None, other: 'int | None' = None, allowed_methods: 'typing.Collection[str] | None' = frozenset({'PUT', 'DELETE', 'TRACE', 'HEAD', 'GET', 'OPTIONS'}), status_forcelist: 'typing.Collection[int] | None' = None, backoff_factor: 'float' = 0, backoff_max: 'float' = 120, raise_on_redirect: 'bool' = True, raise_on_status: 'bool' = True, history: 'tuple[RequestHistory, ...] | None' = None, respect_retry_after_header: 'bool' = True, remove_headers_on_redirect: 'typing.Collection[str]' = frozenset({'Authorization', 'Cookie', 'Proxy-Authorization'}), backoff_jitter: 'float' = 0.0) -> 'None'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "_is_connection_error",
              "doc": "Errors when we're fairly sure that the server did not receive the\nrequest, so it should be safe to retry.",
              "signature": "(self, err: 'Exception') -> 'bool'"
            },
            {
              "name": "_is_method_retryable",
              "doc": "Checks if a given HTTP method should be retried upon, depending if\nit is included in the allowed_methods",
              "signature": "(self, method: 'str') -> 'bool'"
            },
            {
              "name": "_is_read_error",
              "doc": "Errors that occur after the request has been started, so we should\nassume that the server began processing it.",
              "signature": "(self, err: 'Exception') -> 'bool'"
            },
            {
              "name": "_sleep_backoff",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "get_backoff_time",
              "doc": "Formula for computing the current backoff\n\n:rtype: float",
              "signature": "(self) -> 'float'"
            },
            {
              "name": "get_retry_after",
              "doc": "Get the value of Retry-After in seconds.",
              "signature": "(self, response: 'BaseHTTPResponse') -> 'float | None'"
            },
            {
              "name": "increment",
              "doc": "Return a new Retry object with incremented retry counters.\n\n:param response: A response object, or None, if the server did not\n    return a response.\n:type response: :class:`~urllib3.response.BaseHTTPResponse`\n:param Exception error: An error encountered during the request, or\n    None if the response was received successfully.\n\n:return: A new ``Retry`` object.",
              "signature": "(self, method: 'str | None' = None, url: 'str | None' = None, response: 'BaseHTTPResponse | None' = None, error: 'Exception | None' = None, _pool: 'ConnectionPool | None' = None, _stacktrace: 'TracebackType | None' = None) -> 'Self'"
            },
            {
              "name": "is_exhausted",
              "doc": "Are we out of retries?",
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "is_retry",
              "doc": "Is this method/status code retryable? (Based on allowlists and control\nvariables such as the number of total retries to allow, whether to\nrespect the Retry-After header, whether this header is present, and\nwhether the returned status code is on the list of status codes to\nbe retried upon on the presence of the aforementioned header)",
              "signature": "(self, method: 'str', status_code: 'int', has_retry_after: 'bool' = False) -> 'bool'"
            },
            {
              "name": "new",
              "doc": null,
              "signature": "(self, **kw: 'typing.Any') -> 'Self'"
            },
            {
              "name": "parse_retry_after",
              "doc": null,
              "signature": "(self, retry_after: 'str') -> 'float'"
            },
            {
              "name": "sleep",
              "doc": "Sleep between retry attempts.\n\nThis method will respect a server's ``Retry-After`` response header\nand sleep the duration of the time requested. If that is not present, it\nwill use an exponential backoff. By default, the backoff factor is 0 and\nthis method will return immediately.",
              "signature": "(self, response: 'BaseHTTPResponse | None' = None) -> 'None'"
            },
            {
              "name": "sleep_for_retry",
              "doc": null,
              "signature": "(self, response: 'BaseHTTPResponse') -> 'bool'"
            }
          ]
        },
        {
          "name": "Timeout",
          "doc": "Timeout configuration.\n\nTimeouts can be defined as a default for a pool:\n\n.. code-block:: python\n\n    import urllib3\n\n    timeout = urllib3.util.Timeout(connect=2.0, read=7.0)\n\n    http = urllib3.PoolManager(timeout=timeout)\n\n    resp = http.request(\"GET\", \"https://example.com/\")\n\n    print(resp.status)\n\nOr per-request (which overrides the default for the pool):\n\n.. code-block:: python\n\n   response = http.request(\"GET\", \"https://example.com/\", timeout=Timeout(10))\n\nTimeouts can be disabled by setting all the parameters to ``None``:\n\n.. code-block:: python\n\n   no_timeout = Timeout(connect=None, read=None)\n   response = http.request(\"GET\", \"https://example.com/\", timeout=no_timeout)\n\n\n:param total:\n    This combines the connect and read timeouts into one; the read timeout\n    will be set to the time leftover from the connect attempt. In the\n    event that both a connect timeout and a total are specified, or a read\n    timeout and a total are specified, the shorter timeout will be applied.\n\n    Defaults to None.\n\n:type total: int, float, or None\n\n:param connect:\n    The maximum amount of time (in seconds) to wait for a connection\n    attempt to a server to succeed. Omitting the parameter will default the\n    connect timeout to the system default, probably `the global default\n    timeout in socket.py\n    <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.\n    None will set an infinite timeout for connection attempts.\n\n:type connect: int, float, or None\n\n:param read:\n    The maximum amount of time (in seconds) to wait between consecutive\n    read operations for a response from the server. Omitting the parameter\n    will default the read timeout to the system default, probably `the\n    global default timeout in socket.py\n    <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.\n    None will set an infinite timeout.\n\n:type read: int, float, or None\n\n.. note::\n\n    Many factors can affect the total amount of time for urllib3 to return\n    an HTTP response.\n\n    For example, Python's DNS resolver does not obey the timeout specified\n    on the socket. Other factors that can affect total request time include\n    high CPU load, high swap, the program running at a low priority level,\n    or other behaviors.\n\n    In addition, the read and total timeouts only measure the time between\n    read operations on the socket connecting the client and the server,\n    not the total amount of time for the request to return a complete\n    response. For most requests, the timeout is raised because the server\n    has not sent the first byte in the specified time. This is not always\n    the case; if a server streams one byte every fifteen seconds, a timeout\n    of 20 seconds will not trigger, even though the request will take\n    several minutes to complete.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, total: '_TYPE_TIMEOUT' = None, connect: '_TYPE_TIMEOUT' = <_TYPE_DEFAULT.token: -1>, read: '_TYPE_TIMEOUT' = <_TYPE_DEFAULT.token: -1>) -> 'None'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "clone",
              "doc": "Create a copy of the timeout object\n\nTimeout properties are stored per-pool but each request needs a fresh\nTimeout object to ensure each one has its own start/stop configured.\n\n:return: a copy of the timeout object\n:rtype: :class:`Timeout`",
              "signature": "(self) -> 'Timeout'"
            },
            {
              "name": "get_connect_duration",
              "doc": "Gets the time elapsed since the call to :meth:`start_connect`.\n\n:return: Elapsed time in seconds.\n:rtype: float\n:raises urllib3.exceptions.TimeoutStateError: if you attempt\n    to get duration for a timer that hasn't been started.",
              "signature": "(self) -> 'float'"
            },
            {
              "name": "resolve_default_timeout",
              "doc": null,
              "signature": "(timeout: '_TYPE_TIMEOUT') -> 'float | None'"
            },
            {
              "name": "start_connect",
              "doc": "Start the timeout clock, used during a connect() attempt\n\n:raises urllib3.exceptions.TimeoutStateError: if you attempt\n    to start a timer that has been started already.",
              "signature": "(self) -> 'float'"
            }
          ]
        }
      ]
    }
  },
  {
    "package": "sniffio",
    "base": {
      "functions": [
        {
          "name": "current_async_library",
          "doc": "Detect which async library is currently running.\n\nThe following libraries are currently supported:\n\n================   ===========  ============================\nLibrary             Requires     Magic string\n================   ===========  ============================\n**Trio**            Trio v0.6+   ``\"trio\"``\n**Curio**           -            ``\"curio\"``\n**asyncio**                      ``\"asyncio\"``\n**Trio-asyncio**    v0.8.2+     ``\"trio\"`` or ``\"asyncio\"``,\n                                depending on current mode\n================   ===========  ============================\n\nReturns:\n  A string like ``\"trio\"``.\n\nRaises:\n  AsyncLibraryNotFoundError: if called from synchronous context,\n    or if the current async library was not recognized.\n\nExamples:\n\n    .. code-block:: python3\n\n       from sniffio import current_async_library\n\n       async def generic_sleep(seconds):\n           library = current_async_library()\n           if library == \"trio\":\n               import trio\n               await trio.sleep(seconds)\n           elif library == \"asyncio\":\n               import asyncio\n               await asyncio.sleep(seconds)\n           # ... and so on ...\n           else:\n               raise RuntimeError(f\"Unsupported library {library!r}\")",
          "signature": "() -> str"
        }
      ],
      "classes": [
        {
          "name": "AsyncLibraryNotFoundError",
          "doc": "Unspecified run-time error.",
          "functions": []
        }
      ]
    }
  },
  {
    "package": "arrow",
    "base": {
      "functions": [
        {
          "name": "get",
          "doc": "Returns an :class:`Arrow <arrow.arrow.Arrow>` object based on flexible inputs.\n\n:param locale: (optional) a ``str`` specifying a locale for the parser. Defaults to 'en-us'.\n:param tzinfo: (optional) a :ref:`timezone expression <tz-expr>` or tzinfo object.\n    Replaces the timezone unless using an input form that is explicitly UTC or specifies\n    the timezone in a positional argument. Defaults to UTC.\n:param normalize_whitespace: (optional) a ``bool`` specifying whether or not to normalize\n    redundant whitespace (spaces, tabs, and newlines) in a datetime string before parsing.\n    Defaults to false.\n\nUsage::\n\n    >>> import arrow\n\n**No inputs** to get current UTC time::\n\n    >>> arrow.get()\n    <Arrow [2013-05-08T05:51:43.316458+00:00]>\n\n**One** :class:`Arrow <arrow.arrow.Arrow>` object, to get a copy.\n\n    >>> arw = arrow.utcnow()\n    >>> arrow.get(arw)\n    <Arrow [2013-10-23T15:21:54.354846+00:00]>\n\n**One** ``float`` or ``int``, convertible to a floating-point timestamp, to get\nthat timestamp in UTC::\n\n    >>> arrow.get(1367992474.293378)\n    <Arrow [2013-05-08T05:54:34.293378+00:00]>\n\n    >>> arrow.get(1367992474)\n    <Arrow [2013-05-08T05:54:34+00:00]>\n\n**One** ISO 8601-formatted ``str``, to parse it::\n\n    >>> arrow.get('2013-09-29T01:26:43.830580')\n    <Arrow [2013-09-29T01:26:43.830580+00:00]>\n\n**One** ISO 8601-formatted ``str``, in basic format, to parse it::\n\n    >>> arrow.get('20160413T133656.456289')\n    <Arrow [2016-04-13T13:36:56.456289+00:00]>\n\n**One** ``tzinfo``, to get the current time **converted** to that timezone::\n\n    >>> arrow.get(tz.tzlocal())\n    <Arrow [2013-05-07T22:57:28.484717-07:00]>\n\n**One** naive ``datetime``, to get that datetime in UTC::\n\n    >>> arrow.get(datetime(2013, 5, 5))\n    <Arrow [2013-05-05T00:00:00+00:00]>\n\n**One** aware ``datetime``, to get that datetime::\n\n    >>> arrow.get(datetime(2013, 5, 5, tzinfo=tz.tzlocal()))\n    <Arrow [2013-05-05T00:00:00-07:00]>\n\n**One** naive ``date``, to get that date in UTC::\n\n    >>> arrow.get(date(2013, 5, 5))\n    <Arrow [2013-05-05T00:00:00+00:00]>\n\n**One** time.struct time::\n\n    >>> arrow.get(gmtime(0))\n    <Arrow [1970-01-01T00:00:00+00:00]>\n\n**One** iso calendar ``tuple``, to get that week date in UTC::\n\n    >>> arrow.get((2013, 18, 7))\n    <Arrow [2013-05-05T00:00:00+00:00]>\n\n**Two** arguments, a naive or aware ``datetime``, and a replacement\n:ref:`timezone expression <tz-expr>`::\n\n    >>> arrow.get(datetime(2013, 5, 5), 'US/Pacific')\n    <Arrow [2013-05-05T00:00:00-07:00]>\n\n**Two** arguments, a naive ``date``, and a replacement\n:ref:`timezone expression <tz-expr>`::\n\n    >>> arrow.get(date(2013, 5, 5), 'US/Pacific')\n    <Arrow [2013-05-05T00:00:00-07:00]>\n\n**Two** arguments, both ``str``, to parse the first according to the format of the second::\n\n    >>> arrow.get('2013-05-05 12:30:45 America/Chicago', 'YYYY-MM-DD HH:mm:ss ZZZ')\n    <Arrow [2013-05-05T12:30:45-05:00]>\n\n**Two** arguments, first a ``str`` to parse and second a ``list`` of formats to try::\n\n    >>> arrow.get('2013-05-05 12:30:45', ['MM/DD/YYYY', 'YYYY-MM-DD HH:mm:ss'])\n    <Arrow [2013-05-05T12:30:45+00:00]>\n\n**Three or more** arguments, as for the direct constructor of an ``Arrow`` object::\n\n    >>> arrow.get(2013, 5, 5, 12, 30, 45)\n    <Arrow [2013-05-05T12:30:45+00:00]>",
          "signature": "(*args: Any, **kwargs: Any) -> arrow.arrow.Arrow"
        },
        {
          "name": "now",
          "doc": "Returns an :class:`Arrow <arrow.arrow.Arrow>` object, representing \"now\" in the given\ntimezone.\n\n:param tz: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to local time.\n\nUsage::\n\n    >>> import arrow\n    >>> arrow.now()\n    <Arrow [2013-05-07T22:19:11.363410-07:00]>\n\n    >>> arrow.now('US/Pacific')\n    <Arrow [2013-05-07T22:19:15.251821-07:00]>\n\n    >>> arrow.now('+02:00')\n    <Arrow [2013-05-08T07:19:25.618646+02:00]>\n\n    >>> arrow.now('local')\n    <Arrow [2013-05-07T22:19:39.130059-07:00]>",
          "signature": "(tz: Union[datetime.tzinfo, str, NoneType] = None) -> arrow.arrow.Arrow"
        },
        {
          "name": "utcnow",
          "doc": "Returns an :class:`Arrow <arrow.arrow.Arrow>` object, representing \"now\" in UTC time.\n\nUsage::\n\n    >>> import arrow\n    >>> arrow.utcnow()\n    <Arrow [2013-05-08T05:19:07.018993+00:00]>",
          "signature": "() -> arrow.arrow.Arrow"
        }
      ],
      "classes": [
        {
          "name": "Arrow",
          "doc": "An :class:`Arrow <arrow.arrow.Arrow>` object.\n\nImplements the ``datetime`` interface, behaving as an aware ``datetime`` while implementing\nadditional functionality.\n\n:param year: the calendar year.\n:param month: the calendar month.\n:param day: the calendar day.\n:param hour: (optional) the hour. Defaults to 0.\n:param minute: (optional) the minute, Defaults to 0.\n:param second: (optional) the second, Defaults to 0.\n:param microsecond: (optional) the microsecond. Defaults to 0.\n:param tzinfo: (optional) A timezone expression.  Defaults to UTC.\n:param fold: (optional) 0 or 1, used to disambiguate repeated wall times. Defaults to 0.\n\n.. _tz-expr:\n\nRecognized timezone expressions:\n\n    - A ``tzinfo`` object.\n    - A ``str`` describing a timezone, similar to 'US/Pacific', or 'Europe/Berlin'.\n    - A ``str`` in ISO 8601 style, as in '+07:00'.\n    - A ``str``, one of the following:  'local', 'utc', 'UTC'.\n\nUsage::\n\n    >>> import arrow\n    >>> arrow.Arrow(2013, 5, 5, 12, 30, 45)\n    <Arrow [2013-05-05T12:30:45+00:00]>",
          "functions": [
            {
              "name": "__add__",
              "doc": null,
              "signature": "(self, other: Any) -> 'Arrow'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: Any) -> bool"
            },
            {
              "name": "__format__",
              "doc": "Default object formatter.",
              "signature": "(self, formatstr: str) -> str"
            },
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self, other: Any) -> bool"
            },
            {
              "name": "__getattr__",
              "doc": null,
              "signature": "(self, name: str) -> int"
            },
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self, other: Any) -> bool"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self) -> int"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, year: int, month: int, day: int, hour: int = 0, minute: int = 0, second: int = 0, microsecond: int = 0, tzinfo: Union[datetime.tzinfo, str, NoneType] = None, **kwargs: Any) -> None"
            },
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self, other: Any) -> bool"
            },
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self, other: Any) -> bool"
            },
            {
              "name": "__ne__",
              "doc": "Return self!=value.",
              "signature": "(self, other: Any) -> bool"
            },
            {
              "name": "__radd__",
              "doc": null,
              "signature": "(self, other: Union[datetime.timedelta, dateutil.relativedelta.relativedelta]) -> 'Arrow'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "__rsub__",
              "doc": null,
              "signature": "(self, other: Any) -> datetime.timedelta"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "__sub__",
              "doc": null,
              "signature": "(self, other: Any) -> Union[datetime.timedelta, ForwardRef('Arrow')]"
            },
            {
              "name": "_get_tzinfo",
              "doc": "Get normalized tzinfo object from various inputs.",
              "signature": "(tz_expr: Union[datetime.tzinfo, str, NoneType]) -> datetime.tzinfo"
            },
            {
              "name": "_is_last_day_of_month",
              "doc": "Returns a boolean indicating whether the datetime is the last day of the month.",
              "signature": "(date: 'Arrow') -> bool"
            },
            {
              "name": "astimezone",
              "doc": "Returns a ``datetime`` object, converted to the specified timezone.\n\n:param tz: a ``tzinfo`` object.\n\nUsage::\n\n    >>> pacific=arrow.now('US/Pacific')\n    >>> nyc=arrow.now('America/New_York').tzinfo\n    >>> pacific.astimezone(nyc)\n    datetime.datetime(2019, 1, 20, 10, 24, 22, 328172, tzinfo=tzfile('/usr/share/zoneinfo/America/New_York'))",
              "signature": "(self, tz: Optional[datetime.tzinfo]) -> datetime.datetime"
            },
            {
              "name": "ceil",
              "doc": "Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, representing the \"ceiling\"\nof the timespan of the :class:`Arrow <arrow.arrow.Arrow>` object in a given timeframe.\nEquivalent to the second element in the 2-tuple returned by\n:func:`span <arrow.arrow.Arrow.span>`.\n\n:param frame: the timeframe.  Can be any ``datetime`` property (day, hour, minute...).\n\nUsage::\n\n    >>> arrow.utcnow().ceil('hour')\n    <Arrow [2013-05-09T03:59:59.999999+00:00]>",
              "signature": "(self, frame: Literal['year', 'years', 'month', 'months', 'day', 'days', 'hour', 'hours', 'minute', 'minutes', 'second', 'seconds', 'microsecond', 'microseconds', 'week', 'weeks', 'quarter', 'quarters']) -> 'Arrow'"
            },
            {
              "name": "clone",
              "doc": "Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, cloned from the current one.\n\nUsage:\n\n    >>> arw = arrow.utcnow()\n    >>> cloned = arw.clone()",
              "signature": "(self) -> 'Arrow'"
            },
            {
              "name": "ctime",
              "doc": "Returns a ctime formatted representation of the date and time.\n\nUsage::\n\n    >>> arrow.utcnow().ctime()\n    'Sat Jan 19 18:26:50 2019'",
              "signature": "(self) -> str"
            },
            {
              "name": "date",
              "doc": "Returns a ``date`` object with the same year, month and day.\n\nUsage::\n\n    >>> arrow.utcnow().date()\n    datetime.date(2019, 1, 23)",
              "signature": "(self) -> datetime.date"
            },
            {
              "name": "dehumanize",
              "doc": "Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, that represents\nthe time difference relative to the attributes of the\n:class:`Arrow <arrow.arrow.Arrow>` object.\n\n:param timestring: a ``str`` representing a humanized relative time.\n:param locale: (optional) a ``str`` specifying a locale.  Defaults to 'en-us'.\n\nUsage::\n\n        >>> arw = arrow.utcnow()\n        >>> arw\n        <Arrow [2021-04-20T22:27:34.787885+00:00]>\n        >>> earlier = arw.dehumanize(\"2 days ago\")\n        >>> earlier\n        <Arrow [2021-04-18T22:27:34.787885+00:00]>\n\n        >>> arw = arrow.utcnow()\n        >>> arw\n        <Arrow [2021-04-20T22:27:34.787885+00:00]>\n        >>> later = arw.dehumanize(\"in a month\")\n        >>> later\n        <Arrow [2021-05-18T22:27:34.787885+00:00]>",
              "signature": "(self, input_string: str, locale: str = 'en_us') -> 'Arrow'"
            },
            {
              "name": "dst",
              "doc": "Returns the daylight savings time adjustment.\n\nUsage::\n\n    >>> arrow.utcnow().dst()\n    datetime.timedelta(0)",
              "signature": "(self) -> Optional[datetime.timedelta]"
            },
            {
              "name": "floor",
              "doc": "Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, representing the \"floor\"\nof the timespan of the :class:`Arrow <arrow.arrow.Arrow>` object in a given timeframe.\nEquivalent to the first element in the 2-tuple returned by\n:func:`span <arrow.arrow.Arrow.span>`.\n\n:param frame: the timeframe.  Can be any ``datetime`` property (day, hour, minute...).\n\nUsage::\n\n    >>> arrow.utcnow().floor('hour')\n    <Arrow [2013-05-09T03:00:00+00:00]>",
              "signature": "(self, frame: Literal['year', 'years', 'month', 'months', 'day', 'days', 'hour', 'hours', 'minute', 'minutes', 'second', 'seconds', 'microsecond', 'microseconds', 'week', 'weeks', 'quarter', 'quarters']) -> 'Arrow'"
            },
            {
              "name": "for_json",
              "doc": "Serializes for the ``for_json`` protocol of simplejson.\n\nUsage::\n\n    >>> arrow.utcnow().for_json()\n    '2019-01-19T18:25:36.760079+00:00'",
              "signature": "(self) -> str"
            },
            {
              "name": "format",
              "doc": "Returns a string representation of the :class:`Arrow <arrow.arrow.Arrow>` object,\nformatted according to the provided format string.\n\n:param fmt: the format string.\n:param locale: the locale to format.\n\nUsage::\n\n    >>> arrow.utcnow().format('YYYY-MM-DD HH:mm:ss ZZ')\n    '2013-05-09 03:56:47 -00:00'\n\n    >>> arrow.utcnow().format('X')\n    '1368071882'\n\n    >>> arrow.utcnow().format('MMMM DD, YYYY')\n    'May 09, 2013'\n\n    >>> arrow.utcnow().format()\n    '2013-05-09 03:56:47 -00:00'",
              "signature": "(self, fmt: str = 'YYYY-MM-DD HH:mm:ssZZ', locale: str = 'en-us') -> str"
            },
            {
              "name": "humanize",
              "doc": "Returns a localized, humanized representation of a relative difference in time.\n\n:param other: (optional) an :class:`Arrow <arrow.arrow.Arrow>` or ``datetime`` object.\n    Defaults to now in the current :class:`Arrow <arrow.arrow.Arrow>` object's timezone.\n:param locale: (optional) a ``str`` specifying a locale.  Defaults to 'en-us'.\n:param only_distance: (optional) returns only time difference eg: \"11 seconds\" without \"in\" or \"ago\" part.\n:param granularity: (optional) defines the precision of the output. Set it to strings 'second', 'minute',\n                   'hour', 'day', 'week', 'month' or 'year' or a list of any combination of these strings\n\nUsage::\n\n    >>> earlier = arrow.utcnow().shift(hours=-2)\n    >>> earlier.humanize()\n    '2 hours ago'\n\n    >>> later = earlier.shift(hours=4)\n    >>> later.humanize(earlier)\n    'in 4 hours'",
              "signature": "(self, other: Union[ForwardRef('Arrow'), datetime.datetime, NoneType] = None, locale: str = 'en-us', only_distance: bool = False, granularity: Union[Literal['auto', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'], List[Literal['auto', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year']]] = 'auto') -> str"
            },
            {
              "name": "is_between",
              "doc": "Returns a boolean denoting whether the :class:`Arrow <arrow.arrow.Arrow>` object is between\nthe start and end limits.\n\n:param start: an :class:`Arrow <arrow.arrow.Arrow>` object.\n:param end: an :class:`Arrow <arrow.arrow.Arrow>` object.\n:param bounds: (optional) a ``str`` of either '()', '(]', '[)', or '[]' that specifies\n    whether to include or exclude the start and end values in the range. '(' excludes\n    the start, '[' includes the start, ')' excludes the end, and ']' includes the end.\n    If the bounds are not specified, the default bound '()' is used.\n\nUsage::\n\n    >>> start = arrow.get(datetime(2013, 5, 5, 12, 30, 10))\n    >>> end = arrow.get(datetime(2013, 5, 5, 12, 30, 36))\n    >>> arrow.get(datetime(2013, 5, 5, 12, 30, 27)).is_between(start, end)\n    True\n\n    >>> start = arrow.get(datetime(2013, 5, 5))\n    >>> end = arrow.get(datetime(2013, 5, 8))\n    >>> arrow.get(datetime(2013, 5, 8)).is_between(start, end, '[]')\n    True\n\n    >>> start = arrow.get(datetime(2013, 5, 5))\n    >>> end = arrow.get(datetime(2013, 5, 8))\n    >>> arrow.get(datetime(2013, 5, 8)).is_between(start, end, '[)')\n    False",
              "signature": "(self, start: 'Arrow', end: 'Arrow', bounds: Literal['[)', '()', '(]', '[]'] = '()') -> bool"
            },
            {
              "name": "isocalendar",
              "doc": "Returns a 3-tuple, (ISO year, ISO week number, ISO weekday).\n\nUsage::\n\n    >>> arrow.utcnow().isocalendar()\n    (2019, 3, 6)",
              "signature": "(self) -> Tuple[int, int, int]"
            },
            {
              "name": "isoformat",
              "doc": "Returns an ISO 8601 formatted representation of the date and time.\n\nUsage::\n\n    >>> arrow.utcnow().isoformat()\n    '2019-01-19T18:30:52.442118+00:00'",
              "signature": "(self, sep: str = 'T', timespec: str = 'auto') -> str"
            },
            {
              "name": "isoweekday",
              "doc": "Returns the ISO day of the week as an integer (1-7).\n\nUsage::\n\n    >>> arrow.utcnow().isoweekday()\n    6",
              "signature": "(self) -> int"
            },
            {
              "name": "replace",
              "doc": "Returns a new :class:`Arrow <arrow.arrow.Arrow>` object with attributes updated\naccording to inputs.\n\nUse property names to set their value absolutely::\n\n    >>> import arrow\n    >>> arw = arrow.utcnow()\n    >>> arw\n    <Arrow [2013-05-11T22:27:34.787885+00:00]>\n    >>> arw.replace(year=2014, month=6)\n    <Arrow [2014-06-11T22:27:34.787885+00:00]>\n\nYou can also replace the timezone without conversion, using a\n:ref:`timezone expression <tz-expr>`::\n\n    >>> arw.replace(tzinfo=tz.tzlocal())\n    <Arrow [2013-05-11T22:27:34.787885-07:00]>",
              "signature": "(self, **kwargs: Any) -> 'Arrow'"
            },
            {
              "name": "shift",
              "doc": "Returns a new :class:`Arrow <arrow.arrow.Arrow>` object with attributes updated\naccording to inputs.\n\nUse pluralized property names to relatively shift their current value:\n\n>>> import arrow\n>>> arw = arrow.utcnow()\n>>> arw\n<Arrow [2013-05-11T22:27:34.787885+00:00]>\n>>> arw.shift(years=1, months=-1)\n<Arrow [2014-04-11T22:27:34.787885+00:00]>\n\nDay-of-the-week relative shifting can use either Python's weekday numbers\n(Monday = 0, Tuesday = 1 .. Sunday = 6) or using dateutil.relativedelta's\nday instances (MO, TU .. SU).  When using weekday numbers, the returned\ndate will always be greater than or equal to the starting date.\n\nUsing the above code (which is a Saturday) and asking it to shift to Saturday:\n\n>>> arw.shift(weekday=5)\n<Arrow [2013-05-11T22:27:34.787885+00:00]>\n\nWhile asking for a Monday:\n\n>>> arw.shift(weekday=0)\n<Arrow [2013-05-13T22:27:34.787885+00:00]>",
              "signature": "(self, **kwargs: Any) -> 'Arrow'"
            },
            {
              "name": "span",
              "doc": "Returns a tuple of two new :class:`Arrow <arrow.arrow.Arrow>` objects, representing the timespan\nof the :class:`Arrow <arrow.arrow.Arrow>` object in a given timeframe.\n\n:param frame: the timeframe.  Can be any ``datetime`` property (day, hour, minute...).\n:param count: (optional) the number of frames to span.\n:param bounds: (optional) a ``str`` of either '()', '(]', '[)', or '[]' that specifies\n    whether to include or exclude the start and end values in the span. '(' excludes\n    the start, '[' includes the start, ')' excludes the end, and ']' includes the end.\n    If the bounds are not specified, the default bound '[)' is used.\n:param exact: (optional) whether to have the start of the timespan begin exactly\n    at the time specified by ``start`` and the end of the timespan truncated\n    so as not to extend beyond ``end``.\n:param week_start: (optional) only used in combination with the week timeframe. Follows isoweekday() where\n    Monday is 1 and Sunday is 7.\n\nSupported frame values: year, quarter, month, week, day, hour, minute, second.\n\nUsage::\n\n    >>> arrow.utcnow()\n    <Arrow [2013-05-09T03:32:36.186203+00:00]>\n\n    >>> arrow.utcnow().span('hour')\n    (<Arrow [2013-05-09T03:00:00+00:00]>, <Arrow [2013-05-09T03:59:59.999999+00:00]>)\n\n    >>> arrow.utcnow().span('day')\n    (<Arrow [2013-05-09T00:00:00+00:00]>, <Arrow [2013-05-09T23:59:59.999999+00:00]>)\n\n    >>> arrow.utcnow().span('day', count=2)\n    (<Arrow [2013-05-09T00:00:00+00:00]>, <Arrow [2013-05-10T23:59:59.999999+00:00]>)\n\n    >>> arrow.utcnow().span('day', bounds='[]')\n    (<Arrow [2013-05-09T00:00:00+00:00]>, <Arrow [2013-05-10T00:00:00+00:00]>)\n\n    >>> arrow.utcnow().span('week')\n    (<Arrow [2021-02-22T00:00:00+00:00]>, <Arrow [2021-02-28T23:59:59.999999+00:00]>)\n\n    >>> arrow.utcnow().span('week', week_start=6)\n    (<Arrow [2021-02-20T00:00:00+00:00]>, <Arrow [2021-02-26T23:59:59.999999+00:00]>)",
              "signature": "(self, frame: Literal['year', 'years', 'month', 'months', 'day', 'days', 'hour', 'hours', 'minute', 'minutes', 'second', 'seconds', 'microsecond', 'microseconds', 'week', 'weeks', 'quarter', 'quarters'], count: int = 1, bounds: Literal['[)', '()', '(]', '[]'] = '[)', exact: bool = False, week_start: int = 1) -> Tuple[ForwardRef('Arrow'), ForwardRef('Arrow')]"
            },
            {
              "name": "strftime",
              "doc": "Formats in the style of ``datetime.strftime``.\n\n:param format: the format string.\n\nUsage::\n\n    >>> arrow.utcnow().strftime('%d-%m-%Y %H:%M:%S')\n    '23-01-2019 12:28:17'",
              "signature": "(self, format: str) -> str"
            },
            {
              "name": "time",
              "doc": "Returns a ``time`` object with the same hour, minute, second, microsecond.\n\nUsage::\n\n    >>> arrow.utcnow().time()\n    datetime.time(12, 15, 34, 68352)",
              "signature": "(self) -> datetime.time"
            },
            {
              "name": "timestamp",
              "doc": "Returns a timestamp representation of the :class:`Arrow <arrow.arrow.Arrow>` object, in\nUTC time.\n\nUsage::\n\n    >>> arrow.utcnow().timestamp()\n    1616882340.256501",
              "signature": "(self) -> float"
            },
            {
              "name": "timetuple",
              "doc": "Returns a ``time.struct_time``, in the current timezone.\n\nUsage::\n\n    >>> arrow.utcnow().timetuple()\n    time.struct_time(tm_year=2019, tm_mon=1, tm_mday=20, tm_hour=15, tm_min=17, tm_sec=8, tm_wday=6, tm_yday=20, tm_isdst=0)",
              "signature": "(self) -> time.struct_time"
            },
            {
              "name": "timetz",
              "doc": "Returns a ``time`` object with the same hour, minute, second, microsecond and\ntzinfo.\n\nUsage::\n\n    >>> arrow.utcnow().timetz()\n    datetime.time(12, 5, 18, 298893, tzinfo=tzutc())",
              "signature": "(self) -> datetime.time"
            },
            {
              "name": "to",
              "doc": "Returns a new :class:`Arrow <arrow.arrow.Arrow>` object, converted\nto the target timezone.\n\n:param tz: A :ref:`timezone expression <tz-expr>`.\n\nUsage::\n\n    >>> utc = arrow.utcnow()\n    >>> utc\n    <Arrow [2013-05-09T03:49:12.311072+00:00]>\n\n    >>> utc.to('US/Pacific')\n    <Arrow [2013-05-08T20:49:12.311072-07:00]>\n\n    >>> utc.to(tz.tzlocal())\n    <Arrow [2013-05-08T20:49:12.311072-07:00]>\n\n    >>> utc.to('-07:00')\n    <Arrow [2013-05-08T20:49:12.311072-07:00]>\n\n    >>> utc.to('local')\n    <Arrow [2013-05-08T20:49:12.311072-07:00]>\n\n    >>> utc.to('local').to('utc')\n    <Arrow [2013-05-09T03:49:12.311072+00:00]>",
              "signature": "(self, tz: Union[datetime.tzinfo, str]) -> 'Arrow'"
            },
            {
              "name": "toordinal",
              "doc": "Returns the proleptic Gregorian ordinal of the date.\n\nUsage::\n\n    >>> arrow.utcnow().toordinal()\n    737078",
              "signature": "(self) -> int"
            },
            {
              "name": "utcoffset",
              "doc": "Returns a ``timedelta`` object representing the whole number of minutes difference from\nUTC time.\n\nUsage::\n\n    >>> arrow.now('US/Pacific').utcoffset()\n    datetime.timedelta(-1, 57600)",
              "signature": "(self) -> Optional[datetime.timedelta]"
            },
            {
              "name": "utctimetuple",
              "doc": "Returns a ``time.struct_time``, in UTC time.\n\nUsage::\n\n    >>> arrow.utcnow().utctimetuple()\n    time.struct_time(tm_year=2019, tm_mon=1, tm_mday=19, tm_hour=21, tm_min=41, tm_sec=7, tm_wday=5, tm_yday=19, tm_isdst=0)",
              "signature": "(self) -> time.struct_time"
            },
            {
              "name": "weekday",
              "doc": "Returns the day of the week as an integer (0-6).\n\nUsage::\n\n    >>> arrow.utcnow().weekday()\n    5",
              "signature": "(self) -> int"
            }
          ]
        },
        {
          "name": "ArrowFactory",
          "doc": "A factory for generating :class:`Arrow <arrow.arrow.Arrow>` objects.\n\n:param type: (optional) the :class:`Arrow <arrow.arrow.Arrow>`-based class to construct from.\n    Defaults to :class:`Arrow <arrow.arrow.Arrow>`.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, type: Type[arrow.arrow.Arrow] = <class 'arrow.arrow.Arrow'>) -> None"
            },
            {
              "name": "get",
              "doc": "Returns an :class:`Arrow <arrow.arrow.Arrow>` object based on flexible inputs.\n\n:param locale: (optional) a ``str`` specifying a locale for the parser. Defaults to 'en-us'.\n:param tzinfo: (optional) a :ref:`timezone expression <tz-expr>` or tzinfo object.\n    Replaces the timezone unless using an input form that is explicitly UTC or specifies\n    the timezone in a positional argument. Defaults to UTC.\n:param normalize_whitespace: (optional) a ``bool`` specifying whether or not to normalize\n    redundant whitespace (spaces, tabs, and newlines) in a datetime string before parsing.\n    Defaults to false.\n\nUsage::\n\n    >>> import arrow\n\n**No inputs** to get current UTC time::\n\n    >>> arrow.get()\n    <Arrow [2013-05-08T05:51:43.316458+00:00]>\n\n**One** :class:`Arrow <arrow.arrow.Arrow>` object, to get a copy.\n\n    >>> arw = arrow.utcnow()\n    >>> arrow.get(arw)\n    <Arrow [2013-10-23T15:21:54.354846+00:00]>\n\n**One** ``float`` or ``int``, convertible to a floating-point timestamp, to get\nthat timestamp in UTC::\n\n    >>> arrow.get(1367992474.293378)\n    <Arrow [2013-05-08T05:54:34.293378+00:00]>\n\n    >>> arrow.get(1367992474)\n    <Arrow [2013-05-08T05:54:34+00:00]>\n\n**One** ISO 8601-formatted ``str``, to parse it::\n\n    >>> arrow.get('2013-09-29T01:26:43.830580')\n    <Arrow [2013-09-29T01:26:43.830580+00:00]>\n\n**One** ISO 8601-formatted ``str``, in basic format, to parse it::\n\n    >>> arrow.get('20160413T133656.456289')\n    <Arrow [2016-04-13T13:36:56.456289+00:00]>\n\n**One** ``tzinfo``, to get the current time **converted** to that timezone::\n\n    >>> arrow.get(tz.tzlocal())\n    <Arrow [2013-05-07T22:57:28.484717-07:00]>\n\n**One** naive ``datetime``, to get that datetime in UTC::\n\n    >>> arrow.get(datetime(2013, 5, 5))\n    <Arrow [2013-05-05T00:00:00+00:00]>\n\n**One** aware ``datetime``, to get that datetime::\n\n    >>> arrow.get(datetime(2013, 5, 5, tzinfo=tz.tzlocal()))\n    <Arrow [2013-05-05T00:00:00-07:00]>\n\n**One** naive ``date``, to get that date in UTC::\n\n    >>> arrow.get(date(2013, 5, 5))\n    <Arrow [2013-05-05T00:00:00+00:00]>\n\n**One** time.struct time::\n\n    >>> arrow.get(gmtime(0))\n    <Arrow [1970-01-01T00:00:00+00:00]>\n\n**One** iso calendar ``tuple``, to get that week date in UTC::\n\n    >>> arrow.get((2013, 18, 7))\n    <Arrow [2013-05-05T00:00:00+00:00]>\n\n**Two** arguments, a naive or aware ``datetime``, and a replacement\n:ref:`timezone expression <tz-expr>`::\n\n    >>> arrow.get(datetime(2013, 5, 5), 'US/Pacific')\n    <Arrow [2013-05-05T00:00:00-07:00]>\n\n**Two** arguments, a naive ``date``, and a replacement\n:ref:`timezone expression <tz-expr>`::\n\n    >>> arrow.get(date(2013, 5, 5), 'US/Pacific')\n    <Arrow [2013-05-05T00:00:00-07:00]>\n\n**Two** arguments, both ``str``, to parse the first according to the format of the second::\n\n    >>> arrow.get('2013-05-05 12:30:45 America/Chicago', 'YYYY-MM-DD HH:mm:ss ZZZ')\n    <Arrow [2013-05-05T12:30:45-05:00]>\n\n**Two** arguments, first a ``str`` to parse and second a ``list`` of formats to try::\n\n    >>> arrow.get('2013-05-05 12:30:45', ['MM/DD/YYYY', 'YYYY-MM-DD HH:mm:ss'])\n    <Arrow [2013-05-05T12:30:45+00:00]>\n\n**Three or more** arguments, as for the direct constructor of an ``Arrow`` object::\n\n    >>> arrow.get(2013, 5, 5, 12, 30, 45)\n    <Arrow [2013-05-05T12:30:45+00:00]>",
              "signature": "(self, *args: Any, **kwargs: Any) -> arrow.arrow.Arrow"
            },
            {
              "name": "now",
              "doc": "Returns an :class:`Arrow <arrow.arrow.Arrow>` object, representing \"now\" in the given\ntimezone.\n\n:param tz: (optional) A :ref:`timezone expression <tz-expr>`.  Defaults to local time.\n\nUsage::\n\n    >>> import arrow\n    >>> arrow.now()\n    <Arrow [2013-05-07T22:19:11.363410-07:00]>\n\n    >>> arrow.now('US/Pacific')\n    <Arrow [2013-05-07T22:19:15.251821-07:00]>\n\n    >>> arrow.now('+02:00')\n    <Arrow [2013-05-08T07:19:25.618646+02:00]>\n\n    >>> arrow.now('local')\n    <Arrow [2013-05-07T22:19:39.130059-07:00]>",
              "signature": "(self, tz: Union[datetime.tzinfo, str, NoneType] = None) -> arrow.arrow.Arrow"
            },
            {
              "name": "utcnow",
              "doc": "Returns an :class:`Arrow <arrow.arrow.Arrow>` object, representing \"now\" in UTC time.\n\nUsage::\n\n    >>> import arrow\n    >>> arrow.utcnow()\n    <Arrow [2013-05-08T05:19:07.018993+00:00]>",
              "signature": "(self) -> arrow.arrow.Arrow"
            }
          ]
        },
        {
          "name": "ParserError",
          "doc": "Inappropriate argument value (of correct type).",
          "functions": []
        }
      ]
    }
  },
  {
    "package": "text_unidecode",
    "base": {
      "functions": [
        {
          "name": "unidecode",
          "doc": null,
          "signature": "(txt)"
        }
      ],
      "classes": []
    }
  },
  {
    "package": "fastapi",
    "base": {
      "functions": [
        {
          "name": "Body",
          "doc": null,
          "signature": "(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')] = PydanticUndefined, *, default_factory: Annotated[Optional[Callable[[], Any]], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")] = PydanticUndefined, embed: Annotated[Optional[bool], Doc('\\n            When `embed` is `True`, the parameter will be expected in a JSON body as a\\n            key instead of being the JSON body itself.\\n\\n            This happens automatically when more than one `Body` parameter is declared.\\n\\n            Read more about it in the\\n            [FastAPI docs for Body - Multiple Parameters](https://fastapi.tiangolo.com/tutorial/body-multiple-params/#embed-a-single-body-parameter).\\n            ')] = None, media_type: typing.Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")] = 'application/json', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")] = None, alias_priority: Annotated[Optional[int], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')] = PydanticUndefined, validation_alias: Annotated[Optional[str], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")] = None, serialization_alias: Annotated[Optional[str], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")] = None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')] = None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')] = None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')] = None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')] = None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')] = None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')] = None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')] = None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')] = None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')] = None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EB410>] = None, discriminator: Annotated[Optional[str], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')] = None, strict: Annotated[Optional[bool], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')] = PydanticUndefined, multiple_of: Annotated[Optional[float], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')] = PydanticUndefined, allow_inf_nan: Annotated[Optional[bool], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')] = PydanticUndefined, max_digits: Annotated[Optional[int], Doc('\\n            Maximum number of allow digits for strings.\\n            ')] = PydanticUndefined, decimal_places: Annotated[Optional[int], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')] = PydanticUndefined, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')] = None, example: Annotated[Optional[Any], <typing_extensions.deprecated object at 0x0000023E9A1EB450>] = PydanticUndefined, openapi_examples: Annotated[Optional[Dict[str, fastapi.openapi.models.Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")] = None, deprecated: Annotated[Union[typing_extensions.deprecated, str, bool, NoneType], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')] = None, include_in_schema: typing.Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")] = True, json_schema_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n            Any additional JSON schema data.\\n            ')] = None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EB590>]) -> Any"
        },
        {
          "name": "Cookie",
          "doc": null,
          "signature": "(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')] = PydanticUndefined, *, default_factory: Annotated[Optional[Callable[[], Any]], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")] = PydanticUndefined, alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")] = None, alias_priority: Annotated[Optional[int], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')] = PydanticUndefined, validation_alias: Annotated[Optional[str], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")] = None, serialization_alias: Annotated[Optional[str], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")] = None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')] = None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')] = None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')] = None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')] = None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')] = None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')] = None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')] = None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')] = None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')] = None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EB090>] = None, discriminator: Annotated[Optional[str], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')] = None, strict: Annotated[Optional[bool], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')] = PydanticUndefined, multiple_of: Annotated[Optional[float], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')] = PydanticUndefined, allow_inf_nan: Annotated[Optional[bool], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')] = PydanticUndefined, max_digits: Annotated[Optional[int], Doc('\\n            Maximum number of allow digits for strings.\\n            ')] = PydanticUndefined, decimal_places: Annotated[Optional[int], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')] = PydanticUndefined, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')] = None, example: Annotated[Optional[Any], <typing_extensions.deprecated object at 0x0000023E9A1EB0D0>] = PydanticUndefined, openapi_examples: Annotated[Optional[Dict[str, fastapi.openapi.models.Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")] = None, deprecated: Annotated[Union[typing_extensions.deprecated, str, bool, NoneType], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')] = None, include_in_schema: typing.Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")] = True, json_schema_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n            Any additional JSON schema data.\\n            ')] = None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EB250>]) -> Any"
        },
        {
          "name": "Depends",
          "doc": "Declare a FastAPI dependency.\n\nIt takes a single \"dependable\" callable (like a function).\n\nDon't call it directly, FastAPI will call it for you.\n\nRead more about it in the\n[FastAPI docs for Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/).\n\n**Example**\n\n```python\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nasync def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):\n    return {\"q\": q, \"skip\": skip, \"limit\": limit}\n\n\n@app.get(\"/items/\")\nasync def read_items(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n```",
          "signature": "(dependency: Annotated[Optional[Callable[..., Any]], Doc('\\n            A \"dependable\" callable (like a function).\\n\\n            Don\\'t call it directly, FastAPI will call it for you, just pass the object\\n            directly.\\n            ')] = None, *, use_cache: typing.Annotated[bool, Doc('\\n            By default, after a dependency is called the first time in a request, if\\n            the dependency is declared again for the rest of the request (for example\\n            if the dependency is needed by several dependencies), the value will be\\n            re-used for the rest of the request.\\n\\n            Set `use_cache` to `False` to disable this behavior and ensure the\\n            dependency is called again (if declared more than once) in the same request.\\n            ')] = True) -> Any"
        },
        {
          "name": "File",
          "doc": null,
          "signature": "(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')] = PydanticUndefined, *, default_factory: Annotated[Optional[Callable[[], Any]], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")] = PydanticUndefined, media_type: typing.Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")] = 'multipart/form-data', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")] = None, alias_priority: Annotated[Optional[int], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')] = PydanticUndefined, validation_alias: Annotated[Optional[str], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")] = None, serialization_alias: Annotated[Optional[str], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")] = None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')] = None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')] = None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')] = None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')] = None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')] = None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')] = None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')] = None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')] = None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')] = None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EB850>] = None, discriminator: Annotated[Optional[str], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')] = None, strict: Annotated[Optional[bool], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')] = PydanticUndefined, multiple_of: Annotated[Optional[float], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')] = PydanticUndefined, allow_inf_nan: Annotated[Optional[bool], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')] = PydanticUndefined, max_digits: Annotated[Optional[int], Doc('\\n            Maximum number of allow digits for strings.\\n            ')] = PydanticUndefined, decimal_places: Annotated[Optional[int], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')] = PydanticUndefined, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')] = None, example: Annotated[Optional[Any], <typing_extensions.deprecated object at 0x0000023E9A1EB890>] = PydanticUndefined, openapi_examples: Annotated[Optional[Dict[str, fastapi.openapi.models.Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")] = None, deprecated: Annotated[Union[typing_extensions.deprecated, str, bool, NoneType], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')] = None, include_in_schema: typing.Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")] = True, json_schema_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n            Any additional JSON schema data.\\n            ')] = None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EBA10>]) -> Any"
        },
        {
          "name": "Form",
          "doc": null,
          "signature": "(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')] = PydanticUndefined, *, default_factory: Annotated[Optional[Callable[[], Any]], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")] = PydanticUndefined, media_type: typing.Annotated[str, Doc(\"\\n            The media type of this parameter field. Changing it would affect the\\n            generated OpenAPI, but currently it doesn't affect the parsing of the data.\\n            \")] = 'application/x-www-form-urlencoded', alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")] = None, alias_priority: Annotated[Optional[int], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')] = PydanticUndefined, validation_alias: Annotated[Optional[str], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")] = None, serialization_alias: Annotated[Optional[str], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")] = None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')] = None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')] = None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')] = None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')] = None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')] = None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')] = None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')] = None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')] = None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')] = None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EB610>] = None, discriminator: Annotated[Optional[str], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')] = None, strict: Annotated[Optional[bool], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')] = PydanticUndefined, multiple_of: Annotated[Optional[float], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')] = PydanticUndefined, allow_inf_nan: Annotated[Optional[bool], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')] = PydanticUndefined, max_digits: Annotated[Optional[int], Doc('\\n            Maximum number of allow digits for strings.\\n            ')] = PydanticUndefined, decimal_places: Annotated[Optional[int], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')] = PydanticUndefined, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')] = None, example: Annotated[Optional[Any], <typing_extensions.deprecated object at 0x0000023E9A1EB650>] = PydanticUndefined, openapi_examples: Annotated[Optional[Dict[str, fastapi.openapi.models.Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")] = None, deprecated: Annotated[Union[typing_extensions.deprecated, str, bool, NoneType], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')] = None, include_in_schema: typing.Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")] = True, json_schema_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n            Any additional JSON schema data.\\n            ')] = None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EB7D0>]) -> Any"
        },
        {
          "name": "Header",
          "doc": null,
          "signature": "(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')] = PydanticUndefined, *, default_factory: Annotated[Optional[Callable[[], Any]], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")] = PydanticUndefined, alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")] = None, alias_priority: Annotated[Optional[int], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')] = PydanticUndefined, validation_alias: Annotated[Optional[str], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")] = None, serialization_alias: Annotated[Optional[str], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")] = None, convert_underscores: typing.Annotated[bool, Doc('\\n            Automatically convert underscores to hyphens in the parameter field name.\\n\\n            Read more about it in the\\n            [FastAPI docs for Header Parameters](https://fastapi.tiangolo.com/tutorial/header-params/#automatic-conversion)\\n            ')] = True, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')] = None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')] = None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')] = None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')] = None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')] = None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')] = None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')] = None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')] = None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')] = None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EAE50>] = None, discriminator: Annotated[Optional[str], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')] = None, strict: Annotated[Optional[bool], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')] = PydanticUndefined, multiple_of: Annotated[Optional[float], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')] = PydanticUndefined, allow_inf_nan: Annotated[Optional[bool], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')] = PydanticUndefined, max_digits: Annotated[Optional[int], Doc('\\n            Maximum number of allow digits for strings.\\n            ')] = PydanticUndefined, decimal_places: Annotated[Optional[int], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')] = PydanticUndefined, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')] = None, example: Annotated[Optional[Any], <typing_extensions.deprecated object at 0x0000023E9A1EAE90>] = PydanticUndefined, openapi_examples: Annotated[Optional[Dict[str, fastapi.openapi.models.Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")] = None, deprecated: Annotated[Union[typing_extensions.deprecated, str, bool, NoneType], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')] = None, include_in_schema: typing.Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")] = True, json_schema_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n            Any additional JSON schema data.\\n            ')] = None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EB010>]) -> Any"
        },
        {
          "name": "Path",
          "doc": "Declare a path parameter for a *path operation*.\n\nRead more about it in the\n[FastAPI docs for Path Parameters and Numeric Validations](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/).\n\n```python\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, Path\n\napp = FastAPI()\n\n\n@app.get(\"/items/{item_id}\")\nasync def read_items(\n    item_id: Annotated[int, Path(title=\"The ID of the item to get\")],\n):\n    return {\"item_id\": item_id}\n```",
          "signature": "(default: Annotated[Any, Doc(\"\\n            Default value if the parameter field is not set.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")] = Ellipsis, *, default_factory: Annotated[Optional[Callable[[], Any]], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")] = PydanticUndefined, alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")] = None, alias_priority: Annotated[Optional[int], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')] = PydanticUndefined, validation_alias: Annotated[Optional[str], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")] = None, serialization_alias: Annotated[Optional[str], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")] = None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')] = None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')] = None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')] = None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')] = None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')] = None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')] = None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')] = None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')] = None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')] = None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1E9CD0>] = None, discriminator: Annotated[Optional[str], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')] = None, strict: Annotated[Optional[bool], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')] = PydanticUndefined, multiple_of: Annotated[Optional[float], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')] = PydanticUndefined, allow_inf_nan: Annotated[Optional[bool], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')] = PydanticUndefined, max_digits: Annotated[Optional[int], Doc('\\n            Maximum number of allow digits for strings.\\n            ')] = PydanticUndefined, decimal_places: Annotated[Optional[int], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')] = PydanticUndefined, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')] = None, example: Annotated[Optional[Any], <typing_extensions.deprecated object at 0x0000023E9A1EA2D0>] = PydanticUndefined, openapi_examples: Annotated[Optional[Dict[str, fastapi.openapi.models.Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")] = None, deprecated: Annotated[Union[typing_extensions.deprecated, str, bool, NoneType], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')] = None, include_in_schema: typing.Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")] = True, json_schema_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n            Any additional JSON schema data.\\n            ')] = None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EA850>]) -> Any"
        },
        {
          "name": "Query",
          "doc": null,
          "signature": "(default: Annotated[Any, Doc('\\n            Default value if the parameter field is not set.\\n            ')] = PydanticUndefined, *, default_factory: Annotated[Optional[Callable[[], Any]], Doc(\"\\n            A callable to generate the default value.\\n\\n            This doesn't affect `Path` parameters as the value is always required.\\n            The parameter is available only for compatibility.\\n            \")] = PydanticUndefined, alias: Annotated[Optional[str], Doc(\"\\n            An alternative name for the parameter field.\\n\\n            This will be used to extract the data and for the generated OpenAPI.\\n            It is particularly useful when you can't use the name you want because it\\n            is a Python reserved keyword or similar.\\n            \")] = None, alias_priority: Annotated[Optional[int], Doc('\\n            Priority of the alias. This affects whether an alias generator is used.\\n            ')] = PydanticUndefined, validation_alias: Annotated[Optional[str], Doc(\"\\n            'Whitelist' validation step. The parameter field will be the single one\\n            allowed by the alias or set of aliases defined.\\n            \")] = None, serialization_alias: Annotated[Optional[str], Doc(\"\\n            'Blacklist' validation step. The vanilla parameter field will be the\\n            single one of the alias' or set of aliases' fields and all the other\\n            fields will be ignored at serialization time.\\n            \")] = None, title: Annotated[Optional[str], Doc('\\n            Human-readable title.\\n            ')] = None, description: Annotated[Optional[str], Doc('\\n            Human-readable description.\\n            ')] = None, gt: Annotated[Optional[float], Doc('\\n            Greater than. If set, value must be greater than this. Only applicable to\\n            numbers.\\n            ')] = None, ge: Annotated[Optional[float], Doc('\\n            Greater than or equal. If set, value must be greater than or equal to\\n            this. Only applicable to numbers.\\n            ')] = None, lt: Annotated[Optional[float], Doc('\\n            Less than. If set, value must be less than this. Only applicable to numbers.\\n            ')] = None, le: Annotated[Optional[float], Doc('\\n            Less than or equal. If set, value must be less than or equal to this.\\n            Only applicable to numbers.\\n            ')] = None, min_length: Annotated[Optional[int], Doc('\\n            Minimum length for strings.\\n            ')] = None, max_length: Annotated[Optional[int], Doc('\\n            Maximum length for strings.\\n            ')] = None, pattern: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            ')] = None, regex: Annotated[Optional[str], Doc('\\n            RegEx pattern for strings.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EAA90>] = None, discriminator: Annotated[Optional[str], Doc('\\n            Parameter field name for discriminating the type in a tagged union.\\n            ')] = None, strict: Annotated[Optional[bool], Doc('\\n            If `True`, strict validation is applied to the field.\\n            ')] = PydanticUndefined, multiple_of: Annotated[Optional[float], Doc('\\n            Value must be a multiple of this. Only applicable to numbers.\\n            ')] = PydanticUndefined, allow_inf_nan: Annotated[Optional[bool], Doc('\\n            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\\n            ')] = PydanticUndefined, max_digits: Annotated[Optional[int], Doc('\\n            Maximum number of allow digits for strings.\\n            ')] = PydanticUndefined, decimal_places: Annotated[Optional[int], Doc('\\n            Maximum number of decimal places allowed for numbers.\\n            ')] = PydanticUndefined, examples: Annotated[Optional[List[Any]], Doc('\\n            Example values for this field.\\n            ')] = None, example: Annotated[Optional[Any], <typing_extensions.deprecated object at 0x0000023E9A1EAAD0>] = PydanticUndefined, openapi_examples: Annotated[Optional[Dict[str, fastapi.openapi.models.Example]], Doc(\"\\n            OpenAPI-specific examples.\\n\\n            It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n            Swagger UI (that provides the `/docs` interface) has better support for the\\n            OpenAPI-specific examples than the JSON Schema `examples`, that's the main\\n            use case for this.\\n\\n            Read more about it in the\\n            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).\\n            \")] = None, deprecated: Annotated[Union[typing_extensions.deprecated, str, bool, NoneType], Doc('\\n            Mark this parameter field as deprecated.\\n\\n            It will affect the generated OpenAPI (e.g. visible at `/docs`).\\n            ')] = None, include_in_schema: typing.Annotated[bool, Doc(\"\\n            To include (or not) this parameter field in the generated OpenAPI.\\n            You probably don't need it, but it's available.\\n\\n            This affects the generated OpenAPI (e.g. visible at `/docs`).\\n            \")] = True, json_schema_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n            Any additional JSON schema data.\\n            ')] = None, **extra: Annotated[Any, Doc('\\n            Include extra fields used by the JSON Schema.\\n            '), <typing_extensions.deprecated object at 0x0000023E9A1EABD0>]) -> Any"
        },
        {
          "name": "Security",
          "doc": "Declare a FastAPI Security dependency.\n\nThe only difference with a regular dependency is that it can declare OAuth2\nscopes that will be integrated with OpenAPI and the automatic UI docs (by default\nat `/docs`).\n\nIt takes a single \"dependable\" callable (like a function).\n\nDon't call it directly, FastAPI will call it for you.\n\nRead more about it in the\n[FastAPI docs for Security](https://fastapi.tiangolo.com/tutorial/security/) and\nin the\n[FastAPI docs for OAuth2 scopes](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).\n\n**Example**\n\n```python\nfrom typing import Annotated\n\nfrom fastapi import Security, FastAPI\n\nfrom .db import User\nfrom .security import get_current_active_user\n\napp = FastAPI()\n\n@app.get(\"/users/me/items/\")\nasync def read_own_items(\n    current_user: Annotated[User, Security(get_current_active_user, scopes=[\"items\"])]\n):\n    return [{\"item_id\": \"Foo\", \"owner\": current_user.username}]\n```",
          "signature": "(dependency: Annotated[Optional[Callable[..., Any]], Doc('\\n            A \"dependable\" callable (like a function).\\n\\n            Don\\'t call it directly, FastAPI will call it for you, just pass the object\\n            directly.\\n            ')] = None, *, scopes: Annotated[Optional[Sequence[str]], Doc('\\n            OAuth2 scopes required for the *path operation* that uses this Security\\n            dependency.\\n\\n            The term \"scope\" comes from the OAuth2 specification, it seems to be\\n            intentionally vague and interpretable. It normally refers to permissions,\\n            in cases to roles.\\n\\n            These scopes are integrated with OpenAPI (and the API docs at `/docs`).\\n            So they are visible in the OpenAPI specification.\\n            )\\n            ')] = None, use_cache: typing.Annotated[bool, Doc('\\n            By default, after a dependency is called the first time in a request, if\\n            the dependency is declared again for the rest of the request (for example\\n            if the dependency is needed by several dependencies), the value will be\\n            re-used for the rest of the request.\\n\\n            Set `use_cache` to `False` to disable this behavior and ensure the\\n            dependency is called again (if declared more than once) in the same request.\\n            ')] = True) -> Any"
        }
      ],
      "classes": [
        {
          "name": "APIRouter",
          "doc": "`APIRouter` class, used to group *path operations*, for example to structure\nan app in multiple files. It would then be included in the `FastAPI` app, or\nin another `APIRouter` (ultimately included in the app).\n\nRead more about it in the\n[FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/).\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\n\napp = FastAPI()\nrouter = APIRouter()\n\n\n@router.get(\"/users/\", tags=[\"users\"])\nasync def read_users():\n    return [{\"username\": \"Rick\"}, {\"username\": \"Morty\"}]\n\n\napp.include_router(router)\n```",
          "functions": [
            {
              "name": "__call__",
              "doc": "The main entry point to the Router class.",
              "signature": "(self, scope: 'Scope', receive: 'Receive', send: 'Send') -> 'None'"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other: 'Any') -> 'bool'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, *, prefix: typing.Annotated[str, Doc('An optional path prefix for the router.')] = '', tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to all the *path operations* in this\\n                router.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to all the\\n                *path operations* in this router.\\n\\n                Read more about it in the\\n                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\\n                ')] = None, default_response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                The default response class to be used.\\n\\n                Read more in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A251450>, responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses to be shown in OpenAPI.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\\n\\n                And in the\\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc('\\n                OpenAPI callbacks that should apply to all *path operations* in this\\n                router.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                ')] = None, routes: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                **Note**: you probably shouldn't use this parameter, it is inherited\\n                from Starlette and supported for compatibility.\\n\\n                ---\\n\\n                A list of routes to serve incoming HTTP and WebSocket requests.\\n                \"), <typing_extensions.deprecated object at 0x0000023E9A251810>] = None, redirect_slashes: typing.Annotated[bool, Doc(\"\\n                Whether to detect and redirect slashes in URLs when the client doesn't\\n                use the same format.\\n                \")] = True, default: Annotated[Optional[Callable[[collections.abc.MutableMapping[str, Any], Callable[[], collections.abc.Awaitable[collections.abc.MutableMapping[str, Any]]], Callable[[collections.abc.MutableMapping[str, Any]], collections.abc.Awaitable[None]]], collections.abc.Awaitable[None]]], Doc('\\n                Default function handler for this router. Used to handle\\n                404 Not Found errors.\\n                ')] = None, dependency_overrides_provider: Annotated[Optional[Any], Doc(\"\\n                Only used internally by FastAPI to handle dependency overrides.\\n\\n                You shouldn't need to use it. It normally points to the `FastAPI` app\\n                object.\\n                \")] = None, route_class: Annotated[Type[fastapi.routing.APIRoute], Doc('\\n                Custom route (*path operation*) class to be used by this router.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Request and APIRoute class](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#custom-apiroute-class-in-a-router).\\n                ')] = <class 'fastapi.routing.APIRoute'>, on_startup: Annotated[Optional[Sequence[Callable[[], Any]]], Doc('\\n                A list of startup event handler functions.\\n\\n                You should instead use the `lifespan` handlers.\\n\\n                Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\\n                ')] = None, on_shutdown: Annotated[Optional[Sequence[Callable[[], Any]]], Doc('\\n                A list of shutdown event handler functions.\\n\\n                You should instead use the `lifespan` handlers.\\n\\n                Read more in the\\n                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\\n                ')] = None, lifespan: Annotated[Union[Callable[[Any], contextlib.AbstractAsyncContextManager[None]], Callable[[Any], contextlib.AbstractAsyncContextManager[collections.abc.Mapping[str, Any]]], NoneType], Doc('\\n                A `Lifespan` context manager handler. This replaces `startup` and\\n                `shutdown` functions with a single context manager.\\n\\n                Read more in the\\n                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark all *path operations* in this router as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, include_in_schema: typing.Annotated[bool, Doc('\\n                To include (or not) all the *path operations* in this router in the\\n                generated OpenAPI.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A2513D0>) -> None"
            },
            {
              "name": "add_api_route",
              "doc": null,
              "signature": "(self, path: str, endpoint: Callable[..., Any], *, response_model: Any = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A2523D0>, status_code: Optional[int] = None, tags: Optional[List[Union[str, enum.Enum]]] = None, dependencies: Optional[Sequence[fastapi.params.Depends]] = None, summary: Optional[str] = None, description: Optional[str] = None, response_description: str = 'Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None, deprecated: Optional[bool] = None, methods: Union[Set[str], List[str], NoneType] = None, operation_id: Optional[str] = None, response_model_include: Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType] = None, response_model_exclude: Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType] = None, response_model_by_alias: bool = True, response_model_exclude_unset: bool = False, response_model_exclude_defaults: bool = False, response_model_exclude_none: bool = False, include_in_schema: bool = True, response_class: Union[Type[starlette.responses.Response], fastapi.datastructures.DefaultPlaceholder] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A252490>, name: Optional[str] = None, route_class_override: Optional[Type[fastapi.routing.APIRoute]] = None, callbacks: Optional[List[starlette.routing.BaseRoute]] = None, openapi_extra: Optional[Dict[str, Any]] = None, generate_unique_id_function: Union[Callable[[fastapi.routing.APIRoute], str], fastapi.datastructures.DefaultPlaceholder] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A252510>) -> None"
            },
            {
              "name": "add_api_websocket_route",
              "doc": null,
              "signature": "(self, path: str, endpoint: Callable[..., Any], name: Optional[str] = None, *, dependencies: Optional[Sequence[fastapi.params.Depends]] = None) -> None"
            },
            {
              "name": "add_event_handler",
              "doc": null,
              "signature": "(self, event_type: 'str', func: 'Callable[[], Any]') -> 'None'"
            },
            {
              "name": "add_route",
              "doc": null,
              "signature": "(self, path: 'str', endpoint: 'Callable[[Request], Awaitable[Response] | Response]', methods: 'Collection[str] | None' = None, name: 'str | None' = None, include_in_schema: 'bool' = True) -> 'None'"
            },
            {
              "name": "add_websocket_route",
              "doc": null,
              "signature": "(self, path: 'str', endpoint: 'Callable[[WebSocket], Awaitable[None]]', name: 'str | None' = None) -> 'None'"
            },
            {
              "name": "api_route",
              "doc": null,
              "signature": "(self, path: str, *, response_model: Any = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A252790>, status_code: Optional[int] = None, tags: Optional[List[Union[str, enum.Enum]]] = None, dependencies: Optional[Sequence[fastapi.params.Depends]] = None, summary: Optional[str] = None, description: Optional[str] = None, response_description: str = 'Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None, deprecated: Optional[bool] = None, methods: Optional[List[str]] = None, operation_id: Optional[str] = None, response_model_include: Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType] = None, response_model_exclude: Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType] = None, response_model_by_alias: bool = True, response_model_exclude_unset: bool = False, response_model_exclude_defaults: bool = False, response_model_exclude_none: bool = False, include_in_schema: bool = True, response_class: Type[starlette.responses.Response] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A252710>, name: Optional[str] = None, callbacks: Optional[List[starlette.routing.BaseRoute]] = None, openapi_extra: Optional[Dict[str, Any]] = None, generate_unique_id_function: Callable[[fastapi.routing.APIRoute], str] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A2527D0>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "app",
              "doc": null,
              "signature": "(self, scope: 'Scope', receive: 'Receive', send: 'Send') -> 'None'"
            },
            {
              "name": "delete",
              "doc": "Add a *path operation* using an HTTP DELETE operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.delete(\"/items/{item_id}\")\ndef delete_item(item_id: str):\n    return {\"message\": \"Item deleted\"}\n\napp.include_router(router)\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253A50>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253AD0>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253B10>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "get",
              "doc": "Add a *path operation* using an HTTP GET operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.get(\"/items/\")\ndef read_items():\n    return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n\napp.include_router(router)\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A252CD0>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A252D50>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A252D90>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "head",
              "doc": "Add a *path operation* using an HTTP HEAD operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.head(\"/items/\", status_code=204)\ndef get_items_headers(response: Response):\n    response.headers[\"X-Cat-Dog\"] = \"Alone in the world\"\n\napp.include_router(router)\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253C10>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253C50>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253C90>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "host",
              "doc": null,
              "signature": "(self, host: 'str', app: 'ASGIApp', name: 'str | None' = None) -> 'None'"
            },
            {
              "name": "include_router",
              "doc": "Include another `APIRouter` in the same current `APIRouter`.\n\nRead more about it in the\n[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\n\napp = FastAPI()\ninternal_router = APIRouter()\nusers_router = APIRouter()\n\n@users_router.get(\"/users/\")\ndef read_users():\n    return [{\"name\": \"Rick\"}, {\"name\": \"Morty\"}]\n\ninternal_router.include_router(users_router)\napp.include_router(internal_router)\n```",
              "signature": "(self, router: Annotated[ForwardRef('APIRouter'), Doc('The `APIRouter` to include.')], *, prefix: typing.Annotated[str, Doc('An optional path prefix for the router.')] = '', tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to all the *path operations* in this\\n                router.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to all the\\n                *path operations* in this router.\\n\\n                Read more about it in the\\n                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\\n                ')] = None, default_response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                The default response class to be used.\\n\\n                Read more in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A252990>, responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses to be shown in OpenAPI.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\\n\\n                And in the\\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc('\\n                OpenAPI callbacks that should apply to all *path operations* in this\\n                router.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark all *path operations* in this router as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, include_in_schema: typing.Annotated[bool, Doc('\\n                Include (or not) all the *path operations* in this router in the\\n                generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = True, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A252A10>) -> None"
            },
            {
              "name": "lifespan",
              "doc": "Handle ASGI lifespan messages, which allows us to manage application\nstartup and shutdown events.",
              "signature": "(self, scope: 'Scope', receive: 'Receive', send: 'Send') -> 'None'"
            },
            {
              "name": "mount",
              "doc": null,
              "signature": "(self, path: 'str', app: 'ASGIApp', name: 'str | None' = None) -> 'None'"
            },
            {
              "name": "not_found",
              "doc": null,
              "signature": "(self, scope: 'Scope', receive: 'Receive', send: 'Send') -> 'None'"
            },
            {
              "name": "on_event",
              "doc": "Add an event handler for the router.\n\n`on_event` is deprecated, use `lifespan` event handlers instead.\n\nRead more about it in the\n[FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).",
              "signature": "(self, event_type: typing.Annotated[str, Doc('\\n                The type of event. `startup` or `shutdown`.\\n                ')]) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "options",
              "doc": "Add a *path operation* using an HTTP OPTIONS operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.options(\"/items/\")\ndef get_item_options():\n    return {\"additions\": [\"Aji\", \"Guacamole\"]}\n\napp.include_router(router)\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253B50>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253B90>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253BD0>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "patch",
              "doc": "Add a *path operation* using an HTTP PATCH operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.patch(\"/items/\")\ndef update_item(item: Item):\n    return {\"message\": \"Item updated in place\"}\n\napp.include_router(router)\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253CD0>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253D10>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253D50>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "post",
              "doc": "Add a *path operation* using an HTTP POST operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.post(\"/items/\")\ndef create_item(item: Item):\n    return {\"message\": \"Item created\"}\n\napp.include_router(router)\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253990>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A2539D0>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253A10>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "put",
              "doc": "Add a *path operation* using an HTTP PUT operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.put(\"/items/{item_id}\")\ndef replace_item(item_id: str, item: Item):\n    return {\"message\": \"Item replaced\", \"id\": item_id}\n\napp.include_router(router)\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A2538D0>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253950>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253750>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "route",
              "doc": "We no longer document this decorator style API, and its usage is discouraged.\nInstead you should use the following approach:\n\n>>> routes = [Route(path, endpoint=...), ...]\n>>> app = Starlette(routes=routes)",
              "signature": "(self, path: str, methods: Optional[Collection[str]] = None, name: Optional[str] = None, include_in_schema: bool = True) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "shutdown",
              "doc": "Run any `.on_shutdown` event handlers.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "startup",
              "doc": "Run any `.on_startup` event handlers.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "trace",
              "doc": "Add a *path operation* using an HTTP TRACE operation.\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.trace(\"/items/{item_id}\")\ndef trace_item(item_id: str):\n    return None\n\napp.include_router(router)\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253D90>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253DD0>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A253E10>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "url_path_for",
              "doc": null,
              "signature": "(self, name: 'str', /, **path_params: 'Any') -> 'URLPath'"
            },
            {
              "name": "websocket",
              "doc": "Decorate a WebSocket function.\n\nRead more about it in the\n[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n\n**Example**\n\n## Example\n\n```python\nfrom fastapi import APIRouter, FastAPI, WebSocket\n\napp = FastAPI()\nrouter = APIRouter()\n\n@router.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        await websocket.send_text(f\"Message text was: {data}\")\n\napp.include_router(router)\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                WebSocket path.\\n                ')], name: Annotated[Optional[str], Doc('\\n                A name for the WebSocket. Only used internally.\\n                ')] = None, *, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be used for this\\n                WebSocket.\\n\\n                Read more about it in the\\n                [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\\n                ')] = None) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "websocket_route",
              "doc": "We no longer document this decorator style API, and its usage is discouraged.\nInstead you should use the following approach:\n\n>>> routes = [WebSocketRoute(path, endpoint=...), ...]\n>>> app = Starlette(routes=routes)",
              "signature": "(self, path: str, name: Optional[str] = None) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            }
          ]
        },
        {
          "name": "BackgroundTasks",
          "doc": "A collection of background tasks that will be called after a response has been\nsent to the client.\n\nRead more about it in the\n[FastAPI docs for Background Tasks](https://fastapi.tiangolo.com/tutorial/background-tasks/).\n\n## Example\n\n```python\nfrom fastapi import BackgroundTasks, FastAPI\n\napp = FastAPI()\n\n\ndef write_notification(email: str, message=\"\"):\n    with open(\"log.txt\", mode=\"w\") as email_file:\n        content = f\"notification for {email}: {message}\"\n        email_file.write(content)\n\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(write_notification, email, message=\"some notification\")\n    return {\"message\": \"Notification sent in the background\"}\n```",
          "functions": [
            {
              "name": "__call__",
              "doc": "Call self as a function.",
              "signature": "(self) -> 'None'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, tasks: 'Sequence[BackgroundTask] | None' = None)"
            },
            {
              "name": "add_task",
              "doc": "Add a function to be called in the background after the response is sent.\n\nRead more about it in the\n[FastAPI docs for Background Tasks](https://fastapi.tiangolo.com/tutorial/background-tasks/).",
              "signature": "(self, func: Annotated[Callable[~P, Any], Doc('\\n                The function to call after the response is sent.\\n\\n                It can be a regular `def` function or an `async def` function.\\n                ')], *args: P.args, **kwargs: P.kwargs) -> None"
            }
          ]
        },
        {
          "name": "FastAPI",
          "doc": "`FastAPI` app class, the main entrypoint to use FastAPI.\n\nRead more in the\n[FastAPI docs for First Steps](https://fastapi.tiangolo.com/tutorial/first-steps/).\n\n## Example\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n```",
          "functions": [
            {
              "name": "__call__",
              "doc": "Call self as a function.",
              "signature": "(self, scope: collections.abc.MutableMapping[str, typing.Any], receive: Callable[[], collections.abc.Awaitable[collections.abc.MutableMapping[str, Any]]], send: Callable[[collections.abc.MutableMapping[str, Any]], collections.abc.Awaitable[None]]) -> None"
            },
            {
              "name": "__init__",
              "doc": "Initializes the application.\n\nParameters:\n    debug: Boolean indicating if debug tracebacks should be returned on errors.\n    routes: A list of routes to serve incoming HTTP and WebSocket requests.\n    middleware: A list of middleware to run for every request. A starlette\n        application will always automatically include two middleware classes.\n        `ServerErrorMiddleware` is added as the very outermost middleware, to handle\n        any uncaught errors occurring anywhere in the entire stack.\n        `ExceptionMiddleware` is added as the very innermost middleware, to deal\n        with handled exception cases occurring in the routing or endpoints.\n    exception_handlers: A mapping of either integer status codes,\n        or exception class types onto callables which handle the exceptions.\n        Exception handler callables should be of the form\n        `handler(request, exc) -> response` and may be either standard functions, or\n        async functions.\n    on_startup: A list of callables to run on application startup.\n        Startup handler callables do not take any arguments, and may be either\n        standard functions, or async functions.\n    on_shutdown: A list of callables to run on application shutdown.\n        Shutdown handler callables do not take any arguments, and may be either\n        standard functions, or async functions.\n    lifespan: A lifespan context function, which can be used to perform\n        startup and shutdown tasks. This is a newer style that replaces the\n        `on_startup` and `on_shutdown` handlers. Use one or the other, not both.",
              "signature": "(self: ~AppType, *, debug: typing.Annotated[bool, Doc('\\n                Boolean indicating if debug tracebacks should be returned on server\\n                errors.\\n\\n                Read more in the\\n                [Starlette docs for Applications](https://www.starlette.io/applications/#instantiating-the-application).\\n                ')] = False, routes: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                **Note**: you probably shouldn't use this parameter, it is inherited\\n                from Starlette and supported for compatibility.\\n\\n                ---\\n\\n                A list of routes to serve incoming HTTP and WebSocket requests.\\n                \"), <typing_extensions.deprecated object at 0x0000023E9A25D850>] = None, title: typing.Annotated[str, Doc('\\n                The title of the API.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more in the\\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                app = FastAPI(title=\"ChimichangApp\")\\n                ```\\n                ')] = 'FastAPI', summary: Annotated[Optional[str], Doc('\\n                A short summary of the API.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more in the\\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                app = FastAPI(summary=\"Deadpond\\'s favorite app. Nuff said.\")\\n                ```\\n                ')] = None, description: typing.Annotated[str, Doc('\\n                A description of the API. Supports Markdown (using\\n                [CommonMark syntax](https://commonmark.org/)).\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more in the\\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                app = FastAPI(\\n                    description=\"\"\"\\n                                ChimichangApp API helps you do awesome stuff. \ud83d\ude80\\n\\n                                ## Items\\n\\n                                You can **read items**.\\n\\n                                ## Users\\n\\n                                You will be able to:\\n\\n                                * **Create users** (_not implemented_).\\n                                * **Read users** (_not implemented_).\\n\\n                                \"\"\"\\n                )\\n                ```\\n                ')] = '', version: typing.Annotated[str, Doc('\\n                The version of the API.\\n\\n                **Note** This is the version of your application, not the version of\\n                the OpenAPI specification nor the version of FastAPI being used.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more in the\\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                app = FastAPI(version=\"0.0.1\")\\n                ```\\n                ')] = '0.1.0', openapi_url: Annotated[Optional[str], Doc('\\n                The URL where the OpenAPI schema will be served from.\\n\\n                If you set it to `None`, no OpenAPI schema will be served publicly, and\\n                the default automatic endpoints `/docs` and `/redoc` will also be\\n                disabled.\\n\\n                Read more in the\\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#openapi-url).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                app = FastAPI(openapi_url=\"/api/v1/openapi.json\")\\n                ```\\n                ')] = '/openapi.json', openapi_tags: Annotated[Optional[List[Dict[str, Any]]], Doc('\\n                A list of tags used by OpenAPI, these are the same `tags` you can set\\n                in the *path operations*, like:\\n\\n                * `@app.get(\"/users/\", tags=[\"users\"])`\\n                * `@app.get(\"/items/\", tags=[\"items\"])`\\n\\n                The order of the tags can be used to specify the order shown in\\n                tools like Swagger UI, used in the automatic path `/docs`.\\n\\n                It\\'s not required to specify all the tags used.\\n\\n                The tags that are not declared MAY be organized randomly or based\\n                on the tools\\' logic. Each tag name in the list MUST be unique.\\n\\n                The value of each item is a `dict` containing:\\n\\n                * `name`: The name of the tag.\\n                * `description`: A short description of the tag.\\n                    [CommonMark syntax](https://commonmark.org/) MAY be used for rich\\n                    text representation.\\n                * `externalDocs`: Additional external documentation for this tag. If\\n                    provided, it would contain a `dict` with:\\n                    * `description`: A short description of the target documentation.\\n                        [CommonMark syntax](https://commonmark.org/) MAY be used for\\n                        rich text representation.\\n                    * `url`: The URL for the target documentation. Value MUST be in\\n                        the form of a URL.\\n\\n                Read more in the\\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-tags).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                tags_metadata = [\\n                    {\\n                        \"name\": \"users\",\\n                        \"description\": \"Operations with users. The **login** logic is also here.\",\\n                    },\\n                    {\\n                        \"name\": \"items\",\\n                        \"description\": \"Manage items. So _fancy_ they have their own docs.\",\\n                        \"externalDocs\": {\\n                            \"description\": \"Items external docs\",\\n                            \"url\": \"https://fastapi.tiangolo.com/\",\\n                        },\\n                    },\\n                ]\\n\\n                app = FastAPI(openapi_tags=tags_metadata)\\n                ```\\n                ')] = None, servers: Annotated[Optional[List[Dict[str, Union[Any, str]]]], Doc('\\n                A `list` of `dict`s with connectivity information to a target server.\\n\\n                You would use it, for example, if your application is served from\\n                different domains and you want to use the same Swagger UI in the\\n                browser to interact with each of them (instead of having multiple\\n                browser tabs open). Or if you want to leave fixed the possible URLs.\\n\\n                If the servers `list` is not provided, or is an empty `list`, the\\n                default value would be a `dict` with a `url` value of `/`.\\n\\n                Each item in the `list` is a `dict` containing:\\n\\n                * `url`: A URL to the target host. This URL supports Server Variables\\n                and MAY be relative, to indicate that the host location is relative\\n                to the location where the OpenAPI document is being served. Variable\\n                substitutions will be made when a variable is named in `{`brackets`}`.\\n                * `description`: An optional string describing the host designated by\\n                the URL. [CommonMark syntax](https://commonmark.org/) MAY be used for\\n                rich text representation.\\n                * `variables`: A `dict` between a variable name and its value. The value\\n                    is used for substitution in the server\\'s URL template.\\n\\n                Read more in the\\n                [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#additional-servers).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                app = FastAPI(\\n                    servers=[\\n                        {\"url\": \"https://stag.example.com\", \"description\": \"Staging environment\"},\\n                        {\"url\": \"https://prod.example.com\", \"description\": \"Production environment\"},\\n                    ]\\n                )\\n                ```\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of global dependencies, they will be applied to each\\n                *path operation*, including in sub-routers.\\n\\n                Read more about it in the\\n                [FastAPI docs for Global Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/global-dependencies/).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import Depends, FastAPI\\n\\n                from .dependencies import func_dep_1, func_dep_2\\n\\n                app = FastAPI(dependencies=[Depends(func_dep_1), Depends(func_dep_2)])\\n                ```\\n                ')] = None, default_response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                The default response class to be used.\\n\\n                Read more in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n                from fastapi.responses import ORJSONResponse\\n\\n                app = FastAPI(default_response_class=ORJSONResponse)\\n                ```\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A066190>, redirect_slashes: typing.Annotated[bool, Doc('\\n                Whether to detect and redirect slashes in URLs when the client doesn\\'t\\n                use the same format.\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                app = FastAPI(redirect_slashes=True)  # the default\\n\\n                @app.get(\"/items/\")\\n                async def read_items():\\n                    return [{\"item_id\": \"Foo\"}]\\n                ```\\n\\n                With this app, if a client goes to `/items` (without a trailing slash),\\n                they will be automatically redirected with an HTTP status code of 307\\n                to `/items/`.\\n                ')] = True, docs_url: Annotated[Optional[str], Doc('\\n                The path to the automatic interactive API documentation.\\n                It is handled in the browser by Swagger UI.\\n\\n                The default URL is `/docs`. You can disable it by setting it to `None`.\\n\\n                If `openapi_url` is set to `None`, this will be automatically disabled.\\n\\n                Read more in the\\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                app = FastAPI(docs_url=\"/documentation\", redoc_url=None)\\n                ```\\n                ')] = '/docs', redoc_url: Annotated[Optional[str], Doc('\\n                The path to the alternative automatic interactive API documentation\\n                provided by ReDoc.\\n\\n                The default URL is `/redoc`. You can disable it by setting it to `None`.\\n\\n                If `openapi_url` is set to `None`, this will be automatically disabled.\\n\\n                Read more in the\\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                app = FastAPI(docs_url=\"/documentation\", redoc_url=\"redocumentation\")\\n                ```\\n                ')] = '/redoc', swagger_ui_oauth2_redirect_url: Annotated[Optional[str], Doc('\\n                The OAuth2 redirect endpoint for the Swagger UI.\\n\\n                By default it is `/docs/oauth2-redirect`.\\n\\n                This is only used if you use OAuth2 (with the \"Authorize\" button)\\n                with Swagger UI.\\n                ')] = '/docs/oauth2-redirect', swagger_ui_init_oauth: Annotated[Optional[Dict[str, Any]], Doc('\\n                OAuth2 configuration for the Swagger UI, by default shown at `/docs`.\\n\\n                Read more about the available configuration options in the\\n                [Swagger UI docs](https://swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2/).\\n                ')] = None, middleware: Annotated[Optional[Sequence[starlette.middleware.Middleware]], Doc('\\n                List of middleware to be added when creating the application.\\n\\n                In FastAPI you would normally do this with `app.add_middleware()`\\n                instead.\\n\\n                Read more in the\\n                [FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).\\n                ')] = None, exception_handlers: Annotated[Optional[Dict[Union[int, Type[Exception]], Callable[[starlette.requests.Request, Any], Coroutine[Any, Any, starlette.responses.Response]]]], Doc('\\n                A dictionary with handlers for exceptions.\\n\\n                In FastAPI, you would normally use the decorator\\n                `@app.exception_handler()`.\\n\\n                Read more in the\\n                [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).\\n                ')] = None, on_startup: Annotated[Optional[Sequence[Callable[[], Any]]], Doc('\\n                A list of startup event handler functions.\\n\\n                You should instead use the `lifespan` handlers.\\n\\n                Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\\n                ')] = None, on_shutdown: Annotated[Optional[Sequence[Callable[[], Any]]], Doc('\\n                A list of shutdown event handler functions.\\n\\n                You should instead use the `lifespan` handlers.\\n\\n                Read more in the\\n                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\\n                ')] = None, lifespan: Annotated[Union[Callable[[~AppType], contextlib.AbstractAsyncContextManager[None]], Callable[[~AppType], contextlib.AbstractAsyncContextManager[collections.abc.Mapping[str, Any]]], NoneType], Doc('\\n                A `Lifespan` context manager handler. This replaces `startup` and\\n                `shutdown` functions with a single context manager.\\n\\n                Read more in the\\n                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\\n                ')] = None, terms_of_service: Annotated[Optional[str], Doc('\\n                A URL to the Terms of Service for your API.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more at the\\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\\n\\n                **Example**\\n\\n                ```python\\n                app = FastAPI(terms_of_service=\"http://example.com/terms/\")\\n                ```\\n                ')] = None, contact: Annotated[Optional[Dict[str, Union[Any, str]]], Doc('\\n                A dictionary with the contact information for the exposed API.\\n\\n                It can contain several fields.\\n\\n                * `name`: (`str`) The name of the contact person/organization.\\n                * `url`: (`str`) A URL pointing to the contact information. MUST be in\\n                    the format of a URL.\\n                * `email`: (`str`) The email address of the contact person/organization.\\n                    MUST be in the format of an email address.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more at the\\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\\n\\n                **Example**\\n\\n                ```python\\n                app = FastAPI(\\n                    contact={\\n                        \"name\": \"Deadpoolio the Amazing\",\\n                        \"url\": \"http://x-force.example.com/contact/\",\\n                        \"email\": \"dp@x-force.example.com\",\\n                    }\\n                )\\n                ```\\n                ')] = None, license_info: Annotated[Optional[Dict[str, Union[Any, str]]], Doc('\\n                A dictionary with the license information for the exposed API.\\n\\n                It can contain several fields.\\n\\n                * `name`: (`str`) **REQUIRED** (if a `license_info` is set). The\\n                    license name used for the API.\\n                * `identifier`: (`str`) An [SPDX](https://spdx.dev/) license expression\\n                    for the API. The `identifier` field is mutually exclusive of the `url`\\n                    field. Available since OpenAPI 3.1.0, FastAPI 0.99.0.\\n                * `url`: (`str`) A URL to the license used for the API. This MUST be\\n                    the format of a URL.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more at the\\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\\n\\n                **Example**\\n\\n                ```python\\n                app = FastAPI(\\n                    license_info={\\n                        \"name\": \"Apache 2.0\",\\n                        \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\",\\n                    }\\n                )\\n                ```\\n                ')] = None, openapi_prefix: typing.Annotated[str, Doc('\\n                A URL prefix for the OpenAPI URL.\\n                '), <typing_extensions.deprecated object at 0x0000023E9A27A250>] = '', root_path: typing.Annotated[str, Doc('\\n                A path prefix handled by a proxy that is not seen by the application\\n                but is seen by external clients, which affects things like Swagger UI.\\n\\n                Read more about it at the\\n                [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                app = FastAPI(root_path=\"/api/v1\")\\n                ```\\n                ')] = '', root_path_in_servers: typing.Annotated[bool, Doc('\\n                To disable automatically generating the URLs in the `servers` field\\n                in the autogenerated OpenAPI using the `root_path`.\\n\\n                Read more about it in the\\n                [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#disable-automatic-server-from-root_path).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                app = FastAPI(root_path_in_servers=False)\\n                ```\\n                ')] = True, responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses to be shown in OpenAPI.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\\n\\n                And in the\\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc('\\n                OpenAPI callbacks that should apply to all *path operations*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                ')] = None, webhooks: Annotated[Optional[fastapi.routing.APIRouter], Doc(\"\\n                Add OpenAPI webhooks. This is similar to `callbacks` but it doesn't\\n                depend on specific *path operations*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                **Note**: This is available since OpenAPI 3.1.0, FastAPI 0.99.0.\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).\\n                \")] = None, deprecated: Annotated[Optional[bool], Doc(\"\\n                Mark all *path operations* as deprecated. You probably don't need it,\\n                but it's available.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                \")] = None, include_in_schema: typing.Annotated[bool, Doc(\"\\n                To include (or not) all the *path operations* in the generated OpenAPI.\\n                You probably don't need it, but it's available.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                \")] = True, swagger_ui_parameters: Annotated[Optional[Dict[str, Any]], Doc('\\n                Parameters to configure Swagger UI, the autogenerated interactive API\\n                documentation (by default at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A066110>, separate_input_output_schemas: typing.Annotated[bool, Doc(\"\\n                Whether to generate separate OpenAPI schemas for request body and\\n                response body when the results would be more precise.\\n\\n                This is particularly useful when automatically generating clients.\\n\\n                For example, if you have a model like:\\n\\n                ```python\\n                from pydantic import BaseModel\\n\\n                class Item(BaseModel):\\n                    name: str\\n                    tags: list[str] = []\\n                ```\\n\\n                When `Item` is used for input, a request body, `tags` is not required,\\n                the client doesn't have to provide it.\\n\\n                But when using `Item` for output, for a response body, `tags` is always\\n                available because it has a default value, even if it's just an empty\\n                list. So, the client should be able to always expect it.\\n\\n                In this case, there would be two different schemas, one for input and\\n                another one for output.\\n                \")] = True, **extra: Annotated[Any, Doc('\\n                Extra keyword arguments to be stored in the app, not used by FastAPI\\n                anywhere.\\n                ')]) -> None"
            },
            {
              "name": "add_api_route",
              "doc": null,
              "signature": "(self, path: str, endpoint: Callable[..., Any], *, response_model: Any = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27A7D0>, status_code: Optional[int] = None, tags: Optional[List[Union[str, enum.Enum]]] = None, dependencies: Optional[Sequence[fastapi.params.Depends]] = None, summary: Optional[str] = None, description: Optional[str] = None, response_description: str = 'Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None, deprecated: Optional[bool] = None, methods: Optional[List[str]] = None, operation_id: Optional[str] = None, response_model_include: Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType] = None, response_model_exclude: Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType] = None, response_model_by_alias: bool = True, response_model_exclude_unset: bool = False, response_model_exclude_defaults: bool = False, response_model_exclude_none: bool = False, include_in_schema: bool = True, response_class: Union[Type[starlette.responses.Response], fastapi.datastructures.DefaultPlaceholder] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27A850>, name: Optional[str] = None, openapi_extra: Optional[Dict[str, Any]] = None, generate_unique_id_function: Callable[[fastapi.routing.APIRoute], str] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27A890>) -> None"
            },
            {
              "name": "add_api_websocket_route",
              "doc": null,
              "signature": "(self, path: str, endpoint: Callable[..., Any], name: Optional[str] = None, *, dependencies: Optional[Sequence[fastapi.params.Depends]] = None) -> None"
            },
            {
              "name": "add_event_handler",
              "doc": null,
              "signature": "(self, event_type: 'str', func: 'Callable') -> 'None'"
            },
            {
              "name": "add_exception_handler",
              "doc": null,
              "signature": "(self, exc_class_or_status_code: 'int | type[Exception]', handler: 'ExceptionHandler') -> 'None'"
            },
            {
              "name": "add_middleware",
              "doc": null,
              "signature": "(self, middleware_class: '_MiddlewareFactory[P]', *args: 'P.args', **kwargs: 'P.kwargs') -> 'None'"
            },
            {
              "name": "add_route",
              "doc": null,
              "signature": "(self, path: 'str', route: 'Callable[[Request], Awaitable[Response] | Response]', methods: 'list[str] | None' = None, name: 'str | None' = None, include_in_schema: 'bool' = True) -> 'None'"
            },
            {
              "name": "add_websocket_route",
              "doc": null,
              "signature": "(self, path: 'str', route: 'Callable[[WebSocket], Awaitable[None]]', name: 'str | None' = None) -> 'None'"
            },
            {
              "name": "api_route",
              "doc": null,
              "signature": "(self, path: str, *, response_model: Any = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27A8D0>, status_code: Optional[int] = None, tags: Optional[List[Union[str, enum.Enum]]] = None, dependencies: Optional[Sequence[fastapi.params.Depends]] = None, summary: Optional[str] = None, description: Optional[str] = None, response_description: str = 'Successful Response', responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None, deprecated: Optional[bool] = None, methods: Optional[List[str]] = None, operation_id: Optional[str] = None, response_model_include: Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType] = None, response_model_exclude: Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType] = None, response_model_by_alias: bool = True, response_model_exclude_unset: bool = False, response_model_exclude_defaults: bool = False, response_model_exclude_none: bool = False, include_in_schema: bool = True, response_class: Type[starlette.responses.Response] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27A910>, name: Optional[str] = None, openapi_extra: Optional[Dict[str, Any]] = None, generate_unique_id_function: Callable[[fastapi.routing.APIRoute], str] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27A950>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "build_middleware_stack",
              "doc": null,
              "signature": "(self) -> 'ASGIApp'"
            },
            {
              "name": "delete",
              "doc": "Add a *path operation* using an HTTP DELETE operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.delete(\"/items/{item_id}\")\ndef delete_item(item_id: str):\n    return {\"message\": \"Item deleted\"}\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27AF90>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27AFD0>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B050>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "exception_handler",
              "doc": "Add an exception handler to the app.\n\nRead more about it in the\n[FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).\n\n## Example\n\n```python\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\n\n\nclass UnicornException(Exception):\n    def __init__(self, name: str):\n        self.name = name\n\n\napp = FastAPI()\n\n\n@app.exception_handler(UnicornException)\nasync def unicorn_exception_handler(request: Request, exc: UnicornException):\n    return JSONResponse(\n        status_code=418,\n        content={\"message\": f\"Oops! {exc.name} did something. There goes a rainbow...\"},\n    )\n```",
              "signature": "(self, exc_class_or_status_code: Annotated[Union[int, Type[Exception]], Doc('\\n                The Exception class this would handle, or a status code.\\n                ')]) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "get",
              "doc": "Add a *path operation* using an HTTP GET operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/items/\")\ndef read_items():\n    return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27ACD0>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27AD90>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27AD10>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "head",
              "doc": "Add a *path operation* using an HTTP HEAD operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI, Response\n\napp = FastAPI()\n\n@app.head(\"/items/\", status_code=204)\ndef get_items_headers(response: Response):\n    response.headers[\"X-Cat-Dog\"] = \"Alone in the world\"\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B190>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B1D0>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B250>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "host",
              "doc": null,
              "signature": "(self, host: 'str', app: 'ASGIApp', name: 'str | None' = None) -> 'None'"
            },
            {
              "name": "include_router",
              "doc": "Include an `APIRouter` in the same app.\n\nRead more about it in the\n[FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).\n\n## Example\n\n```python\nfrom fastapi import FastAPI\n\nfrom .users import users_router\n\napp = FastAPI()\n\napp.include_router(users_router)\n```",
              "signature": "(self, router: typing.Annotated[fastapi.routing.APIRouter, Doc('The `APIRouter` to include.')], *, prefix: typing.Annotated[str, Doc('An optional path prefix for the router.')] = '', tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to all the *path operations* in this\\n                router.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to all the\\n                *path operations* in this router.\\n\\n                Read more about it in the\\n                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import Depends, FastAPI\\n\\n                from .dependencies import get_token_header\\n                from .internal import admin\\n\\n                app = FastAPI()\\n\\n                app.include_router(\\n                    admin.router,\\n                    dependencies=[Depends(get_token_header)],\\n                )\\n                ```\\n                ')] = None, responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses to be shown in OpenAPI.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\\n\\n                And in the\\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark all the *path operations* in this router as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                from .internal import old_api\\n\\n                app = FastAPI()\\n\\n                app.include_router(\\n                    old_api.router,\\n                    deprecated=True,\\n                )\\n                ```\\n                ')] = None, include_in_schema: typing.Annotated[bool, Doc('\\n                Include (or not) all the *path operations* in this router in the\\n                generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n\\n                from .internal import old_api\\n\\n                app = FastAPI()\\n\\n                app.include_router(\\n                    old_api.router,\\n                    include_in_schema=False,\\n                )\\n                ```\\n                ')] = True, default_response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Default response class to be used for the *path operations* in this\\n                router.\\n\\n                Read more in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\\n\\n                **Example**\\n\\n                ```python\\n                from fastapi import FastAPI\\n                from fastapi.responses import ORJSONResponse\\n\\n                from .internal import old_api\\n\\n                app = FastAPI()\\n\\n                app.include_router(\\n                    old_api.router,\\n                    default_response_class=ORJSONResponse,\\n                )\\n                ```\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27A990>, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27A9D0>) -> None"
            },
            {
              "name": "middleware",
              "doc": "Add a middleware to the application.\n\nRead more about it in the\n[FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).\n\n## Example\n\n```python\nimport time\nfrom typing import Awaitable, Callable\n\nfrom fastapi import FastAPI, Request, Response\n\napp = FastAPI()\n\n\n@app.middleware(\"http\")\nasync def add_process_time_header(\n    request: Request, call_next: Callable[[Request], Awaitable[Response]]\n) -> Response:\n    start_time = time.time()\n    response = await call_next(request)\n    process_time = time.time() - start_time\n    response.headers[\"X-Process-Time\"] = str(process_time)\n    return response\n```",
              "signature": "(self, middleware_type: typing.Annotated[str, Doc('\\n                The type of middleware. Currently only supports `http`.\\n                ')]) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "mount",
              "doc": null,
              "signature": "(self, path: 'str', app: 'ASGIApp', name: 'str | None' = None) -> 'None'"
            },
            {
              "name": "on_event",
              "doc": "Add an event handler for the application.\n\n`on_event` is deprecated, use `lifespan` event handlers instead.\n\nRead more about it in the\n[FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).",
              "signature": "(self, event_type: typing.Annotated[str, Doc('\\n                The type of event. `startup` or `shutdown`.\\n                ')]) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "openapi",
              "doc": "Generate the OpenAPI schema of the application. This is called by FastAPI\ninternally.\n\nThe first time it is called it stores the result in the attribute\n`app.openapi_schema`, and next times it is called, it just returns that same\nresult. To avoid the cost of generating the schema every time.\n\nIf you need to modify the generated OpenAPI schema, you could modify it.\n\nRead more in the\n[FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).",
              "signature": "(self) -> Dict[str, Any]"
            },
            {
              "name": "options",
              "doc": "Add a *path operation* using an HTTP OPTIONS operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.options(\"/items/\")\ndef get_item_options():\n    return {\"additions\": [\"Aji\", \"Guacamole\"]}\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B090>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B0D0>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B150>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "patch",
              "doc": "Add a *path operation* using an HTTP PATCH operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\n\n@app.patch(\"/items/\")\ndef update_item(item: Item):\n    return {\"message\": \"Item updated in place\"}\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B290>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B2D0>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B350>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "post",
              "doc": "Add a *path operation* using an HTTP POST operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\n\n@app.post(\"/items/\")\ndef create_item(item: Item):\n    return {\"message\": \"Item created\"}\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27AE90>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27AED0>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27AF50>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "put",
              "doc": "Add a *path operation* using an HTTP PUT operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str | None = None\n\napp = FastAPI()\n\n@app.put(\"/items/{item_id}\")\ndef replace_item(item_id: str, item: Item):\n    return {\"message\": \"Item replaced\", \"id\": item_id}\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27ADD0>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27AE10>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27AE50>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "route",
              "doc": "We no longer document this decorator style API, and its usage is discouraged.\nInstead you should use the following approach:\n\n>>> routes = [Route(path, endpoint=...), ...]\n>>> app = Starlette(routes=routes)",
              "signature": "(self, path: 'str', methods: 'list[str] | None' = None, name: 'str | None' = None, include_in_schema: 'bool' = True) -> 'Callable'"
            },
            {
              "name": "setup",
              "doc": null,
              "signature": "(self) -> None"
            },
            {
              "name": "trace",
              "doc": "Add a *path operation* using an HTTP TRACE operation.\n\n## Example\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.trace(\"/items/{item_id}\")\ndef trace_item(item_id: str):\n    return None\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                The URL path to be used for this *path operation*.\\n\\n                For example, in `http://example.com/items`, the path is `/items`.\\n                ')], *, response_model: Annotated[Any, Doc(\"\\n                The type to use for the response.\\n\\n                It could be any valid Pydantic *field* type. So, it doesn't have to\\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\\n                etc.\\n\\n                It will be used for:\\n\\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\\n                    show it as the response (JSON Schema).\\n                * Serialization: you could return an arbitrary object and the\\n                    `response_model` would be used to serialize that object into the\\n                    corresponding JSON.\\n                * Filtering: the JSON sent to the client will only contain the data\\n                    (fields) defined in the `response_model`. If you returned an object\\n                    that contains an attribute `password` but the `response_model` does\\n                    not include that field, the JSON sent to the client would not have\\n                    that `password`.\\n                * Validation: whatever you return will be serialized with the\\n                    `response_model`, converting any data as necessary to generate the\\n                    corresponding JSON. But if the data in the object returned is not\\n                    valid, that would mean a violation of the contract with the client,\\n                    so it's an error from the API developer. So, FastAPI will raise an\\n                    error and return a 500 error code (Internal Server Error).\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\\n                \")] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B390>, status_code: Annotated[Optional[int], Doc('\\n                The default status code to be used for the response.\\n\\n                You could override the status code by returning a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\\n                ')] = None, tags: Annotated[Optional[List[Union[str, enum.Enum]]], Doc('\\n                A list of tags to be applied to the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\\n                ')] = None, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be applied to the\\n                *path operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\\n                ')] = None, summary: Annotated[Optional[str], Doc('\\n                A summary for the *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, description: Annotated[Optional[str], Doc('\\n                A description for the *path operation*.\\n\\n                If not provided, it will be extracted automatically from the docstring\\n                of the *path operation function*.\\n\\n                It can contain Markdown.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\\n                ')] = None, response_description: typing.Annotated[str, Doc('\\n                The description for the default response.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = 'Successful Response', responses: Annotated[Optional[Dict[Union[int, str], Dict[str, Any]]], Doc('\\n                Additional responses that could be returned by this *path operation*.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, deprecated: Annotated[Optional[bool], Doc('\\n                Mark this *path operation* as deprecated.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n                ')] = None, operation_id: Annotated[Optional[str], Doc('\\n                Custom operation ID to be used by this *path operation*.\\n\\n                By default, it is generated automatically.\\n\\n                If you provide a custom operation ID, you need to make sure it is\\n                unique for the whole API.\\n\\n                You can customize the\\n                operation ID generation with the parameter\\n                `generate_unique_id_function` in the `FastAPI` class.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = None, response_model_include: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to include only certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_exclude: Annotated[Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], NoneType], Doc('\\n                Configuration passed to Pydantic to exclude certain fields in the\\n                response data.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = None, response_model_by_alias: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response model\\n                should be serialized by alias when an alias is used.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\\n                ')] = True, response_model_exclude_unset: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that were not set and\\n                have their default values. This is different from\\n                `response_model_exclude_defaults` in that if the fields are set,\\n                they will be included in the response, even if the value is the same\\n                as the default.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_defaults: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data\\n                should have all the fields, including the ones that have the same value\\n                as the default. This is different from `response_model_exclude_unset`\\n                in that if the fields are set but contain the same default values,\\n                they will be excluded from the response.\\n\\n                When `True`, default values are omitted from the response.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\\n                ')] = False, response_model_exclude_none: typing.Annotated[bool, Doc('\\n                Configuration passed to Pydantic to define if the response data should\\n                exclude fields set to `None`.\\n\\n                This is much simpler (less smart) than `response_model_exclude_unset`\\n                and `response_model_exclude_defaults`. You probably want to use one of\\n                those two instead of this one, as those allow returning `None` values\\n                when it makes sense.\\n\\n                Read more about it in the\\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\\n                ')] = False, include_in_schema: typing.Annotated[bool, Doc('\\n                Include this *path operation* in the generated OpenAPI schema.\\n\\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\\n                ')] = True, response_class: Annotated[Type[starlette.responses.Response], Doc('\\n                Response class to be used for this *path operation*.\\n\\n                This will not be used if you return a response directly.\\n\\n                Read more about it in the\\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B3D0>, name: Annotated[Optional[str], Doc('\\n                Name for this *path operation*. Only used internally.\\n                ')] = None, callbacks: Annotated[Optional[List[starlette.routing.BaseRoute]], Doc(\"\\n                List of *path operations* that will be used as OpenAPI callbacks.\\n\\n                This is only for OpenAPI documentation, the callbacks won't be used\\n                directly.\\n\\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\\n\\n                Read more about it in the\\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\\n                \")] = None, openapi_extra: Annotated[Optional[Dict[str, Any]], Doc('\\n                Extra metadata to be included in the OpenAPI schema for this *path\\n                operation*.\\n\\n                Read more about it in the\\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\\n                ')] = None, generate_unique_id_function: Annotated[Callable[[fastapi.routing.APIRoute], str], Doc('\\n                Customize the function used to generate unique IDs for the *path\\n                operations* shown in the generated OpenAPI.\\n\\n                This is particularly useful when automatically generating clients or\\n                SDKs for your API.\\n\\n                Read more about it in the\\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\\n                ')] = <fastapi.datastructures.DefaultPlaceholder object at 0x0000023E9A27B450>) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "url_path_for",
              "doc": null,
              "signature": "(self, name: 'str', /, **path_params: 'Any') -> 'URLPath'"
            },
            {
              "name": "websocket",
              "doc": "Decorate a WebSocket function.\n\nRead more about it in the\n[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n\n**Example**\n\n```python\nfrom fastapi import FastAPI, WebSocket\n\napp = FastAPI()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(websocket: WebSocket):\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        await websocket.send_text(f\"Message text was: {data}\")\n```",
              "signature": "(self, path: typing.Annotated[str, Doc('\\n                WebSocket path.\\n                ')], name: Annotated[Optional[str], Doc('\\n                A name for the WebSocket. Only used internally.\\n                ')] = None, *, dependencies: Annotated[Optional[Sequence[fastapi.params.Depends]], Doc('\\n                A list of dependencies (using `Depends()`) to be used for this\\n                WebSocket.\\n\\n                Read more about it in the\\n                [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\\n                ')] = None) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            },
            {
              "name": "websocket_route",
              "doc": "We no longer document this decorator style API, and its usage is discouraged.\nInstead you should use the following approach:\n\n>>> routes = [WebSocketRoute(path, endpoint=...), ...]\n>>> app = Starlette(routes=routes)",
              "signature": "(self, path: str, name: Optional[str] = None) -> Callable[[~DecoratedCallable], ~DecoratedCallable]"
            }
          ]
        },
        {
          "name": "HTTPException",
          "doc": "An HTTP exception you can raise in your own code to show errors to the client.\n\nThis is for client errors, invalid authentication, invalid data, etc. Not for server\nerrors in your code.\n\nRead more about it in the\n[FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).\n\n## Example\n\n```python\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\nitems = {\"foo\": \"The Foo Wrestlers\"}\n\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: str):\n    if item_id not in items:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return {\"item\": items[item_id]}\n```",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, status_code: typing.Annotated[int, Doc('\\n                HTTP status code to send to the client.\\n                ')], detail: Annotated[Any, Doc('\\n                Any data to be sent to the client in the `detail` key of the JSON\\n                response.\\n                ')] = None, headers: Annotated[Optional[Dict[str, str]], Doc('\\n                Any headers to send to the client in the response.\\n                ')] = None) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        },
        {
          "name": "Request",
          "doc": "A base class for incoming HTTP connections, that is used to provide\nany functionality that is common to both `Request` and `WebSocket`.",
          "functions": [
            {
              "name": "__contains__",
              "doc": null,
              "signature": "(self, key)"
            },
            {
              "name": "__getitem__",
              "doc": null,
              "signature": "(self, key: 'str') -> 'Any'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, scope: 'Scope', receive: 'Receive' = <function empty_receive at 0x0000023E9A0D3880>, send: 'Send' = <function empty_send at 0x0000023E9A1DF880>)"
            },
            {
              "name": "__iter__",
              "doc": null,
              "signature": "(self) -> 'Iterator[str]'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "_get_form",
              "doc": null,
              "signature": "(self, *, max_files: 'int | float' = 1000, max_fields: 'int | float' = 1000, max_part_size: 'int' = 1048576) -> 'FormData'"
            },
            {
              "name": "body",
              "doc": null,
              "signature": "(self) -> 'bytes'"
            },
            {
              "name": "close",
              "doc": null,
              "signature": "(self) -> 'None'"
            },
            {
              "name": "form",
              "doc": null,
              "signature": "(self, *, max_files: 'int | float' = 1000, max_fields: 'int | float' = 1000, max_part_size: 'int' = 1048576) -> 'AwaitableOrContextManager[FormData]'"
            },
            {
              "name": "get",
              "doc": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.",
              "signature": "(self, key, default=None)"
            },
            {
              "name": "is_disconnected",
              "doc": null,
              "signature": "(self) -> 'bool'"
            },
            {
              "name": "items",
              "doc": "D.items() -> a set-like object providing a view on D's items",
              "signature": "(self)"
            },
            {
              "name": "json",
              "doc": null,
              "signature": "(self) -> 'Any'"
            },
            {
              "name": "keys",
              "doc": "D.keys() -> a set-like object providing a view on D's keys",
              "signature": "(self)"
            },
            {
              "name": "send_push_promise",
              "doc": null,
              "signature": "(self, path: 'str') -> 'None'"
            },
            {
              "name": "stream",
              "doc": null,
              "signature": "(self) -> 'AsyncGenerator[bytes, None]'"
            },
            {
              "name": "url_for",
              "doc": null,
              "signature": "(self, name: 'str', /, **path_params: 'Any') -> 'URL'"
            },
            {
              "name": "values",
              "doc": "D.values() -> an object providing a view on D's values",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "Response",
          "doc": null,
          "functions": [
            {
              "name": "__call__",
              "doc": "Call self as a function.",
              "signature": "(self, scope: 'Scope', receive: 'Receive', send: 'Send') -> 'None'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, content: 'Any' = None, status_code: 'int' = 200, headers: 'Mapping[str, str] | None' = None, media_type: 'str | None' = None, background: 'BackgroundTask | None' = None) -> 'None'"
            },
            {
              "name": "delete_cookie",
              "doc": null,
              "signature": "(self, key: 'str', path: 'str' = '/', domain: 'str | None' = None, secure: 'bool' = False, httponly: 'bool' = False, samesite: \"Literal['lax', 'strict', 'none'] | None\" = 'lax') -> 'None'"
            },
            {
              "name": "init_headers",
              "doc": null,
              "signature": "(self, headers: 'Mapping[str, str] | None' = None) -> 'None'"
            },
            {
              "name": "render",
              "doc": null,
              "signature": "(self, content: 'Any') -> 'bytes | memoryview'"
            },
            {
              "name": "set_cookie",
              "doc": null,
              "signature": "(self, key: 'str', value: 'str' = '', max_age: 'int | None' = None, expires: 'datetime | str | int | None' = None, path: 'str | None' = '/', domain: 'str | None' = None, secure: 'bool' = False, httponly: 'bool' = False, samesite: \"Literal['lax', 'strict', 'none'] | None\" = 'lax', partitioned: 'bool' = False) -> 'None'"
            }
          ]
        },
        {
          "name": "UploadFile",
          "doc": "A file uploaded in a request.\n\nDefine it as a *path operation function* (or dependency) parameter.\n\nIf you are using a regular `def` function, you can use the `upload_file.file`\nattribute to access the raw standard Python file (blocking, not async), useful and\nneeded for non-async code.\n\nRead more about it in the\n[FastAPI docs for Request Files](https://fastapi.tiangolo.com/tutorial/request-files/).\n\n## Example\n\n```python\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, File, UploadFile\n\napp = FastAPI()\n\n\n@app.post(\"/files/\")\nasync def create_file(file: Annotated[bytes, File()]):\n    return {\"file_size\": len(file)}\n\n\n@app.post(\"/uploadfile/\")\nasync def create_upload_file(file: UploadFile):\n    return {\"filename\": file.filename}\n```",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, file: 'BinaryIO', *, size: 'int | None' = None, filename: 'str | None' = None, headers: 'Headers | None' = None) -> 'None'"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "_will_roll",
              "doc": null,
              "signature": "(self, size_to_add: 'int') -> 'bool'"
            },
            {
              "name": "close",
              "doc": "Close the file.\n\nTo be awaitable, compatible with async, this is run in threadpool.",
              "signature": "(self) -> None"
            },
            {
              "name": "read",
              "doc": "Read some bytes from the file.\n\nTo be awaitable, compatible with async, this is run in threadpool.",
              "signature": "(self, size: typing.Annotated[int, Doc('\\n                The number of bytes to read from the file.\\n                ')] = -1) -> bytes"
            },
            {
              "name": "seek",
              "doc": "Move to a position in the file.\n\nAny next read or write will be done from that position.\n\nTo be awaitable, compatible with async, this is run in threadpool.",
              "signature": "(self, offset: typing.Annotated[int, Doc('\\n                The position in bytes to seek to in the file.\\n                ')]) -> None"
            },
            {
              "name": "write",
              "doc": "Write some bytes to the file.\n\nYou normally wouldn't use this from a file you read in a request.\n\nTo be awaitable, compatible with async, this is run in threadpool.",
              "signature": "(self, data: typing.Annotated[bytes, Doc('\\n                The bytes to write to the file.\\n                ')]) -> None"
            }
          ]
        },
        {
          "name": "WebSocket",
          "doc": "A base class for incoming HTTP connections, that is used to provide\nany functionality that is common to both `Request` and `WebSocket`.",
          "functions": [
            {
              "name": "__contains__",
              "doc": null,
              "signature": "(self, key)"
            },
            {
              "name": "__getitem__",
              "doc": null,
              "signature": "(self, key: 'str') -> 'Any'"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, scope: 'Scope', receive: 'Receive', send: 'Send') -> 'None'"
            },
            {
              "name": "__iter__",
              "doc": null,
              "signature": "(self) -> 'Iterator[str]'"
            },
            {
              "name": "__len__",
              "doc": null,
              "signature": "(self) -> 'int'"
            },
            {
              "name": "_raise_on_disconnect",
              "doc": null,
              "signature": "(self, message: 'Message') -> 'None'"
            },
            {
              "name": "accept",
              "doc": null,
              "signature": "(self, subprotocol: 'str | None' = None, headers: 'Iterable[tuple[bytes, bytes]] | None' = None) -> 'None'"
            },
            {
              "name": "close",
              "doc": null,
              "signature": "(self, code: 'int' = 1000, reason: 'str | None' = None) -> 'None'"
            },
            {
              "name": "get",
              "doc": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.",
              "signature": "(self, key, default=None)"
            },
            {
              "name": "items",
              "doc": "D.items() -> a set-like object providing a view on D's items",
              "signature": "(self)"
            },
            {
              "name": "iter_bytes",
              "doc": null,
              "signature": "(self) -> 'AsyncIterator[bytes]'"
            },
            {
              "name": "iter_json",
              "doc": null,
              "signature": "(self) -> 'AsyncIterator[Any]'"
            },
            {
              "name": "iter_text",
              "doc": null,
              "signature": "(self) -> 'AsyncIterator[str]'"
            },
            {
              "name": "keys",
              "doc": "D.keys() -> a set-like object providing a view on D's keys",
              "signature": "(self)"
            },
            {
              "name": "receive",
              "doc": "Receive ASGI websocket messages, ensuring valid state transitions.",
              "signature": "(self) -> 'Message'"
            },
            {
              "name": "receive_bytes",
              "doc": null,
              "signature": "(self) -> 'bytes'"
            },
            {
              "name": "receive_json",
              "doc": null,
              "signature": "(self, mode: 'str' = 'text') -> 'Any'"
            },
            {
              "name": "receive_text",
              "doc": null,
              "signature": "(self) -> 'str'"
            },
            {
              "name": "send",
              "doc": "Send ASGI websocket messages, ensuring valid state transitions.",
              "signature": "(self, message: 'Message') -> 'None'"
            },
            {
              "name": "send_bytes",
              "doc": null,
              "signature": "(self, data: 'bytes') -> 'None'"
            },
            {
              "name": "send_denial_response",
              "doc": null,
              "signature": "(self, response: 'Response') -> 'None'"
            },
            {
              "name": "send_json",
              "doc": null,
              "signature": "(self, data: 'Any', mode: 'str' = 'text') -> 'None'"
            },
            {
              "name": "send_text",
              "doc": null,
              "signature": "(self, data: 'str') -> 'None'"
            },
            {
              "name": "url_for",
              "doc": null,
              "signature": "(self, name: 'str', /, **path_params: 'Any') -> 'URL'"
            },
            {
              "name": "values",
              "doc": "D.values() -> an object providing a view on D's values",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "WebSocketDisconnect",
          "doc": "Common base class for all non-exit exceptions.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, code: 'int' = 1000, reason: 'str | None' = None) -> 'None'"
            }
          ]
        },
        {
          "name": "WebSocketException",
          "doc": "A WebSocket exception you can raise in your own code to show errors to the client.\n\nThis is for client errors, invalid authentication, invalid data, etc. Not for server\nerrors in your code.\n\nRead more about it in the\n[FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n\n## Example\n\n```python\nfrom typing import Annotated\n\nfrom fastapi import (\n    Cookie,\n    FastAPI,\n    WebSocket,\n    WebSocketException,\n    status,\n)\n\napp = FastAPI()\n\n@app.websocket(\"/items/{item_id}/ws\")\nasync def websocket_endpoint(\n    *,\n    websocket: WebSocket,\n    session: Annotated[str | None, Cookie()] = None,\n    item_id: str,\n):\n    if session is None:\n        raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        await websocket.send_text(f\"Session cookie is: {session}\")\n        await websocket.send_text(f\"Message text was: {data}, for item ID: {item_id}\")\n```",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, code: typing.Annotated[int, Doc('\\n                A closing code from the\\n                [valid codes defined in the specification](https://datatracker.ietf.org/doc/html/rfc6455#section-7.4.1).\\n                ')], reason: Annotated[Optional[str], Doc('\\n                The reason to close the WebSocket connection.\\n\\n                It is UTF-8-encoded data. The interpretation of the reason is up to the\\n                application, it is not specified by the WebSocket specification.\\n\\n                It could contain text that could be human-readable or interpretable\\n                by the client code, etc.\\n                ')] = None) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> 'str'"
            },
            {
              "name": "__str__",
              "doc": "Return str(self).",
              "signature": "(self) -> 'str'"
            }
          ]
        }
      ]
    }
  },
  {
    "package": "starlette",
    "base": {
      "functions": [],
      "classes": []
    }
  },
  {
    "package": "annotated_types",
    "base": {
      "functions": [
        {
          "name": "dataclass",
          "doc": "Add dunder methods based on the fields defined in the class.\n\nExamines PEP 526 __annotations__ to determine fields.\n\nIf init is true, an __init__() method is added to the class. If repr\nis true, a __repr__() method is added. If order is true, rich\ncomparison dunder methods are added. If unsafe_hash is true, a\n__hash__() method is added. If frozen is true, fields may not be\nassigned to after instance creation. If match_args is true, the\n__match_args__ tuple is added. If kw_only is true, then by default\nall fields are keyword-only. If slots is true, a new class with a\n__slots__ attribute is returned.",
          "signature": "(cls=None, /, *, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False, weakref_slot=False)"
        },
        {
          "name": "doc",
          "doc": "Add documentation to a type annotation inside of Annotated.\n\nFor example:\n\n>>> def hi(name: Annotated[int, doc(\"The name of the user\")]) -> None: ...",
          "signature": "(documentation: str) -> annotated_types.DocInfo"
        },
        {
          "name": "runtime_checkable",
          "doc": "Mark a protocol class as a runtime protocol.\n\nSuch protocol can be used with isinstance() and issubclass().\nRaise TypeError if applied to a non-protocol class.\nThis allows a simple-minded structural check very similar to\none trick ponies in collections.abc such as Iterable.\n\nFor example::\n\n    @runtime_checkable\n    class Closable(Protocol):\n        def close(self): ...\n\n    assert isinstance(open('/some/file'), Closable)\n\nWarning: this will check only the presence of the required methods,\nnot their type signatures!",
          "signature": "(cls)"
        }
      ],
      "classes": [
        {
          "name": "Annotated",
          "doc": "Add context-specific metadata to a type.\n\nExample: Annotated[int, runtime_check.Unsigned] indicates to the\nhypothetical runtime_check module that this type is an unsigned int.\nEvery other consumer of this type can ignore this metadata and treat\nthis type as int.\n\nThe first argument to Annotated must be a valid type.\n\nDetails:\n\n- It's an error to call `Annotated` with less than two arguments.\n- Access the metadata via the ``__metadata__`` attribute::\n\n    assert Annotated[int, '$'].__metadata__ == ('$',)\n\n- Nested Annotated types are flattened::\n\n    assert Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n- Instantiating an annotated type is equivalent to instantiating the\nunderlying type::\n\n    assert Annotated[C, Ann1](5) == C(5)\n\n- Annotated can be used as a generic type alias::\n\n    Optimized: TypeAlias = Annotated[T, runtime.Optimize()]\n    assert Optimized[int] == Annotated[int, runtime.Optimize()]\n\n    OptimizedList: TypeAlias = Annotated[list[T], runtime.Optimize()]\n    assert OptimizedList[int] == Annotated[list[int], runtime.Optimize()]\n\n- Annotated cannot be used with an unpacked TypeVarTuple::\n\n    Variadic: TypeAlias = Annotated[*Ts, Ann1]  # NOT valid\n\n  This would be equivalent to::\n\n    Annotated[T1, T2, T3, ..., Ann1]\n\n  where T1, T2 etc. are TypeVars, which would be invalid, because\n  only one type should be passed to Annotated.",
          "functions": []
        },
        {
          "name": "Any",
          "doc": "Special type indicating an unconstrained type.\n\n- Any is compatible with every type.\n- Any assumed to have all methods.\n- All values assumed to be instances of Any.\n\nNote that all the above statements are true from the point of view of\nstatic type checkers. At runtime, Any should not be used with instance\nchecks.",
          "functions": []
        },
        {
          "name": "BaseMetadata",
          "doc": "Base class for all metadata.\n\nThis exists mainly so that implementers\ncan do `isinstance(..., BaseMetadata)` while traversing field annotations.",
          "functions": []
        },
        {
          "name": "DocInfo",
          "doc": "\"\nThe return value of doc(), mainly to be used by tools that want to extract the\nAnnotated documentation at runtime.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, documentation: str) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "ellipsis",
          "doc": null,
          "functions": []
        },
        {
          "name": "Ge",
          "doc": "Ge(ge=x) implies that the value must be greater than or equal to x.\n\nIt can be used with any type that supports the ``>=`` operator,\nincluding numbers, dates and times, strings, sets, and so on.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, ge: annotated_types.SupportsGe) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "GroupedMetadata",
          "doc": "A grouping of multiple objects, like typing.Unpack.\n\n`GroupedMetadata` on its own is not metadata and has no meaning.\nAll of the constraints and metadata should be fully expressable\nin terms of the `BaseMetadata`'s returned by `GroupedMetadata.__iter__()`.\n\nConcrete implementations should override `GroupedMetadata.__iter__()`\nto add their own metadata.\nFor example:\n\n>>> @dataclass\n>>> class Field(GroupedMetadata):\n>>>     gt: float | None = None\n>>>     description: str | None = None\n...\n>>>     def __iter__(self) -> Iterable[object]:\n>>>         if self.gt is not None:\n>>>             yield Gt(self.gt)\n>>>         if self.description is not None:\n>>>             yield Description(self.gt)\n\nAlso see the implementation of `Interval` below for an example.\n\nParsers should recognize this and unpack it so that it can be used\nboth with and without unpacking:\n\n- `Annotated[int, Field(...)]` (parser must unpack Field)\n- `Annotated[int, *Field(...)]` (PEP-646)",
          "functions": [
            {
              "name": "__iter__",
              "doc": null,
              "signature": "(self) -> Iterator[object]"
            }
          ]
        },
        {
          "name": "Gt",
          "doc": "Gt(gt=x) implies that the value must be greater than x.\n\nIt can be used with any type that supports the ``>`` operator,\nincluding numbers, dates and times, strings, sets, and so on.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, gt: annotated_types.SupportsGt) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "Interval",
          "doc": "Interval can express inclusive or exclusive bounds with a single object.\n\nIt accepts keyword arguments ``gt``, ``ge``, ``lt``, and/or ``le``, which\nare interpreted the same way as the single-bound constraints.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, *, gt: Optional[annotated_types.SupportsGt] = None, ge: Optional[annotated_types.SupportsGe] = None, lt: Optional[annotated_types.SupportsLt] = None, le: Optional[annotated_types.SupportsLe] = None) -> None"
            },
            {
              "name": "__iter__",
              "doc": "Unpack an Interval into zero or more single-bounds.",
              "signature": "(self) -> Iterator[annotated_types.BaseMetadata]"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "Le",
          "doc": "Le(le=x) implies that the value must be less than or equal to x.\n\nIt can be used with any type that supports the ``<=`` operator,\nincluding numbers, dates and times, strings, sets, and so on.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, le: annotated_types.SupportsLe) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "Len",
          "doc": "Len() implies that ``min_length <= len(value) <= max_length``.\n\nUpper bound may be omitted or ``None`` to indicate no upper length bound.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, min_length: typing.Annotated[int, Ge(ge=0)] = 0, max_length: Optional[Annotated[int, Ge(ge=0)]] = None) -> None"
            },
            {
              "name": "__iter__",
              "doc": "Unpack a Len into zone or more single-bounds.",
              "signature": "(self) -> Iterator[annotated_types.BaseMetadata]"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "Lt",
          "doc": "Lt(lt=x) implies that the value must be less than x.\n\nIt can be used with any type that supports the ``<`` operator,\nincluding numbers, dates and times, strings, sets, and so on.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, lt: annotated_types.SupportsLt) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "MaxLen",
          "doc": "MaxLen() implies maximum inclusive length,\ne.g. ``len(value) <= max_length``.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, max_length: typing.Annotated[int, Ge(ge=0)]) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "MinLen",
          "doc": "MinLen() implies minimum inclusive length,\ne.g. ``len(value) >= min_length``.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, min_length: typing.Annotated[int, Ge(ge=0)]) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "MultipleOf",
          "doc": "MultipleOf(multiple_of=x) might be interpreted in two ways:\n\n1. Python semantics, implying ``value % multiple_of == 0``, or\n2. JSONschema semantics, where ``int(value / multiple_of) == value / multiple_of``\n\nWe encourage users to be aware of these two common interpretations,\nand libraries to carefully document which they implement.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, multiple_of: Union[annotated_types.SupportsDiv, annotated_types.SupportsMod]) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "Not",
          "doc": "Not(func: Callable[[Any], bool])",
          "functions": [
            {
              "name": "__call__",
              "doc": "Call self as a function.",
              "signature": "(self, _Not__v: Any) -> bool"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, func: Callable[[Any], bool]) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "Predicate",
          "doc": "``Predicate(func: Callable)`` implies `func(value)` is truthy for valid values.\n\nUsers should prefer statically inspectable metadata, but if you need the full\npower and flexibility of arbitrary runtime predicates... here it is.\n\nWe provide a few predefined predicates for common string constraints:\n``IsLower = Predicate(str.islower)``, ``IsUpper = Predicate(str.isupper)``, and\n``IsDigits = Predicate(str.isdigit)``. Users are encouraged to use methods which\ncan be given special handling, and avoid indirection like ``lambda s: s.lower()``.\n\nSome libraries might have special logic to handle certain predicates, e.g. by\nchecking for `str.isdigit` and using its presence to both call custom logic to\nenforce digit-only strings, and customise some generated external schema.\n\nWe do not specify what behaviour should be expected for predicates that raise\nan exception.  For example `Annotated[int, Predicate(str.isdigit)]` might silently\nskip invalid constraints, or statically raise an error; or it might try calling it\nand then propagate or discard the resulting exception.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, func: Callable[[Any], bool]) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self) -> str"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "Protocol",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": []
        },
        {
          "name": "SupportsDiv",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": [
            {
              "name": "__div__",
              "doc": null,
              "signature": "(self: ~T, _SupportsDiv__other: ~T) -> ~T"
            }
          ]
        },
        {
          "name": "SupportsFloat",
          "doc": "An ABC with one abstract method __float__.",
          "functions": []
        },
        {
          "name": "SupportsGe",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": [
            {
              "name": "__ge__",
              "doc": "Return self>=value.",
              "signature": "(self: ~T, _SupportsGe__other: ~T) -> bool"
            }
          ]
        },
        {
          "name": "SupportsGt",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": [
            {
              "name": "__gt__",
              "doc": "Return self>value.",
              "signature": "(self: ~T, _SupportsGt__other: ~T) -> bool"
            }
          ]
        },
        {
          "name": "SupportsIndex",
          "doc": "An ABC with one abstract method __index__.",
          "functions": []
        },
        {
          "name": "SupportsLe",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": [
            {
              "name": "__le__",
              "doc": "Return self<=value.",
              "signature": "(self: ~T, _SupportsLe__other: ~T) -> bool"
            }
          ]
        },
        {
          "name": "SupportsLt",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": [
            {
              "name": "__lt__",
              "doc": "Return self<value.",
              "signature": "(self: ~T, _SupportsLt__other: ~T) -> bool"
            }
          ]
        },
        {
          "name": "SupportsMod",
          "doc": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
          "functions": [
            {
              "name": "__mod__",
              "doc": null,
              "signature": "(self: ~T, _SupportsMod__other: ~T) -> ~T"
            }
          ]
        },
        {
          "name": "Timezone",
          "doc": "Timezone(tz=...) requires a datetime to be aware (or ``tz=None``, naive).\n\n``Annotated[datetime, Timezone(None)]`` must be a naive datetime.\n``Timezone[...]`` (the ellipsis literal) expresses that the datetime must be\ntz-aware but any timezone is allowed.\n\nYou may also pass a specific timezone string or tzinfo object such as\n``Timezone(timezone.utc)`` or ``Timezone(\"Africa/Abidjan\")`` to express that\nyou only allow a specific timezone, though we note that this is often\na symptom of poor design.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, tz: Union[str, datetime.tzinfo, ellipsis, NoneType]) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "TypeVar",
          "doc": "Type variable.\n\nUsage::\n\n  T = TypeVar('T')  # Can be anything\n  A = TypeVar('A', str, bytes)  # Must be str or bytes\n\nType variables exist primarily for the benefit of static type\ncheckers.  They serve as the parameters for generic types as well\nas for generic function definitions.  See class Generic for more\ninformation on generic types.  Generic functions work as follows:\n\n  def repeat(x: T, n: int) -> List[T]:\n      '''Return a list containing n references to x.'''\n      return [x]*n\n\n  def longest(x: A, y: A) -> A:\n      '''Return the longest of two strings.'''\n      return x if len(x) >= len(y) else y\n\nThe latter example's signature is essentially the overloading\nof (str, str) -> str and (bytes, bytes) -> bytes.  Also note\nthat if the arguments are instances of some subclass of str,\nthe return type is still plain str.\n\nAt runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.\n\nType variables defined with covariant=True or contravariant=True\ncan be used to declare covariant or contravariant generic types.\nSee PEP 484 for more details. By default generic types are invariant\nin all type variables.\n\nType variables can be introspected. e.g.:\n\n  T.__name__ == 'T'\n  T.__constraints__ == ()\n  T.__covariant__ == False\n  T.__contravariant__ = False\n  A.__constraints__ == (str, bytes)\n\nNote that only type variables defined in global scope can be pickled.",
          "functions": []
        },
        {
          "name": "Unit",
          "doc": "Indicates that the value is a physical quantity with the specified unit.\n\nIt is intended for usage with numeric types, where the value represents the\nmagnitude of the quantity. For example, ``distance: Annotated[float, Unit('m')]``\nor ``speed: Annotated[float, Unit('m/s')]``.\n\nInterpretation of the unit string is left to the discretion of the consumer.\nIt is suggested to follow conventions established by python libraries that work\nwith physical quantities, such as\n\n- ``pint`` : <https://pint.readthedocs.io/en/stable/>\n- ``astropy.units``: <https://docs.astropy.org/en/stable/units/>\n\nFor indicating a quantity with a certain dimensionality but without a specific unit\nit is recommended to use square brackets, e.g. `Annotated[float, Unit('[time]')]`.\nNote, however, ``annotated_types`` itself makes no use of the unit string.",
          "functions": [
            {
              "name": "__delattr__",
              "doc": "Implement delattr(self, name).",
              "signature": "(self, name)"
            },
            {
              "name": "__eq__",
              "doc": "Return self==value.",
              "signature": "(self, other)"
            },
            {
              "name": "__hash__",
              "doc": "Return hash(self).",
              "signature": "(self)"
            },
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, unit: str) -> None"
            },
            {
              "name": "__repr__",
              "doc": "Return repr(self).",
              "signature": "(self)"
            },
            {
              "name": "__setattr__",
              "doc": "Implement setattr(self, name, value).",
              "signature": "(self, name, value)"
            }
          ]
        },
        {
          "name": "tzinfo",
          "doc": "Abstract base class for time zone info objects.",
          "functions": []
        }
      ]
    }
  },
  {
    "package": "pyasn1",
    "base": {
      "functions": [],
      "classes": []
    }
  },
  {
    "package": "colorama",
    "base": {
      "functions": [
        {
          "name": "colorama_text",
          "doc": null,
          "signature": "(*args, **kwargs)"
        },
        {
          "name": "deinit",
          "doc": null,
          "signature": "()"
        },
        {
          "name": "init",
          "doc": null,
          "signature": "(autoreset=False, convert=None, strip=None, wrap=True)"
        },
        {
          "name": "just_fix_windows_console",
          "doc": null,
          "signature": "()"
        },
        {
          "name": "reinit",
          "doc": null,
          "signature": "()"
        }
      ],
      "classes": [
        {
          "name": "AnsiToWin32",
          "doc": "Implements a 'write()' method which, on Windows, will strip ANSI character\nsequences from the text, and if outputting to a tty, will convert them into\nwin32 function calls.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, wrapped, convert=None, strip=None, autoreset=False)"
            },
            {
              "name": "call_win32",
              "doc": null,
              "signature": "(self, command, params)"
            },
            {
              "name": "convert_ansi",
              "doc": null,
              "signature": "(self, paramstring, command)"
            },
            {
              "name": "convert_osc",
              "doc": null,
              "signature": "(self, text)"
            },
            {
              "name": "extract_params",
              "doc": null,
              "signature": "(self, command, paramstring)"
            },
            {
              "name": "flush",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "get_win32_calls",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "reset_all",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "should_wrap",
              "doc": "True if this class is actually needed. If false, then the output\nstream will not be affected, nor will win32 calls be issued, so\nwrapping stdout is not actually required. This will generally be\nFalse on non-Windows platforms, unless optional functionality like\nautoreset has been requested using kwargs to init()",
              "signature": "(self)"
            },
            {
              "name": "write",
              "doc": null,
              "signature": "(self, text)"
            },
            {
              "name": "write_and_convert",
              "doc": "Write the given text to our wrapped stream, stripping any ANSI\nsequences from the text, and optionally converting them into win32\ncalls.",
              "signature": "(self, text)"
            },
            {
              "name": "write_plain_text",
              "doc": null,
              "signature": "(self, text, start, end)"
            }
          ]
        }
      ]
    }
  },
  {
    "package": "binaryornot",
    "base": {
      "functions": [],
      "classes": []
    }
  },
  {
    "package": "typing_inspection",
    "base": {
      "functions": [],
      "classes": []
    }
  },
  {
    "package": "setuptools",
    "base": {
      "functions": [
        {
          "name": "convert_path",
          "doc": "Return 'pathname' as a name that will work on the native filesystem,\ni.e. split it on '/' and put it back together again using the current\ndirectory separator.  Needed because filenames in the setup script are\nalways supplied in Unix style, and have to be converted to the local\nconvention before we can actually use them in the filesystem.  Raises\nValueError on non-Unix-ish systems if 'pathname' either starts or\nends with a slash.",
          "signature": "(pathname)"
        },
        {
          "name": "_find_all_simple",
          "doc": "Find all files under 'path'",
          "signature": "(path)"
        },
        {
          "name": "_install_setup_requires",
          "doc": null,
          "signature": "(attrs)"
        },
        {
          "name": "convert_path",
          "doc": "Return 'pathname' as a name that will work on the native filesystem,\ni.e. split it on '/' and put it back together again using the current\ndirectory separator.  Needed because filenames in the setup script are\nalways supplied in Unix style, and have to be converted to the local\nconvention before we can actually use them in the filesystem.  Raises\nValueError on non-Unix-ish systems if 'pathname' either starts or\nends with a slash.",
          "signature": "(pathname)"
        },
        {
          "name": "findall",
          "doc": "Find all files under 'dir' and return the list of full filenames.\nUnless dir is '.', return full filenames with dir prepended.",
          "signature": "(dir='.')"
        },
        {
          "name": "setup",
          "doc": "The gateway to the Distutils: do everything your setup script needs\nto do, in a highly flexible and user-driven way.  Briefly: create a\nDistribution instance; find and parse config files; parse the command\nline; run each Distutils command found there, customized by the options\nsupplied to 'setup()' (as keyword arguments), in config files, and on\nthe command line.\n\nThe Distribution instance might be an instance of a class supplied via\nthe 'distclass' keyword argument to 'setup'; if no such class is\nsupplied, then the Distribution class (in dist.py) is instantiated.\nAll other arguments to 'setup' (except for 'cmdclass') are used to set\nattributes of the Distribution instance.\n\nThe 'cmdclass' argument, if supplied, is a dictionary mapping command\nnames to command classes.  Each command encountered on the command line\nwill be turned into a command class, which is in turn instantiated; any\nclass found in 'cmdclass' is used in place of the default, which is\n(for command 'foo_bar') class 'foo_bar' in module\n'distutils.command.foo_bar'.  The command class must provide a\n'user_options' attribute which is a list of option specifiers for\n'distutils.fancy_getopt'.  Any command-line options between the current\nand the next command are used to set attributes of the current command\nobject.\n\nWhen the entire command-line has been successfully parsed, calls the\n'run()' method on each command object in turn.  This method will be\ndriven entirely by the Distribution object (which each command object\nhas a reference to, thanks to its constructor), and the\ncommand-specific options that became attributes of each command\nobject.",
          "signature": "(**attrs)"
        }
      ],
      "classes": [
        {
          "name": "Command",
          "doc": "Setuptools internal actions are organized using a *command design pattern*.\nThis means that each action (or group of closely related actions) executed during\nthe build should be implemented as a ``Command`` subclass.\n\nThese commands are abstractions and do not necessarily correspond to a command that\ncan (or should) be executed via a terminal, in a CLI fashion (although historically\nthey would).\n\nWhen creating a new command from scratch, custom defined classes **SHOULD** inherit\nfrom ``setuptools.Command`` and implement a few mandatory methods.\nBetween these mandatory methods, are listed:\n\n.. method:: initialize_options(self)\n\n    Set or (reset) all options/attributes/caches used by the command\n    to their default values. Note that these values may be overwritten during\n    the build.\n\n.. method:: finalize_options(self)\n\n    Set final values for all options/attributes used by the command.\n    Most of the time, each option/attribute/cache should only be set if it does not\n    have any value yet (e.g. ``if self.attr is None: self.attr = val``).\n\n.. method:: run(self)\n\n    Execute the actions intended by the command.\n    (Side effects **SHOULD** only take place when ``run`` is executed,\n    for example, creating new files or writing to the terminal output).\n\nA useful analogy for command classes is to think of them as subroutines with local\nvariables called \"options\".  The options are \"declared\" in ``initialize_options()``\nand \"defined\" (given their final values, aka \"finalized\") in ``finalize_options()``,\nboth of which must be defined by every command class. The \"body\" of the subroutine,\n(where it does all the work) is the ``run()`` method.\nBetween ``initialize_options()`` and ``finalize_options()``, ``setuptools`` may set\nthe values for options/attributes based on user's input (or circumstance),\nwhich means that the implementation should be careful to not overwrite values in\n``finalize_options`` unless necessary.\n\nPlease note that other commands (or other parts of setuptools) may also overwrite\nthe values of the command's options/attributes multiple times during the build\nprocess.\nTherefore it is important to consistently implement ``initialize_options()`` and\n``finalize_options()``. For example, all derived attributes (or attributes that\ndepend on the value of other attributes) **SHOULD** be recomputed in\n``finalize_options``.\n\nWhen overwriting existing commands, custom defined classes **MUST** abide by the\nsame APIs implemented by the original class. They also **SHOULD** inherit from the\noriginal class.",
          "functions": [
            {
              "name": "__getattr__",
              "doc": null,
              "signature": "(self, attr)"
            },
            {
              "name": "__init__",
              "doc": "Construct the command for dist, updating\nvars(self) with any keyword parameters.",
              "signature": "(self, dist, **kw)"
            },
            {
              "name": "_ensure_stringlike",
              "doc": null,
              "signature": "(self, option, what, default=None)"
            },
            {
              "name": "_ensure_tested_string",
              "doc": null,
              "signature": "(self, option, tester, what, error_fmt, default=None)"
            },
            {
              "name": "announce",
              "doc": "If the current verbosity level is of greater than or equal to\n'level' print 'msg' to stdout.",
              "signature": "(self, msg, level=1)"
            },
            {
              "name": "copy_file",
              "doc": "Copy a file respecting verbose, dry-run and force flags.  (The\nformer two default to whatever is in the Distribution object, and\nthe latter defaults to false for commands that don't define it.)",
              "signature": "(self, infile, outfile, preserve_mode=1, preserve_times=1, link=None, level=1)"
            },
            {
              "name": "copy_tree",
              "doc": "Copy an entire directory tree respecting verbose, dry-run,\nand force flags.",
              "signature": "(self, infile, outfile, preserve_mode=1, preserve_times=1, preserve_symlinks=0, level=1)"
            },
            {
              "name": "debug_print",
              "doc": "Print 'msg' to stdout if the global DEBUG (taken from the\nDISTUTILS_DEBUG environment variable) flag is true.",
              "signature": "(self, msg)"
            },
            {
              "name": "dump_options",
              "doc": null,
              "signature": "(self, header=None, indent='')"
            },
            {
              "name": "ensure_dirname",
              "doc": null,
              "signature": "(self, option)"
            },
            {
              "name": "ensure_filename",
              "doc": "Ensure that 'option' is the name of an existing file.",
              "signature": "(self, option)"
            },
            {
              "name": "ensure_finalized",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "ensure_string",
              "doc": "Ensure that 'option' is a string; if not defined, set it to\n'default'.",
              "signature": "(self, option, default=None)"
            },
            {
              "name": "ensure_string_list",
              "doc": "Ensure that 'option' is a list of strings.  If 'option' is\ncurrently a string, we split it either on /,\\s*/ or /\\s+/, so\n\"foo bar baz\", \"foo,bar,baz\", and \"foo,   bar baz\" all become\n[\"foo\", \"bar\", \"baz\"].\n\n..\n   TODO: This method seems to be similar to the one in ``distutils.cmd``\n   Probably it is just here for backward compatibility with old Python versions?\n\n:meta private:",
              "signature": "(self, option)"
            },
            {
              "name": "execute",
              "doc": null,
              "signature": "(self, func, args, msg=None, level=1)"
            },
            {
              "name": "finalize_options",
              "doc": "Set final values for all the options that this command supports.\nThis is always called as late as possible, ie.  after any option\nassignments from the command-line or from other commands have been\ndone.  Thus, this is the place to code option dependencies: if\n'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as\nlong as 'foo' still has the same value it was assigned in\n'initialize_options()'.\n\nThis method must be implemented by all command classes.",
              "signature": "(self)"
            },
            {
              "name": "get_command_name",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "get_finalized_command",
              "doc": "Wrapper around Distribution's 'get_command_obj()' method: find\n(create if necessary and 'create' is true) the command object for\n'command', call its 'ensure_finalized()' method, and return the\nfinalized command object.",
              "signature": "(self, command, create=1)"
            },
            {
              "name": "get_sub_commands",
              "doc": "Determine the sub-commands that are relevant in the current\ndistribution (ie., that need to be run).  This is based on the\n'sub_commands' class attribute: each tuple in that list may include\na method that we call to determine if the subcommand needs to be\nrun for the current distribution.  Return a list of command names.",
              "signature": "(self)"
            },
            {
              "name": "initialize_options",
              "doc": "Set default values for all the options that this command\nsupports.  Note that these defaults may be overridden by other\ncommands, by the setup script, by config files, or by the\ncommand-line.  Thus, this is not the place to code dependencies\nbetween options; generally, 'initialize_options()' implementations\nare just a bunch of \"self.foo = None\" assignments.\n\nThis method must be implemented by all command classes.",
              "signature": "(self)"
            },
            {
              "name": "make_archive",
              "doc": null,
              "signature": "(self, base_name, format, root_dir=None, base_dir=None, owner=None, group=None)"
            },
            {
              "name": "make_file",
              "doc": "Special case of 'execute()' for operations that process one or\nmore input files and generate one output file.  Works just like\n'execute()', except the operation is skipped and a different\nmessage printed if 'outfile' already exists and is newer than all\nfiles listed in 'infiles'.  If the command defined 'self.force',\nand it is true, then the command is unconditionally run -- does no\ntimestamp checks.",
              "signature": "(self, infiles, outfile, func, args, exec_msg=None, skip_msg=None, level=1)"
            },
            {
              "name": "mkpath",
              "doc": null,
              "signature": "(self, name, mode=511)"
            },
            {
              "name": "move_file",
              "doc": "Move a file respecting dry-run flag.",
              "signature": "(self, src, dst, level=1)"
            },
            {
              "name": "reinitialize_command",
              "doc": null,
              "signature": "(self, command, reinit_subcommands=0, **kw)"
            },
            {
              "name": "run",
              "doc": "A command's raison d'etre: carry out the action it exists to\nperform, controlled by the options initialized in\n'initialize_options()', customized by other commands, the setup\nscript, the command-line, and config files, and finalized in\n'finalize_options()'.  All terminal output and filesystem\ninteraction should be done by 'run()'.\n\nThis method must be implemented by all command classes.",
              "signature": "(self)"
            },
            {
              "name": "run_command",
              "doc": "Run some other command: uses the 'run_command()' method of\nDistribution, which creates and finalizes the command object if\nnecessary and then invokes its 'run()' method.",
              "signature": "(self, command)"
            },
            {
              "name": "set_undefined_options",
              "doc": "Set the values of any \"undefined\" options from corresponding\noption values in some other command object.  \"Undefined\" here means\n\"is None\", which is the convention used to indicate that an option\nhas not been changed between 'initialize_options()' and\n'finalize_options()'.  Usually called from 'finalize_options()' for\noptions that depend on some other command rather than another\noption of the same command.  'src_cmd' is the other command from\nwhich option values will be taken (a command object will be created\nfor it if necessary); the remaining arguments are\n'(src_option,dst_option)' tuples which mean \"take the value of\n'src_option' in the 'src_cmd' command object, and copy it to\n'dst_option' in the current command object\".",
              "signature": "(self, src_cmd, *option_pairs)"
            },
            {
              "name": "spawn",
              "doc": "Spawn an external command respecting dry-run flag.",
              "signature": "(self, cmd, search_path=1, level=1)"
            },
            {
              "name": "warn",
              "doc": null,
              "signature": "(self, msg)"
            }
          ]
        },
        {
          "name": "Distribution",
          "doc": "Distribution with support for tests and package data\n\nThis is an enhanced version of 'distutils.dist.Distribution' that\neffectively adds the following new optional keyword arguments to 'setup()':\n\n 'install_requires' -- a string or sequence of strings specifying project\n    versions that the distribution requires when installed, in the format\n    used by 'pkg_resources.require()'.  They will be installed\n    automatically when the package is installed.  If you wish to use\n    packages that are not available in PyPI, or want to give your users an\n    alternate download location, you can add a 'find_links' option to the\n    '[easy_install]' section of your project's 'setup.cfg' file, and then\n    setuptools will scan the listed web pages for links that satisfy the\n    requirements.\n\n 'extras_require' -- a dictionary mapping names of optional \"extras\" to the\n    additional requirement(s) that using those extras incurs. For example,\n    this::\n\n        extras_require = dict(reST = [\"docutils>=0.3\", \"reSTedit\"])\n\n    indicates that the distribution can optionally provide an extra\n    capability called \"reST\", but it can only be used if docutils and\n    reSTedit are installed.  If the user installs your package using\n    EasyInstall and requests one of your extras, the corresponding\n    additional requirements will be installed if needed.\n\n 'test_suite' -- the name of a test suite to run for the 'test' command.\n    If the user runs 'python setup.py test', the package will be installed,\n    and the named test suite will be run.  The format is the same as\n    would be used on a 'unittest.py' command line.  That is, it is the\n    dotted name of an object to import and call to generate a test suite.\n\n 'package_data' -- a dictionary mapping package names to lists of filenames\n    or globs to use to find data files contained in the named packages.\n    If the dictionary has filenames or globs listed under '\"\"' (the empty\n    string), those names will be searched for in every package, in addition\n    to any names for the specific package.  Data files found using these\n    names/globs will be installed along with the package, in the same\n    location as the package.  Note that globs are allowed to reference\n    the contents of non-package subdirectories, as long as you use '/' as\n    a path separator.  (Globs are automatically converted to\n    platform-specific paths at runtime.)\n\nIn addition to these new keywords, this class also has several new methods\nfor manipulating the distribution's contents.  For example, the 'include()'\nand 'exclude()' methods can be thought of as in-place add and subtract\ncommands that add or remove packages, modules, extensions, and so on from\nthe distribution.",
          "functions": [
            {
              "name": "__init__",
              "doc": "Construct a new Distribution instance: initialize all the\nattributes of a Distribution, and then use 'attrs' (a dictionary\nmapping attribute names to values) to assign some of those\nattributes their \"real\" values.  (Any attributes not mentioned in\n'attrs' will be assigned to some null value: 0, None, an empty list\nor dictionary, etc.)  Most importantly, initialize the\n'command_obj' attribute to the empty dictionary; this will be\nfilled in with real command objects by 'parse_command_line()'.",
              "signature": "(self, attrs=None)"
            },
            {
              "name": "_clean_req",
              "doc": "Given a Requirement, remove environment markers and return it.",
              "signature": "(self, req)"
            },
            {
              "name": "_convert_extras_requirements",
              "doc": "Convert requirements in `extras_require` of the form\n`\"extra\": [\"barbazquux; {marker}\"]` to\n`\"extra:{marker}\": [\"barbazquux\"]`.",
              "signature": "(self)"
            },
            {
              "name": "_exclude_misc",
              "doc": "Handle 'exclude()' for list/tuple attrs without a special handler",
              "signature": "(self, name, value)"
            },
            {
              "name": "_exclude_packages",
              "doc": null,
              "signature": "(self, packages)"
            },
            {
              "name": "_expand_patterns",
              "doc": ">>> list(Distribution._expand_patterns(['LICENSE']))\n['LICENSE']\n>>> list(Distribution._expand_patterns(['setup.cfg', 'LIC*']))\n['setup.cfg', 'LICENSE']",
              "signature": "(patterns)"
            },
            {
              "name": "_finalize_license_files",
              "doc": "Compute names of all license files which should be included.",
              "signature": "(self)"
            },
            {
              "name": "_finalize_requires",
              "doc": "Set `metadata.python_requires` and fix environment markers\nin `install_requires` and `extras_require`.",
              "signature": "(self)"
            },
            {
              "name": "_finalize_setup_keywords",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_gen_paths",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_get_project_config_files",
              "doc": "Add default file and split between INI and TOML",
              "signature": "(self, filenames)"
            },
            {
              "name": "_get_toplevel_options",
              "doc": "Return the non-display options recognized at the top level.\n\nThis includes options that are recognized *only* at the top\nlevel as well as options recognized for commands.",
              "signature": "(self)"
            },
            {
              "name": "_include_misc",
              "doc": "Handle 'include()' for list/tuple attrs without a special handler",
              "signature": "(self, name, value)"
            },
            {
              "name": "_move_install_requirements_markers",
              "doc": "Move requirements in `install_requires` that are using environment\nmarkers `extras_require`.",
              "signature": "(self)"
            },
            {
              "name": "_normalize_version",
              "doc": null,
              "signature": "(version)"
            },
            {
              "name": "_parse_command_opts",
              "doc": "Parse the command-line options for a single command.\n'parser' must be a FancyGetopt instance; 'args' must be the list\nof arguments, starting with the current command (whose options\nwe are about to parse).  Returns a new version of 'args' with\nthe next command at the front of the list; will be the empty\nlist if there are no more commands on the command line.  Returns\nNone if the user asked for help on this command.",
              "signature": "(self, parser, args)"
            },
            {
              "name": "_parse_config_files",
              "doc": "Adapted from distutils.dist.Distribution.parse_config_files,\nthis method provides the same functionality in subtly-improved\nways.",
              "signature": "(self, filenames=None)"
            },
            {
              "name": "_removed",
              "doc": "When removing an entry point, if metadata is loaded\nfrom an older version of Setuptools, that removed\nentry point will attempt to be loaded and will fail.\nSee #2765 for more details.",
              "signature": "(ep)"
            },
            {
              "name": "_set_command_options",
              "doc": "Set the options for 'command_obj' from 'option_dict'.  Basically\nthis means copying elements of a dictionary ('option_dict') to\nattributes of an instance ('command').\n\n'command_obj' must be a Command instance.  If 'option_dict' is not\nsupplied, uses the standard option dictionary for this command\n(from 'self.command_options').\n\n(Adopted from distutils.dist.Distribution._set_command_options)",
              "signature": "(self, command_obj, option_dict=None)"
            },
            {
              "name": "_set_metadata_defaults",
              "doc": "Fill-in missing metadata fields not supported by distutils.\nSome fields may have been set by other tools (e.g. pbr).\nThose fields (vars(self.metadata)) take precedence to\nsupplied attrs.",
              "signature": "(self, attrs)"
            },
            {
              "name": "_setuptools_commands",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_show_help",
              "doc": "Show help for the setup script command-line in the form of\nseveral lists of command-line options.  'parser' should be a\nFancyGetopt instance; do not expect it to be returned in the\nsame state, as its option table will be reset to make it\ngenerate the correct help text.\n\nIf 'global_options' is true, lists the global options:\n--verbose, --dry-run, etc.  If 'display_options' is true, lists\nthe \"display-only\" options: --name, --version, etc.  Finally,\nlists per-command help for every command name or command class\nin 'commands'.",
              "signature": "(self, parser, global_options=1, display_options=1, commands=[])"
            },
            {
              "name": "_suffix_for",
              "doc": "For a requirement, return the 'extras_require' suffix for\nthat requirement.",
              "signature": "(req)"
            },
            {
              "name": "_validate_metadata",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_validate_version",
              "doc": null,
              "signature": "(version)"
            },
            {
              "name": "announce",
              "doc": null,
              "signature": "(self, msg, level=2)"
            },
            {
              "name": "dump_option_dicts",
              "doc": null,
              "signature": "(self, header=None, commands=None, indent='')"
            },
            {
              "name": "exclude",
              "doc": "Remove items from distribution that are named in keyword arguments\n\nFor example, 'dist.exclude(py_modules=[\"x\"])' would remove 'x' from\nthe distribution's 'py_modules' attribute.  Excluding packages uses\nthe 'exclude_package()' method, so all of the package's contained\npackages, modules, and extensions are also excluded.\n\nCurrently, this method only supports exclusion from attributes that are\nlists or tuples.  If you need to add support for excluding from other\nattributes in this or a subclass, you can add an '_exclude_X' method,\nwhere 'X' is the name of the attribute.  The method will be called with\nthe value passed to 'exclude()'.  So, 'dist.exclude(foo={\"bar\":\"baz\"})'\nwill try to call 'dist._exclude_foo({\"bar\":\"baz\"})', which can then\nhandle whatever special exclusion logic is needed.",
              "signature": "(self, **attrs)"
            },
            {
              "name": "exclude_package",
              "doc": "Remove packages, modules, and extensions in named package",
              "signature": "(self, package)"
            },
            {
              "name": "fetch_build_egg",
              "doc": "Fetch an egg needed for building",
              "signature": "(self, req)"
            },
            {
              "name": "fetch_build_eggs",
              "doc": "Resolve pre-setup requirements",
              "signature": "(self, requires)"
            },
            {
              "name": "finalize_options",
              "doc": "Allow plugins to apply arbitrary operations to the\ndistribution. Each hook may optionally define a 'order'\nto influence the order of execution. Smaller numbers\ngo first and the default is 0.",
              "signature": "(self)"
            },
            {
              "name": "find_config_files",
              "doc": "Find as many configuration files as should be processed for this\nplatform, and return a list of filenames in the order in which they\nshould be parsed.  The filenames returned are guaranteed to exist\n(modulo nasty race conditions).\n\nThere are multiple possible config files:\n- distutils.cfg in the Distutils installation directory (i.e.\n  where the top-level Distutils __inst__.py file lives)\n- a file in the user's home directory named .pydistutils.cfg\n  on Unix and pydistutils.cfg on Windows/Mac; may be disabled\n  with the ``--no-user-cfg`` option\n- setup.cfg in the current directory\n- a file named by an environment variable",
              "signature": "(self)"
            },
            {
              "name": "get_cmdline_options",
              "doc": "Return a '{cmd: {opt:val}}' map of all command-line options\n\nOption names are all long, but do not include the leading '--', and\ncontain dashes rather than underscores.  If the option doesn't take\nan argument (e.g. '--quiet'), the 'val' is 'None'.\n\nNote that options provided by config files are intentionally excluded.",
              "signature": "(self)"
            },
            {
              "name": "get_command_class",
              "doc": "Pluggable version of get_command_class()",
              "signature": "(self, command)"
            },
            {
              "name": "get_command_list",
              "doc": "Get a list of (command, description) tuples.\nThe list is divided into \"standard commands\" (listed in\ndistutils.command.__all__) and \"extra commands\" (mentioned in\nself.cmdclass, but not a standard command).  The descriptions come\nfrom the command class attribute 'description'.",
              "signature": "(self)"
            },
            {
              "name": "get_command_obj",
              "doc": "Return the command object for 'command'.  Normally this object\nis cached on a previous call to 'get_command_obj()'; if no command\nobject for 'command' is in the cache, then we either create and\nreturn it (if 'create' is true) or return None.",
              "signature": "(self, command, create=1)"
            },
            {
              "name": "get_command_packages",
              "doc": "Return a list of packages from which commands are loaded.",
              "signature": "(self)"
            },
            {
              "name": "get_egg_cache_dir",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "get_option_dict",
              "doc": "Get the option dictionary for a given command.  If that\ncommand's option dictionary hasn't been created yet, then create it\nand return the new dictionary; otherwise, return the existing\noption dictionary.",
              "signature": "(self, command)"
            },
            {
              "name": "handle_display_options",
              "doc": "If there were any non-global \"display-only\" options\n(--help-commands or the metadata display options) on the command\nline, display the requested info and return true; else return\nfalse.",
              "signature": "(self, option_order)"
            },
            {
              "name": "has_c_libraries",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "has_contents_for",
              "doc": "Return true if 'exclude_package(package)' would do something",
              "signature": "(self, package)"
            },
            {
              "name": "has_data_files",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "has_ext_modules",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "has_headers",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "has_modules",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "has_pure_modules",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "has_scripts",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "include",
              "doc": "Add items to distribution that are named in keyword arguments\n\nFor example, 'dist.include(py_modules=[\"x\"])' would add 'x' to\nthe distribution's 'py_modules' attribute, if it was not already\nthere.\n\nCurrently, this method only supports inclusion for attributes that are\nlists or tuples.  If you need to add support for adding to other\nattributes in this or a subclass, you can add an '_include_X' method,\nwhere 'X' is the name of the attribute.  The method will be called with\nthe value passed to 'include()'.  So, 'dist.include(foo={\"bar\":\"baz\"})'\nwill try to call 'dist._include_foo({\"bar\":\"baz\"})', which can then\nhandle whatever special inclusion logic is needed.",
              "signature": "(self, **attrs)"
            },
            {
              "name": "is_pure",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "iter_distribution_names",
              "doc": "Yield all packages, modules, and extension names in distribution",
              "signature": "(self)"
            },
            {
              "name": "make_option_lowercase",
              "doc": null,
              "signature": "(self, opt, section)"
            },
            {
              "name": "parse_command_line",
              "doc": "Parse the setup script's command line, taken from the\n'script_args' instance attribute (which defaults to 'sys.argv[1:]'\n-- see 'setup()' in core.py).  This list is first processed for\n\"global options\" -- options that set attributes of the Distribution\ninstance.  Then, it is alternately scanned for Distutils commands\nand options for that command.  Each new command terminates the\noptions for the previous command.  The allowed options for a\ncommand are determined by the 'user_options' attribute of the\ncommand class -- thus, we have to be able to load command classes\nin order to parse the command line.  Any error in that 'options'\nattribute raises DistutilsGetoptError; any error on the\ncommand-line raises DistutilsArgError.  If no Distutils commands\nwere found on the command line, raises DistutilsArgError.  Return\ntrue if command-line was successfully parsed and we should carry\non with executing commands; false if no errors but we shouldn't\nexecute commands (currently, this only happens if user asks for\nhelp).",
              "signature": "(self)"
            },
            {
              "name": "parse_config_files",
              "doc": "Parses configuration files from various levels\nand loads configuration.",
              "signature": "(self, filenames=None, ignore_option_errors=False)"
            },
            {
              "name": "patch_missing_pkg_info",
              "doc": null,
              "signature": "(self, attrs)"
            },
            {
              "name": "print_command_list",
              "doc": "Print a subset of the list of all commands -- used by\n'print_commands()'.",
              "signature": "(self, commands, header, max_length)"
            },
            {
              "name": "print_commands",
              "doc": "Print out a help message listing all available commands with a\ndescription of each.  The list is divided into \"standard commands\"\n(listed in distutils.command.__all__) and \"extra commands\"\n(mentioned in self.cmdclass, but not a standard command).  The\ndescriptions come from the command class attribute\n'description'.",
              "signature": "(self)"
            },
            {
              "name": "reinitialize_command",
              "doc": "Reinitializes a command to the state it was in when first\nreturned by 'get_command_obj()': ie., initialized but not yet\nfinalized.  This provides the opportunity to sneak option\nvalues in programmatically, overriding or supplementing\nuser-supplied values from the config files and command line.\nYou'll have to re-finalize the command object (by calling\n'finalize_options()' or 'ensure_finalized()') before using it for\nreal.\n\n'command' should be a command name (string) or command object.  If\n'reinit_subcommands' is true, also reinitializes the command's\nsub-commands, as declared by the 'sub_commands' class attribute (if\nit has one).  See the \"install\" command for an example.  Only\nreinitializes the sub-commands that actually matter, ie. those\nwhose test predicates return true.\n\nReturns the reinitialized command object.",
              "signature": "(self, command, reinit_subcommands=0)"
            },
            {
              "name": "run_command",
              "doc": "Do whatever it takes to run a command (including nothing at all,\nif the command has already been run).  Specifically: if we have\nalready created and run the command named by 'command', return\nsilently without doing anything.  If the command named by 'command'\ndoesn't even have a command object yet, create one.  Then invoke\n'run()' on that command object (or an existing one).",
              "signature": "(self, command)"
            },
            {
              "name": "run_commands",
              "doc": "Run each command that was seen on the setup script command line.\nUses the list of commands found and cache of command objects\ncreated by 'get_command_obj()'.",
              "signature": "(self)"
            },
            {
              "name": "warn_dash_deprecation",
              "doc": null,
              "signature": "(self, opt, section)"
            }
          ]
        },
        {
          "name": "DistutilsOptionError",
          "doc": "Syntactic/semantic errors in command options, such as use of\nmutually conflicting options, or inconsistent options,\nbadly-spelled values, etc.  No distinction is made between option\nvalues originating in the setup script, the command line, config\nfiles, or what-have-you -- but if we *know* something originated in\nthe setup script, we'll raise DistutilsSetupError instead.",
          "functions": []
        },
        {
          "name": "Extension",
          "doc": "Describes a single extension module.\n\nThis means that all source files will be compiled into a single binary file\n``<module path>.<suffix>`` (with ``<module path>`` derived from ``name`` and\n``<suffix>`` defined by one of the values in\n``importlib.machinery.EXTENSION_SUFFIXES``).\n\nIn the case ``.pyx`` files are passed as ``sources and`` ``Cython`` is **not**\ninstalled in the build environment, ``setuptools`` may also try to look for the\nequivalent ``.cpp`` or ``.c`` files.\n\n:arg str name:\n  the full name of the extension, including any packages -- ie.\n  *not* a filename or pathname, but Python dotted name\n\n:arg list[str] sources:\n  list of source filenames, relative to the distribution root\n  (where the setup script lives), in Unix form (slash-separated)\n  for portability.  Source files may be C, C++, SWIG (.i),\n  platform-specific resource files, or whatever else is recognized\n  by the \"build_ext\" command as source for a Python extension.\n\n:keyword list[str] include_dirs:\n  list of directories to search for C/C++ header files (in Unix\n  form for portability)\n\n:keyword list[tuple[str, str|None]] define_macros:\n  list of macros to define; each macro is defined using a 2-tuple:\n  the first item corresponding to the name of the macro and the second\n  item either a string with its value or None to\n  define it without a particular value (equivalent of \"#define\n  FOO\" in source or -DFOO on Unix C compiler command line)\n\n:keyword list[str] undef_macros:\n  list of macros to undefine explicitly\n\n:keyword list[str] library_dirs:\n  list of directories to search for C/C++ libraries at link time\n\n:keyword list[str] libraries:\n  list of library names (not filenames or paths) to link against\n\n:keyword list[str] runtime_library_dirs:\n  list of directories to search for C/C++ libraries at run time\n  (for shared extensions, this is when the extension is loaded).\n  Setting this will cause an exception during build on Windows\n  platforms.\n\n:keyword list[str] extra_objects:\n  list of extra files to link with (eg. object files not implied\n  by 'sources', static library that must be explicitly specified,\n  binary resource files, etc.)\n\n:keyword list[str] extra_compile_args:\n  any extra platform- and compiler-specific information to use\n  when compiling the source files in 'sources'.  For platforms and\n  compilers where \"command line\" makes sense, this is typically a\n  list of command-line arguments, but for other platforms it could\n  be anything.\n\n:keyword list[str] extra_link_args:\n  any extra platform- and compiler-specific information to use\n  when linking object files together to create the extension (or\n  to create a new static Python interpreter).  Similar\n  interpretation as for 'extra_compile_args'.\n\n:keyword list[str] export_symbols:\n  list of symbols to be exported from a shared extension.  Not\n  used on all platforms, and not generally necessary for Python\n  extensions, which typically export exactly one symbol: \"init\" +\n  extension_name.\n\n:keyword list[str] swig_opts:\n  any extra options to pass to SWIG if a source file has the .i\n  extension.\n\n:keyword list[str] depends:\n  list of files that the extension depends on\n\n:keyword str language:\n  extension language (i.e. \"c\", \"c++\", \"objc\"). Will be detected\n  from the source extensions if not provided.\n\n:keyword bool optional:\n  specifies that a build failure in the extension should not abort the\n  build process, but simply not install the failing extension.\n\n:keyword bool py_limited_api:\n  opt-in flag for the usage of :doc:`Python's limited API <python:c-api/stable>`.\n\n:raises setuptools.errors.PlatformError: if 'runtime_library_dirs' is\n  specified on Windows. (since v63)",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, name, sources, *args, **kw)"
            },
            {
              "name": "__repr__",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "_convert_pyx_sources_to_lang",
              "doc": "Replace sources with .pyx extensions to sources with the target\nlanguage extension. This mechanism allows language authors to supply\npre-converted sources but to prefer the .pyx sources.",
              "signature": "(self)"
            }
          ]
        },
        {
          "name": "PEP420PackageFinder",
          "doc": "Generate a list of all Python packages found within a directory",
          "functions": [
            {
              "name": "_build_filter",
              "doc": "Given a list of patterns, return a callable that will be true only if\nthe input matches at least one of the patterns.",
              "signature": "(*patterns: str) -> Callable[[str], bool]"
            },
            {
              "name": "_looks_like_package",
              "doc": "Does a directory look like a package?",
              "signature": "(_path: Union[str, os.PathLike], _package_name: str) -> bool"
            }
          ]
        },
        {
          "name": "PackageFinder",
          "doc": "Generate a list of all Python packages found within a directory",
          "functions": [
            {
              "name": "_build_filter",
              "doc": "Given a list of patterns, return a callable that will be true only if\nthe input matches at least one of the patterns.",
              "signature": "(*patterns: str) -> Callable[[str], bool]"
            },
            {
              "name": "_looks_like_package",
              "doc": "Does a directory look like a package?",
              "signature": "(path: Union[str, os.PathLike], _package_name: str) -> bool"
            }
          ]
        },
        {
          "name": "Require",
          "doc": "A prerequisite to building or installing a distribution",
          "functions": [
            {
              "name": "__init__",
              "doc": "Initialize self.  See help(type(self)) for accurate signature.",
              "signature": "(self, name, requested_version, module, homepage='', attribute=None, format=None)"
            },
            {
              "name": "full_name",
              "doc": "Return full package/distribution name, w/version",
              "signature": "(self)"
            },
            {
              "name": "get_version",
              "doc": "Get version number of installed module, 'None', or 'default'\n\nSearch 'paths' for module.  If not found, return 'None'.  If found,\nreturn the extracted version attribute, or 'default' if no version\nattribute was specified, or the value cannot be determined without\nimporting the module.  The version is formatted according to the\nrequirement's version format (if any), unless it is 'None' or the\nsupplied 'default'.",
              "signature": "(self, paths=None, default='unknown')"
            },
            {
              "name": "is_current",
              "doc": "Return true if dependency is present and up-to-date on 'paths'",
              "signature": "(self, paths=None)"
            },
            {
              "name": "is_present",
              "doc": "Return true if dependency is present on 'paths'",
              "signature": "(self, paths=None)"
            },
            {
              "name": "version_ok",
              "doc": "Is 'version' sufficiently up-to-date?",
              "signature": "(self, version)"
            }
          ]
        },
        {
          "name": "SetuptoolsDeprecationWarning",
          "doc": "Base class for warning deprecations in ``setuptools``\n\nThis class is not derived from ``DeprecationWarning``, and as such is\nvisible by default.",
          "functions": []
        },
        {
          "name": "Command",
          "doc": "Abstract base class for defining command classes, the \"worker bees\"\nof the Distutils.  A useful analogy for command classes is to think of\nthem as subroutines with local variables called \"options\".  The options\nare \"declared\" in 'initialize_options()' and \"defined\" (given their\nfinal values, aka \"finalized\") in 'finalize_options()', both of which\nmust be defined by every command class.  The distinction between the\ntwo is necessary because option values might come from the outside\nworld (command line, config file, ...), and any options dependent on\nother options must be computed *after* these outside influences have\nbeen processed -- hence 'finalize_options()'.  The \"body\" of the\nsubroutine, where it does all its work based on the values of its\noptions, is the 'run()' method, which must also be implemented by every\ncommand class.",
          "functions": [
            {
              "name": "__getattr__",
              "doc": null,
              "signature": "(self, attr)"
            },
            {
              "name": "__init__",
              "doc": "Create and initialize a new Command object.  Most importantly,\ninvokes the 'initialize_options()' method, which is the real\ninitializer and depends on the actual command being\ninstantiated.",
              "signature": "(self, dist)"
            },
            {
              "name": "_ensure_stringlike",
              "doc": null,
              "signature": "(self, option, what, default=None)"
            },
            {
              "name": "_ensure_tested_string",
              "doc": null,
              "signature": "(self, option, tester, what, error_fmt, default=None)"
            },
            {
              "name": "announce",
              "doc": "If the current verbosity level is of greater than or equal to\n'level' print 'msg' to stdout.",
              "signature": "(self, msg, level=1)"
            },
            {
              "name": "copy_file",
              "doc": "Copy a file respecting verbose, dry-run and force flags.  (The\nformer two default to whatever is in the Distribution object, and\nthe latter defaults to false for commands that don't define it.)",
              "signature": "(self, infile, outfile, preserve_mode=1, preserve_times=1, link=None, level=1)"
            },
            {
              "name": "copy_tree",
              "doc": "Copy an entire directory tree respecting verbose, dry-run,\nand force flags.",
              "signature": "(self, infile, outfile, preserve_mode=1, preserve_times=1, preserve_symlinks=0, level=1)"
            },
            {
              "name": "debug_print",
              "doc": "Print 'msg' to stdout if the global DEBUG (taken from the\nDISTUTILS_DEBUG environment variable) flag is true.",
              "signature": "(self, msg)"
            },
            {
              "name": "dump_options",
              "doc": null,
              "signature": "(self, header=None, indent='')"
            },
            {
              "name": "ensure_dirname",
              "doc": null,
              "signature": "(self, option)"
            },
            {
              "name": "ensure_filename",
              "doc": "Ensure that 'option' is the name of an existing file.",
              "signature": "(self, option)"
            },
            {
              "name": "ensure_finalized",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "ensure_string",
              "doc": "Ensure that 'option' is a string; if not defined, set it to\n'default'.",
              "signature": "(self, option, default=None)"
            },
            {
              "name": "ensure_string_list",
              "doc": "Ensure that 'option' is a list of strings.  If 'option' is\ncurrently a string, we split it either on /,\\s*/ or /\\s+/, so\n\"foo bar baz\", \"foo,bar,baz\", and \"foo,   bar baz\" all become\n[\"foo\", \"bar\", \"baz\"].",
              "signature": "(self, option)"
            },
            {
              "name": "execute",
              "doc": null,
              "signature": "(self, func, args, msg=None, level=1)"
            },
            {
              "name": "finalize_options",
              "doc": "Set final values for all the options that this command supports.\nThis is always called as late as possible, ie.  after any option\nassignments from the command-line or from other commands have been\ndone.  Thus, this is the place to code option dependencies: if\n'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as\nlong as 'foo' still has the same value it was assigned in\n'initialize_options()'.\n\nThis method must be implemented by all command classes.",
              "signature": "(self)"
            },
            {
              "name": "get_command_name",
              "doc": null,
              "signature": "(self)"
            },
            {
              "name": "get_finalized_command",
              "doc": "Wrapper around Distribution's 'get_command_obj()' method: find\n(create if necessary and 'create' is true) the command object for\n'command', call its 'ensure_finalized()' method, and return the\nfinalized command object.",
              "signature": "(self, command, create=1)"
            },
            {
              "name": "get_sub_commands",
              "doc": "Determine the sub-commands that are relevant in the current\ndistribution (ie., that need to be run).  This is based on the\n'sub_commands' class attribute: each tuple in that list may include\na method that we call to determine if the subcommand needs to be\nrun for the current distribution.  Return a list of command names.",
              "signature": "(self)"
            },
            {
              "name": "initialize_options",
              "doc": "Set default values for all the options that this command\nsupports.  Note that these defaults may be overridden by other\ncommands, by the setup script, by config files, or by the\ncommand-line.  Thus, this is not the place to code dependencies\nbetween options; generally, 'initialize_options()' implementations\nare just a bunch of \"self.foo = None\" assignments.\n\nThis method must be implemented by all command classes.",
              "signature": "(self)"
            },
            {
              "name": "make_archive",
              "doc": null,
              "signature": "(self, base_name, format, root_dir=None, base_dir=None, owner=None, group=None)"
            },
            {
              "name": "make_file",
              "doc": "Special case of 'execute()' for operations that process one or\nmore input files and generate one output file.  Works just like\n'execute()', except the operation is skipped and a different\nmessage printed if 'outfile' already exists and is newer than all\nfiles listed in 'infiles'.  If the command defined 'self.force',\nand it is true, then the command is unconditionally run -- does no\ntimestamp checks.",
              "signature": "(self, infiles, outfile, func, args, exec_msg=None, skip_msg=None, level=1)"
            },
            {
              "name": "mkpath",
              "doc": null,
              "signature": "(self, name, mode=511)"
            },
            {
              "name": "move_file",
              "doc": "Move a file respecting dry-run flag.",
              "signature": "(self, src, dst, level=1)"
            },
            {
              "name": "reinitialize_command",
              "doc": null,
              "signature": "(self, command, reinit_subcommands=0)"
            },
            {
              "name": "run",
              "doc": "A command's raison d'etre: carry out the action it exists to\nperform, controlled by the options initialized in\n'initialize_options()', customized by other commands, the setup\nscript, the command-line, and config files, and finalized in\n'finalize_options()'.  All terminal output and filesystem\ninteraction should be done by 'run()'.\n\nThis method must be implemented by all command classes.",
              "signature": "(self)"
            },
            {
              "name": "run_command",
              "doc": "Run some other command: uses the 'run_command()' method of\nDistribution, which creates and finalizes the command object if\nnecessary and then invokes its 'run()' method.",
              "signature": "(self, command)"
            },
            {
              "name": "set_undefined_options",
              "doc": "Set the values of any \"undefined\" options from corresponding\noption values in some other command object.  \"Undefined\" here means\n\"is None\", which is the convention used to indicate that an option\nhas not been changed between 'initialize_options()' and\n'finalize_options()'.  Usually called from 'finalize_options()' for\noptions that depend on some other command rather than another\noption of the same command.  'src_cmd' is the other command from\nwhich option values will be taken (a command object will be created\nfor it if necessary); the remaining arguments are\n'(src_option,dst_option)' tuples which mean \"take the value of\n'src_option' in the 'src_cmd' command object, and copy it to\n'dst_option' in the current command object\".",
              "signature": "(self, src_cmd, *option_pairs)"
            },
            {
              "name": "spawn",
              "doc": "Spawn an external command respecting dry-run flag.",
              "signature": "(self, cmd, search_path=1, level=1)"
            },
            {
              "name": "warn",
              "doc": null,
              "signature": "(self, msg)"
            }
          ]
        },
        {
          "name": "sic",
          "doc": "Treat this string as-is (https://en.wikipedia.org/wiki/Sic)",
          "functions": []
        }
      ]
    }
  }
]